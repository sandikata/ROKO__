diff --git defaults/initrd.defaults defaults/initrd.defaults
index 76d72a7..0c059a5 100755
--- defaults/initrd.defaults
+++ defaults/initrd.defaults
@@ -68,6 +68,7 @@ fi
 
 REAL_ROOT=''
 CDROOT='0'
+SCRATCH='0'
 CDROOT_DEV=''
 CDROOT_TYPE='auto'
 NEW_ROOT='/newroot'
diff --git defaults/initrd.scripts defaults/initrd.scripts
index 51ebcce..b2d3d5d 100755
--- defaults/initrd.scripts
+++ defaults/initrd.scripts
@@ -187,23 +187,45 @@ cache_cd_contents() {
 			# TODO: Check the size of the image versus the size of our tmpfs
 			# along with the amount of available RAM and increase tmpfs size
 			# if necessary. (Not having awk sucks...)
-			# z=0
-			# for i in $(cat /proc/meminfo | grep -e ^MemFree -e ^Cached | \
-			# cut -d: -f2 | cut -dk -f1 | sed -e "s/^\s*//") ; do
-			# z=$(($z + $i)) ; done
-			# echo $z
-			good_msg "Copying loop file for caching..."
-			# Verify that the needed directory exists
-			mkdir -p "$(dirname ${NEW_ROOT}/mnt/${LOOP})"
-			cp -a ${NEW_ROOT}/mnt/cdrom/${LOOP} ${NEW_ROOT}/mnt/${LOOP}
-			if [ $? -ne 0 ]
+
+			# getting memory
+			allmemory=0
+			for i in $(cat /proc/meminfo | grep -e ^MemFree -e ^Cached | \
+				cut -d: -f2 | cut -dk -f1 | sed -e "s/^\s*//") ;
+			do
+				allmemory=$(($allmemory + $i))
+			done
+
+			# getting size tmpfs of default
+			let curtfs=$allmemory/2
+
+			# getting size of image
+			let imagesize=`ls -la ${NEW_ROOT}/mnt/cdrom/${LOOP} | sed -r -n 's/(\S*\s*){4}(\S*).*/\2/p'`/20000*21
+			let addon=$imagesize/10
+			if [[ $curtfs -gt $(( ${imagesize} + ${addon} )) ]];
 			then
-				bad_msg "Failed to cache the loop file! Lack of space?"
-				rm -rf ${NEW_ROOT}/mnt/livecd.* 2>/dev/null
-				rm -rf ${NEW_ROOT}/mnt/image.* 2>/dev/null
-				rm -rf ${NEW_ROOT}/mnt/zisofs 2>/dev/null
+				let addon=$(( $curtfs - ${imagesize} ))
+			fi
+
+			if [[ $((${imagesize} + $addon)) -lt ${allmemory} ]];
+			then
+				mount -o remount,size=${addon}000 -t tmpfs tmpfs ${NEW_ROOT}
+				mkdir ${NEW_ROOT}/mnt/squash
+				mount -o size=${imagesize}000 -t tmpfs tmpfs ${NEW_ROOT}/mnt/squash
+				good_msg "Copying loop file for caching..."
+				cp -a ${NEW_ROOT}/mnt/cdrom/${LOOP} ${NEW_ROOT}/mnt/squash/${LOOP}
+				if [ $? -ne 0 ]
+				then
+					bad_msg "Failed to cache the loop file! Lack of space?"
+					umount ${NEW_ROOT}/mnt/squash
+					mount -o remount,size=${curtfs}000 -t tmpfs tmpfs ${NEW_ROOT}
+				else
+					LOOPEXT='../squash/'
+					good_msg "Unmounting media from ${NEW_ROOT}/mnt/cdrom"
+					umount ${NEW_ROOT}/mnt/cdrom
+				fi
 			else
-				LOOPEXT='../'
+				bad_msg "Too low memory for cache the loop file."
 			fi
 		fi
 	fi
@@ -266,7 +288,7 @@ findnfsmount() {
 			if [ "${CDROOT}" != '0' ]
 			then
 				good_msg "Attempting to mount NFS CD image on ${NFSROOT} with options ${NFSOPTIONS}"
-				mount -t nfs -o ${NFSOPTIONS} ${NFSROOT} ${NEW_ROOT}/mnt/cdrom
+				busybox mount -t nfs -o ${NFSOPTIONS} ${NFSROOT} ${NEW_ROOT}/mnt/cdrom
 				if [ "$?" = '0' ]
 				then
 					REAL_ROOT="/dev/nfs"
@@ -275,7 +297,7 @@ findnfsmount() {
 				fi
 			else	
 				good_msg "Attempting to mount NFS root on ${NFSROOT} with options ${NFSOPTIONS}"
-				mount -t nfs -o ${NFSOPTIONS} ${NFSROOT} ${NEW_ROOT}
+				busybox mount -t nfs -o ${NFSOPTIONS} ${NFSROOT} ${NEW_ROOT}
 				if [ "$?" = '0' ]
 				then
 					REAL_ROOT="/dev/nfs"
@@ -655,7 +677,7 @@ startVolumes() {
 			[ -d /etc/lvm/cache ] && lvm_commands="${lvm_commands} \nvgscan"
 
 			# To activate volumegroups on all devices in the cache
-			lvm_commands="${lvm_commands} \nvgchange -ay --sysinit"
+			lvm_commands="${lvm_commands} \nvgchange -ay --sysinit --noudevsync"
 
 			# And finally execute it all (/proc/... needed if lvm is compiled without readline)
 			good_msg "Scanning for and activating Volume Groups"
@@ -1082,6 +1104,38 @@ getdvhoff() {
 	echo $(( $(hexdump -n 4 -s $((316 + 12 * $2)) -e '"%i"' $1) * 512))
 }
 
+load_union_module() {
+	UNIONTYPE=""
+	# find module for union file system
+	[ -n "$(find /lib/ -name unionfs.ko)" ] && UNIONTYPE="unionfs"
+	[ -n "$(find /lib/ -name aufs.ko)" ] && UNIONTYPE="aufs"
+	# probably aufs in kernel
+	if [ -n "$(gzip -dc /proc/config.gz | grep CONFIG_AUFS_FS=y )" ]
+	then
+		UNIONTYPE="aufs"
+	else
+		if [ -z "${UNIONTYPE}" ]
+		then
+			bad_msg "Module for union file system is not found!"
+			run_shell
+		else
+			modprobe ${UNIONTYPE} > /dev/null 2>&1
+			# error on load union module
+			if [ -z "$(lsmod | grep $UNIONTYPE)" ]
+			then
+				bad_msg "Module for union file system is not correct!"
+				if [[ ${UNIONTYPE} = aufs ]]
+				then
+					bad_msg "Probably kernel compiled without standalone patch."
+				fi
+				run_shell
+			fi
+
+			good_msg "Loading ${UNIONTYPE}"
+		fi
+	fi
+}
+
 setup_unionfs() {
 	local rw_dir=$1
 	local ro_dir=$2
@@ -1101,6 +1155,7 @@ setup_unionfs() {
 		mkdir -p ${UNION}
 		good_msg "Loading fuse module"
 		modprobe fuse > /dev/null 2>&1
+		load_union_module
 #                 if [ -n "${UNIONFS}" ] 	 
 #                 then 	 
 #                         CHANGESDEV=${UNIONFS} 	 
@@ -1130,11 +1185,102 @@ setup_unionfs() {
 		mkdir /tmp
 		mkdir -p ${UNION}
 #		mkdir -p $CHANGES
-#		mount -t unionfs -o dirs=$CHANGES=rw unionfs ${UNION}
+##		mount -t unionfs -o dirs=$CHANGES=rw unionfs ${UNION}
+
+		if [ "${SCRATCH}" -ne 0 ];
+		then
+			good_msg "Loading in scratch mode"
+			BUILDERDIR=${UNION}/mnt/builder
+			SCRATCHDIR=${UNION}/mnt/scratch
+			DELTADIR=${rw_dir}/mnt/delta
+			WORKSPACEDIR=${rw_dir}/mnt/workspace
+			mount -o remount,rw ${rw_dir}/mnt/cdrom >/dev/null 2>&1
+			touch ${rw_dir}/mnt/cdrom/livecd >/dev/null 2>&1
+			if [ "$?" -ne 0 ];
+			then
+				ISRW=0
+			else
+				ISRW=1
+			fi
+
+			mkdir -p ${DELTADIR}
+			mkdir -p ${WORKSPACEDIR}
+			if [[ ${UNIONTYPE} = aufs ]]
+			then
+				if ! mount -t aufs -o udba=reval,br:${WORKSPACEDIR}=rw:${DELTADIR}=ro+wh:${rw_dir}/mnt/livecd=ro none ${UNION}
+				then
+					bad_msg "Can't setup union mount!"
+					run_shell
+				fi
+			else
+				mount -t unionfs -o dirs=${WORKSPACEDIR}=rw:${DELTADIR}=ro:${rw_dir}/mnt/livecd=ro unionfs ${UNION}
+			fi
+			tmpret=$?;[ "$tmpret" -ne 0 ] && ret=$tmpret
+			mkdir -p ${SCRATCHDIR}/calculate
+			mkdir -p ${SCRATCHDIR}/delta
+			mkdir -p ${SCRATCHDIR}/workspace
+			mount -o bind ${rw_dir}/mnt/delta ${SCRATCHDIR}/delta
+			tmpret=$?;[ "$tmpret" -ne 0 ] && ret=$tmpret
+			mount -o bind ${rw_dir}/mnt/workspace ${SCRATCHDIR}/workspace
+			tmpret=$?;[ "$tmpret" -ne 0 ] && ret=$tmpret
+			mkdir -p ${BUILDERDIR}
+			if [[ ${UNIONTYPE} = aufs ]]
+			then
+				if ! mount -t aufs -o udba=reval,br:${DELTADIR}=rw:${rw_dir}/mnt/livecd=ro none ${BUILDERDIR}
+				then
+					bad_msg "Can't setup union mount!"
+					run_shell
+				fi
+			else
+				mount -t unionfs -o dirs=${DELTADIR}=rw:${rw_dir}/mnt/livecd=ro unionfs ${BUILDERDIR}
+			fi
+			tmpret=$?;[ "$tmpret" -ne 0 ] && ret=$tmpret
+			mount -o bind,ro ${rw_dir}/mnt/livecd ${SCRATCHDIR}/calculate
+			tmpret=$?;[ "$tmpret" -ne 0 ] && ret=$tmpret
+			if [ "$ISRW" -ne 0 ];
+			then
+				FLASHDIR=${UNION}/mnt/flash
+				mkdir -p ${FLASHDIR}
+				mount -o bind ${rw_dir}/mnt/cdrom ${FLASHDIR}
+				tmpret=$?;[ "$tmpret" -ne 0 ] && ret=$tmpret
+			else
+				CDROMDIR=${UNION}/mnt/cdrom
+				mkdir -p ${CDROMDIR}
+				mount -o bind,ro ${rw_dir}/mnt/cdrom ${CDROMDIR}
+				tmpret=$?;[ "$tmpret" -ne 0 ] && ret=$tmpret
+			fi
+		else
+			CDROMDIR=${UNION}/mnt/cdrom
+			LIVECDDIR=${UNION}/mnt/livecd
+
+			if [[ ${UNIONTYPE} = aufs ]]
+			then
+				if ! mount -t aufs -o udba=reval,br:${rw_dir}:${ro_dir}=ro none ${UNION}
+				then
+					bad_msg "Can't setup union mount!"
+					run_shell
+				fi
+			else
+				mount -t unionfs -o dirs=${rw_dir}:${ro_dir}=ro unionfs ${UNION}
+			fi
+
+			if [[ -n "$( echo ${LOOPEXT} | grep squash )" ]];
+			then
+				mkdir -p ${UNION}/mnt/squash
+				mount -o bind ${NEW_ROOT}/mnt/squash ${UNION}/mnt/squash &>/dev/null
+			fi
+
+			chmod 0755 ${UNION}
+			mount -o bind ${rw_dir}/mnt/cdrom ${CDROMDIR} &>/dev/null
+			mount -o bind ${rw_dir}/mnt/livecd ${LIVECDDIR} &>/dev/null
+			ret=$?
+		fi
+
+		chmod 1777 ${UNION}/tmp
 		good_msg "Creating union mount"
-		unionfs -o allow_other,cow,noinitgroups,suid,dev,default_permissions,use_ino ${rw_dir}=RW:${ro_dir}=RO ${UNION} 2>/dev/null
-		ret=$?
-		if [ ${ret} -ne 0 ]
+#		unionfs -o allow_other,cow,noinitgroups,suid,dev,default_permissions,use_ino ${rw_dir}=RW:${ro_dir}=RO ${UNION} 2>/dev/null
+#		ret=$?
+		if [ "${ret}" -ne 0 ]
 		then
 			bad_msg "Can't setup union mount!"
 			USE_UNIONFS_NORMAL=0
@@ -1143,3 +1289,110 @@ setup_unionfs() {
 		USE_UNIONFS_NORMAL=0
 	fi
 }
+
+load_videodrv() {
+	good_msg "Loading frame buffer video driver"
+	# find all available fb drivers
+	videodrv_count=$(find /lib/modules \
+		-name "nouveau.ko" -o \
+		-name "uvesafb.ko" -o \
+		-name "i915.ko" -o \
+		-name "radeon.ko" |
+		grep -c "")
+	# load specified videodrv
+	modules_list=
+	case "${VIDEODRV}" in
+		nouveau)
+			modules_list="nouveau"
+			;;
+		radeon)
+			modules_list="radeon"
+			;;
+		i915|intel)
+			modules_list="i915"
+			;;
+		""|auto)
+			# if not livecd and initramfs otimized (aviailable only one video driver)
+			if [ "${CDROOT}" != '1' -a "${videodrv_count}" -le 2 ]
+			then
+				modules_list="nouveau i915 radeon"
+			else
+				if [[ -x /usr/sbin/lspci ]]
+				then
+					if lspci | grep -m1 VGA | grep -qi intel
+					then
+						modules_list="i915"
+					elif lspci | grep -m1 VGA | grep -qi nvidia
+					then
+						modules_list="nouveau"
+					elif lspci | grep -m1 VGA | grep -q -e "Ati" -e "ATI"
+					then
+						modules_list="radeon"
+					else
+						modules_list=""
+					fi
+				else
+					modules_list="i915"
+				fi
+			fi
+			;;
+	esac
+	for x in $modules_list
+	do
+		if [ "`find /lib/modules -name "${x}.ko" | grep -c ''`" -eq "1" ]
+		then
+			modprobe "${x}" modeset=${USE_MODESET} &>/dev/null
+			lsmod | grep -q "${x}" && return 0
+		fi
+	done
+	# else load uvesafb with specified video resolution
+	if [ -n "${VIDEORES}" ]
+	then
+		if ! echo $VIDEORES | grep -q "\-"
+		then
+			VIDEORES="${VIDEORES}-32"
+		fi
+	else
+		VIDEORES="1024x768-32"
+	fi
+	modprobe uvesafb mode_option=${VIDEORES} &>/dev/null
+}
+
+start_udev()
+{
+	# start udev
+	if [ "${USE_UDEV}" == "1" ]
+	then
+		echo "" >/proc/sys/kernel/hotplug
+		udevd --daemon &>/dev/null
+		udevadm settle
+	fi
+}
+
+stop_udev()
+{
+	# kill udevd
+	if [ "${USE_UDEV}" == "1" ]
+	then
+		pkill udevd &>/dev/null
+	fi
+}
+
+populate_dev()
+{
+	good_msg 'Activating udev'
+	# Do not run any init-scripts
+	udevadm control --property=do_not_run_plug_service=1
+
+	if [ "${REAL_ROOT}" == "/dev/nfs" ]
+	then
+		rm /etc/modprobe.d/blacklist.conf
+	fi
+	# discarding net drivers placed into blacklist.conf
+	udevadm trigger --action="add"
+
+	# we can speed up booting under these conditions:
+	#  * using devtmpfs so kernel creates device nodes for us
+	#  * only using kernel created device nodes at boot (in /etc/fstab and elsewhere)
+	udevadm settle --timeout=60
+}
diff --git defaults/linuxrc defaults/linuxrc
index 0843f5d..8109d09 100755
--- defaults/linuxrc
+++ defaults/linuxrc
@@ -39,6 +39,13 @@ FAKE_ROOT=''
 REAL_ROOTFLAGS=''
 ROOTFSTYPE='auto'
 CRYPT_SILENT=0
+VIDEODRV=''
+USE_UDEV=1
+USE_MODESET=1
+if [ -e "/etc/calculate/calculate.ini" ]
+then
+	source /etc/calculate/calculate.ini
+fi
 for x in ${CMDLINE}
 do
 	case "${x}" in
@@ -57,6 +64,57 @@ do
 		init_opts\=*)
 			INIT_OPTS=`parse_opt "${x}"`
 		;;
+		nokms)
+			USE_MODESET=0
+		;;
+		kms)
+			USE_MODESET=1
+		;;
+		noudev)
+			USE_UDEV=0
+			;;
+		calculate\=*)
+			CALCULATE=`parse_opt "${x}"`
+			if [[ "${CALCULATE//:/}" != "${CALCULATE}" ]]
+			then
+				for i in ${CALCULATE//,/ }
+				do
+					case "${i}" in
+						video:*)
+							VIDEODRV=`echo "${i}" | cut -s -d: -f2-`
+							;;
+						resolution:*)
+							RES=`echo "${i}" | cut -s -d: -f2-`
+							if [ -n "${RES}" -a "${RES}" != "auto" ]
+							then
+								VIDEORES=${RES}-32
+							fi
+							;;
+					esac
+				done
+			else
+				RES=`echo "${CALCULATE}" | cut -s -d, -f4`
+				if [ -n "${RES}" -a "${RES}" != "auto" ]
+				then
+					VIDEORES=${RES}-32
+				fi
+				VIDEODRV=`echo "${CALCULATE}" | cut -s -d, -f5`
+			fi
+		;;
+		video\=*)
+			VR=`parse_opt "${x}"`
+			for i in ${VR//,/ }
+			do
+				if [ -z "${i//[0-9-x@]}" ]
+				then
+					VIDEORES=${i}
+				fi
+			done
+		;;
+		# Scratch usbload
+		scratch)
+			SCRATCH=1
+		;;
 		# Livecd options
 		cdroot)
 			CDROOT=1
@@ -251,15 +309,24 @@ then
 	REAL_ROOT="${FAKE_ROOT}"	
 fi
 
-splash 'init'
-
-cmdline_hwopts
+# check udevd
+[ ! -x /sbin/udevd ] && USE_UDEV=0
 
 # Mount sysfs
 mount_sysfs
 
+# start udev
+start_udev
+
+# load kernel video driver
+load_videodrv
+
+splash 'init'
+
+cmdline_hwopts
+
 # Setup hotplugging for firmware loading
-setup_hotplug
+[ "${USE_UDEV}" == "0" ] && setup_hotplug
 
 # Load modules listed in MY_HWOPTS if /lib/modules exists for the running kernel
 if [ -z "${DO_modules}" ]
@@ -269,7 +336,7 @@ elif [ -d "/lib/modules/${KV}" ]
 then
 	good_msg 'Loading modules'
 	# Load appropriate kernel modules
-	if [ "${NODETECT}" != '1' ]
+	if [ "${USE_UDEV}" != '1' -a "${NODETECT}" != '1' ]
 	then
 		for modules in ${MY_HWOPTS}
 		do
@@ -285,14 +352,20 @@ fi
 # Apply scan delay if specified
 sdelay
 
-# Setup slow USB bits
-setup_slowusb
+if [ "${USE_UDEV}" == "1" ]
+then
+	# populate /dev with devices already found by the kernel
+	populate_dev
+else
+	# Setup slow USB bits
+	setup_slowusb
 
-# Start device manager
-start_dev_mgr
+	# Start device manager
+	start_dev_mgr
 
-# if doslowusb is passed, pause other 10 seconds here, after mdev load
-[ "${DO_slowusb}" ] && sleep 10
+	# if doslowusb is passed, pause other 10 seconds here, after mdev load
+	[ "${DO_slowusb}" ] && sleep 10
+fi
 
 # Start iSCSI
 if [ -e /bin/iscsistart ]
@@ -509,9 +582,50 @@ do
 			then
 				break
 			else
-				bad_msg "The filesystem mounted at ${REAL_ROOT} does not appear to be a valid /, try again"
-				got_good_root=0
-				REAL_ROOT=''
+				# check for scratch
+				if [ -e ${NEW_ROOT}/livecd.squashfs -a -d ${NEW_ROOT}/delta -a -d ${NEW_ROOT}/workspace ];
+				then
+					good_msg 'Found scratch data...'
+					load_union_module
+					modprobe squashfs >/dev/null
+					if mount -o remount,rw ${NEW_ROOT};
+					then
+						mkdir -p ${NEW_ROOT}/calculate && mkdir -p /union && mkdir -p ${NEW_ROOT}/workspace/mnt/builder && mkdir -p ${NEW_ROOT}/workspace/mnt/scratch
+						if mount -o loop,ro -t squashfs ${NEW_ROOT}/livecd.squashfs ${NEW_ROOT}/calculate;
+						then
+							if [[ ${UNIONTYPE} = aufs ]]
+							then
+								if mount -t aufs -o ro,udba=reval,br:${NEW_ROOT}/workspace=rw:${NEW_ROOT}/delta=ro+wh:${NEW_ROOT}/calculate=ro none /union;
+								then
+									mount -t aufs -o ro,udba=reval,br:${NEW_ROOT}/delta=rw:${NEW_ROOT}/calculate=ro none /union/mnt/builder
+									CHROOT=/union
+									break;
+								else
+									bad_msg 'Could not merge scratch layers!'
+									run_shell
+								fi
+							else
+								if mount -t unionfs -o ro,dirs=${NEW_ROOT}/workspace:${NEW_ROOT}/delta=ro:${NEW_ROOT}/calculate=ro unionfs /union;
+								then
+									mount -t unionfs -o ro,dirs=${NEW_ROOT}/delta:${NEW_ROOT}/calculate=ro unionfs /union/mnt/builder
+									CHROOT=/union
+									break;
+								else
+									bad_msg 'Could not merge scratch layers'
+									run_shell
+								fi
+							fi
+						else
+							bad_msg 'Could not mount scratch squashfs image'
+						fi
+					else
+						bad_msg 'Could not remount ${NEW_ROOT}'
+					fi
+				else
+					bad_msg "The filesystem mounted at ${REAL_ROOT} does not appear to be a valid /, try again"
+					got_good_root=0
+					REAL_ROOT=''
+				fi
 			fi
 		else
 			bad_msg "Could not mount specified ROOT, try again"
@@ -723,9 +837,12 @@ cd "${CHROOT}"
 mkdir "${CHROOT}/proc" "${CHROOT}/sys" 2>/dev/null
 echo -ne "${BOLD}.${NORMAL}"
 
+# stop udev before move mount points
+stop_udev
+
 # If devtmpfs is mounted, try move it to the new root
 # If that fails, try to unmount all possible mounts of devtmpfs as stuff breaks otherwise
-for fs in /dev /sys /proc
+for fs in "/dev " /sys /proc
 do
 	if grep -qs "$fs" /proc/mounts
 	then
diff --git defaults/modprobe defaults/modprobe
index ba2d890..9280357 100755
--- defaults/modprobe
+++ defaults/modprobe
@@ -10,8 +10,6 @@ usage() {
 	echo
 	echo 'Example:'
 	echo '  modprobe eepro100'
-	echo
-	echo 'Note: Do not pass the suffix to modprobe!'
 	exit 1
 }
 
@@ -81,14 +79,29 @@ modprobe2() {
 		usage
 		exit 1
 	fi
-	real_path=`real_mod_path ${1}`
+	local modname=${1}
+	local quiet=''
+	local params=''
+	shift
+	for x in $@
+	do
+		case ${x} in
+			-n)
+				quiet=1
+				;;
+			*)
+				params="${params} ${x}"
+				;;
+		esac
+	done
+	real_path=`real_mod_path ${modname}`
 	if [ "${real_path}" = '' -o "${real_path}" = ' ' ]
 	then
-		[ "${2}" = '-n' ] && echo -n " -> $1"
+		[ "${quiet}" = '1' ] && echo -n " -> ${modname}"
 		echo ' module not found.'
 		exit 2
 	fi
-	modlist=`modules_dep_list ${1}`
+	modlist=`modules_dep_list ${modname}`
 	if [ "${modlist}" != '' -a "${modlist}" != ' ' ]
 	then
 		deps=`strip_mod_paths ${modlist}`
@@ -110,13 +123,13 @@ modprobe2() {
 			filler=1
 		fi
 	done
-	${INSMOD} ${real_path} > /dev/null 2>&1
+	${INSMOD} ${real_path} ${params} > /dev/null 2>&1
 	ret=$?
 	if [ ${ret} -eq 0 ]
 	then
 		echoAppend=' loaded.'
-		[ "${2}" = '-n' ] && echoFlags='-n' && echoAppend=', '
-		echo ${echoFlags} "${1}${echoAppend}"
+		[ "${quiet}" = '1' ] && echoFlags='-n' && echoAppend=', '
+		echo ${echoFlags} "${modname}${echoAppend}"
 	fi
 	return $ret
 }
@@ -132,7 +145,7 @@ do
 	LOADED_MODULES="${LOADED_MODULES} ${x}"
 done
 
-modprobe2 ${1}
+modprobe2 ${@}
 modprobe_ret=$?
 
 [ -f '/modules.cache' ] && rm -f /modules.cache > /dev/null 2>&1
diff --git dracut_funcs.sh dracut_funcs.sh
new file mode 100755
index 0000000..e80a638
--- /dev/null
+++ dracut_funcs.sh
@@ -0,0 +1,752 @@
+#!/bin/bash
+# -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
+# ex: ts=8 sw=4 sts=4 et filetype=sh
+#
+# functions used by dracut and other tools.
+#
+# Copyright 2005-2009 Red Hat, Inc.  All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+IF_RTLD=""
+IF_dynamic=""
+
+# Generic substring function.  If $2 is in $1, return 0.
+strstr() { [[ $1 =~ $2 ]]; }
+
+# Create all subdirectories for given path without creating the last element.
+# $1 = path
+mksubdirs() { mkdir -p ${1%/*}; }
+
+# Version comparision function.  Assumes Linux style version scheme.
+# $1 = version a
+# $2 = comparision op (gt, ge, eq, le, lt, ne)
+# $3 = version b
+vercmp() {
+    local n1=(${1//./ }) op=$2 n2=(${3//./ }) i res
+
+    for ((i=0; ; i++))
+    do
+        if [[ ! ${n1[i]}${n2[i]} ]]; then res=0
+        elif ((${n1[i]:-0} > ${n2[i]:-0})); then res=1
+        elif ((${n1[i]:-0} < ${n2[i]:-0})); then res=2
+        else continue
+        fi
+        break
+    done
+
+    case $op in
+        gt) ((res == 1));;
+        ge) ((res != 2));;
+        eq) ((res == 0));;
+        le) ((res != 1));;
+        lt) ((res == 2));;
+        ne) ((res != 0));;
+    esac
+}
+
+is_func() {
+     [[ $(type -t $1) = "function" ]] 
+}
+
+# Log initrd creation.
+if ! [[ $dracutlogfile ]]; then
+    [[ $dracutbasedir = /usr/share/dracut ]] && \
+        dracutlogfile=/var/log/dracut.log || \
+        dracutlogfile=/tmp/dracut.log
+#    [[ -w $dracutlogfile ]] || dracutlogfile=/tmp/dracut.log
+    if [[ -w $dracutlogfile ]]; then
+        >"$dracutlogfile"
+    fi
+fi
+
+dwarning() {
+    echo "W: $@" >&2
+    [[ -w $dracutlogfile ]] && echo "W: $@" >>"$dracutlogfile"
+}
+
+dinfo() {
+    [[ $beverbose ]] && echo "I: $@" >&2
+    [[ -w $dracutlogfile ]] && echo "I: $@" >>"$dracutlogfile"
+}
+
+derror() {
+    echo "E: $@" >&2
+    [[ -w $dracutlogfile ]] && echo "E: $@" >>"$dracutlogfile"
+}
+
+# Function prints global variables in format name=value line by line.
+# $@ = list of global variables' name
+print_vars() {
+    local var value
+
+    for var in $@
+    do
+        value=$(eval echo \$$var)
+        [[ ${value} ]] && echo "${var}=\"${value}\""
+    done
+}
+
+get_fs_env() {
+    [[ $1 ]] || return
+    eval $(udevadm info --query=env --name=$1|egrep 'ID_FS_(TYPE|UUID)=')
+    [[ $ID_FS_TYPE ]] && return
+
+    if [[ -x /lib/udev/vol_id ]]; then
+        eval $(/lib/udev/vol_id --export $1)
+    elif find_binary blkid >/dev/null; then
+        eval $(blkid -o udev $1)
+    else
+        return 1
+    fi
+}
+
+get_fs_type() (
+    [[ $1 ]] || return
+    if [[ $1 != ${1#/dev/block/nfs:} ]] \
+        || [[ $1 != ${1#/dev/block/nfs3:} ]] \
+        || [[ $1 != ${1#/dev/block/nfs4:} ]]; then
+        echo "nfs"
+        return
+    fi
+    get_fs_env $1 || return
+    echo $ID_FS_TYPE
+)
+
+get_fs_uuid() (
+    get_fs_env $1 || return
+    echo $ID_FS_UUID
+)
+
+# finds the major:minor of the block device backing the root filesystem.
+find_block_device() {
+    local x mpt majmin dev fs misc maj min
+    if [[ $use_fstab != yes ]]; then    
+        while read x x majmin x mpt x x fs dev misc; do
+            [[ $fs = nfs ]] && { echo $dev; return 0;}
+            [[ $fs = nfs3 ]] && { echo $dev; return 0;}
+            [[ $fs = nfs4 ]] && { echo $dev; return 0;}
+            [[ $fs = btrfs ]] && {
+                ls -nLl "$dev" | { 
+                    read x x x x maj min x;
+                    maj=${maj//,/}; 
+                    echo $maj:$min; 
+                } && return 0
+            }
+            if [[ $mpt = $1 ]] && [[ ${majmin#0:} = $majmin ]]; then
+                echo $majmin; 
+                return 0 # we have a winner!
+            fi
+        done < /proc/self/mountinfo       
+    fi
+    # fall back to /etc/fstab    
+    while read dev mpt fs misc; do
+        if [[ $mpt = $1 ]]; then
+            [[ $fs = nfs ]] && { echo $dev; return 0;}
+            [[ $fs = nfs3 ]] && { echo $dev; return 0;}
+            [[ $fs = nfs4 ]] && { echo $dev; return 0;}
+            [[ $dev != ${dev#UUID=} ]] && dev=/dev/disk/by-uuid/${dev#UUID=}
+            [[ $dev != ${dev#LABEL=} ]] && dev=/dev/disk/by-label/${dev#LABEL=}
+            [[ -b $dev ]] || return 1 # oops, not a block device.
+            ls -nLl "$dev" | { 
+                read x x x x maj min x;
+                maj=${maj//,/}; 
+                echo $maj:$min; 
+            } && return 0
+        fi
+    done < /etc/fstab
+    return 1;
+}
+
+find_root_block_device() { find_block_device /; }
+
+# Walk all the slave relationships for a given block device.
+# Stop when our helper function returns success
+# $1 = function to call on every found block device
+# $2 = block device in major:minor format
+check_block_and_slaves() {    
+    local x 
+    [[ -b /dev/block/$2 ]] || return 1 # Not a block device? So sorry.
+    "$1" $2 && return
+    check_vol_slaves "$@" && return 0
+    if [[ -f /sys/dev/block/$2/../dev ]]; then
+        check_block_and_slaves $1 $(cat "/sys/dev/block/$2/../dev") &&  return 0
+    fi
+    [[ -d /sys/dev/block/$2/slaves ]] || return 1
+    for x in /sys/dev/block/$2/slaves/*/dev; do
+        [[ -f $x ]] || continue
+        check_block_and_slaves $1 $(cat "$x") &&  return 0
+    done
+    return 1
+}
+
+get_numeric_dev() {
+    ls -lH "$1" | { read a b c d maj min rest; printf "%d:%d" ${maj%%,} $min;}
+}
+
+# ugly workaround for the lvm design
+# There is no volume group device,
+# so, there are no slave devices for volume groups.
+# Logical volumes only have the slave devices they really live on,
+# but you cannot create the logical volume without the volume group.
+# And the volume group might be bigger than the devices the LV needs.
+check_vol_slaves() {
+    for i in /dev/mapper/*; do 
+        lv=$(get_numeric_dev $i)
+        if [[ $lv = $2 ]]; then
+            vg=$(lvm lvs --noheadings -o vg_name $i 2>/dev/null)
+            # strip space
+            vg=$(echo $vg)
+            if [[ $vg ]]; then
+                for pv in $(lvm vgs --noheadings -o pv_name "$vg" 2>/dev/null); \
+                    do
+                    check_block_and_slaves $1 $(get_numeric_dev $pv) \
+                        &&  return 0
+                done
+            fi
+        fi
+    done
+    return 1
+}
+
+# Install a directory, keeping symlinks as on the original system.
+# Example: if /lib64 points to /lib on the host, "inst_dir /lib/file"
+# will create ${initdir}/lib64, ${initdir}/lib64/file,
+# and a symlink ${initdir}/lib -> lib64.
+inst_dir() {
+    local dir="$1"
+    [[ -e ${initdir}$dir ]] && return 0
+
+    # iterate over parent directories
+    local file=""
+    local IFS="/"
+    for part in $dir; do
+        [[ $part ]] || continue
+        file="$file/$part"
+        [[ -e ${initdir}$file ]] && continue
+
+        if [[ -L $file ]]; then
+            # create link as the original
+            local target=$(readlink "$file")
+            ln -sfn "$target" "${initdir}$file" || return 1
+            # resolve relative path and recursively install destionation
+            [[ $target = ${target##*/} ]] && target="${file%/*}/$target"
+            inst_dir "$target"
+        else
+            # create directory
+            mkdir -p "${initdir}$file" || return 1
+        fi
+    done
+}
+
+# $1 = file to copy to ramdisk
+# $2 (optional) Name for the file on the ramdisk
+# Location of the image dir is assumed to be $initdir
+# We never overwrite the target if it exists.
+inst_simple() {
+    local src target
+    [[ -f $1 ]] || return 1
+    src=$1 target="${2:-$1}"
+    if ! [[ -d ${initdir}$target ]]; then
+        [[ -e ${initdir}$target ]] && return 0
+        inst_dir "${target%/*}"
+    fi
+    dinfo "Installing $src" 
+    cp -pfL "$src" "${initdir}$target"
+}
+
+# find symlinks linked to given library file
+# $1 = library file
+# Function searches for symlinks by stripping version numbers appended to
+# library filename, checks if it points to the same target and finally
+# prints the list of symlinks to stdout.
+#
+# Example:
+# rev_lib_symlinks libfoo.so.8.1
+# output: libfoo.so.8 libfoo.so
+# (Only if libfoo.so.8 and libfoo.so exists on host system.)
+rev_lib_symlinks() {
+    [[ ! $1 ]] && return 0
+
+    local fn="$1" orig="$(readlink -f "$1")" links=''
+
+    [[ ${fn} =~ .*\.so\..* ]] || return 1
+
+    until [[ ${fn##*.} == so ]]; do
+        fn="${fn%.*}"
+        [[ -L ${fn} && $(readlink -f "${fn}") == ${orig} ]] && links+=" ${fn}"
+    done
+
+    echo ${links}
+}
+
+# Same as above, but specialized to handle dynamic libraries.
+# It handles making symlinks according to how the original library
+# is referenced.
+inst_library() {
+    local src=$1 dest=${2:-$1} lib reallib symlink
+    [[ -e $initdir$dest ]] && return 0
+    if [[ -L $src ]]; then
+        reallib=$(readlink -f "$src")
+        lib=${src##*/}
+        inst_simple "$reallib" "$reallib"
+        inst_dir "${dest%/*}"
+        (cd "${initdir}${dest%/*}" && ln -s "$reallib" "$lib")
+    else
+        inst_simple "$src" "$dest"
+    fi
+
+    # Create additional symlinks.  See rev_symlinks description.
+    for symlink in $(rev_lib_symlinks $src) $(rev_lib_symlinks $reallib); do
+        [[ ! -e $initdir$symlink ]] && {
+            dinfo "Creating extra symlink: $symlink"
+            inst_symlink $symlink
+        }
+    done
+}
+
+# find a binary.  If we were not passed the full path directly,
+# search in the usual places to find the binary.
+find_binary() {
+    local binpath="/bin /sbin /usr/bin /usr/sbin" p
+    [[ -z ${1##/*} && -x $1 ]] && { echo $1; return 0; } 
+    for p in $binpath; do
+        [[ -x $p/$1 ]] && { echo "$p/$1"; return 0; }
+    done
+    return 1
+}
+
+# Same as above, but specialized to install binary executables.
+# Install binary executable, and all shared library dependencies, if any.
+inst_binary() {
+    local bin target
+    bin=$(find_binary "$1") || return 1
+    target=${2:-$bin}
+    inst_symlink $bin $target && return 0
+    local LDSO NAME IO FILE ADDR I1 n f TLIBDIR
+    [[ -e $initdir$target ]] && return 0
+    # I love bash!
+    LC_ALL=C ldd $bin 2>/dev/null | while read line; do
+        [[ $line = 'not a dynamic executable' ]] && return 1
+        if [[ $line =~ not\ found ]]; then
+            derror "Missing a shared library required by $bin."
+            derror "Run \"ldd $bin\" to find out what it is."
+            derror "dracut cannot create an initrd."
+            exit 1
+        fi
+        so_regex='([^ ]*/lib[^/]*/[^ ]*\.so[^ ]*)'
+        [[ $line =~ $so_regex ]] || continue
+        FILE=${BASH_REMATCH[1]}
+        [[ -e ${initdir}$FILE ]] && continue
+        # see if we are loading an optimized version of a shared lib.
+        lib_regex='^(/lib[^/]*).*'
+        if [[ $FILE =~ $lib_regex ]]; then
+            TLIBDIR=${BASH_REMATCH[1]}
+            BASE=${FILE##*/}
+            # prefer nosegneg libs, then unoptimized ones.
+            for f in "$TLIBDIR/i686/nosegneg" "$TLIBDIR"; do
+                [[ -e $f/$BASE ]] || continue
+                FILE=$f/$BASE
+                break
+            done
+            inst_library "$FILE" "$TLIBDIR/$BASE"
+            IF_dynamic=yes
+            continue
+            fi
+            inst_library "$FILE" 
+    done
+    inst_simple "$bin" "$target"
+}
+
+# same as above, except for shell scripts.
+# If your shell script does not start with shebang, it is not a shell script.
+inst_script() {
+    [[ -f $1 ]] || return 1
+    local line
+    read -r -n 80 line <"$1"
+    # If debug is set, clean unprintable chars to prevent messing up the term
+    [[ $debug ]] && line=$(echo -n "$line" | tr -c -d '[:print:][:space:]')
+    shebang_regex='(#! *)(/[^ ]+).*'
+    [[ $line =~ $shebang_regex ]] || return 1
+    inst "${BASH_REMATCH[2]}" && inst_simple "$@"
+}
+
+# same as above, but specialized for symlinks
+inst_symlink() {
+    local src=$1 target=$initdir${2:-$1} realsrc
+    [[ -L $1 ]] || return 1
+    [[ -L $target ]] && return 0
+    realsrc=$(readlink -f "$src")
+    [[ $realsrc = ${realsrc##*/} ]] && realsrc=${src%/*}/$realsrc
+    inst "$realsrc" && mkdir -p "${target%/*}" && \
+        ln -s "$realsrc" "$target"
+}
+
+# find a udev rule in the usual places.
+find_rule() {
+    [[ -f $1 ]] && { echo "$1"; return 0; }
+    for r in . /lib/udev/rules.d /etc/udev/rules.d $dracutbasedir/rules.d; do
+        [[ -f $r/$1 ]] && { echo "$r/$1"; return 0; }
+    done
+    return 1
+}
+
+# udev rules always get installed in the same place, so
+# create a function to install them to make life simpler.
+inst_rules() { 
+    local target=/etc/udev/rules.d rule found
+
+    inst_dir "/lib/udev/rules.d"
+    inst_dir "$target"
+    for rule in "$@"; do 
+        found=$(find_rule "$rule") && \
+            inst_simple "$found" "$target/${found##*/}" \
+            || dinfo "Skipping udev rule: $rule"
+    done
+}
+
+# general purpose installation function
+# Same args as above.
+inst() {
+    case $# in
+        1) ;;
+        2) [[ ! $initdir && -d $2 ]] && export initdir=$2
+            [[ $initdir = $2 ]] && set $1;;
+        3) [[ -z $initdir ]] && export initdir=$2 
+            set $1 $3;;
+        *) derror "inst only takes 1 or 2 or 3 arguments"
+            exit 1;;
+    esac
+    for x in inst_symlink inst_script inst_binary inst_simple; do
+        $x "$@" && return 0
+    done
+    return 1
+}
+
+# install function specialized for hooks
+# $1 = type of hook, $2 = hook priority (lower runs first), $3 = hook
+# All hooks should be POSIX/SuS compliant, they will be sourced by init.
+inst_hook() {
+    if ! [[ -f $3 ]]; then
+        derror "Cannot install a hook ($3) that does not exist."
+        derror "Aborting initrd creation."
+        exit 1
+    elif ! strstr "$hookdirs" "$1"; then
+        derror "No such hook type $1. Aborting initrd creation." 
+        exit 1
+    fi
+    inst_simple "$3" "/${1}/${2}${3##*/}"
+}
+
+dracut_install() {
+    if [[ $1 = '-o' ]]; then 
+        local optional=yes
+        shift
+    fi
+    while (($# > 0)); do
+        if ! inst "$1" ; then
+            if [[ $optional = yes ]]; then
+                dwarning "Skipping program $1 as it cannot be found and is flagged to be optional"
+            else
+                derror "Failed to install $1"
+                exit 1
+            fi
+        fi
+        shift
+    done
+}
+
+# install function decompressing the target and handling symlinks
+# $@ = list of compressed (gz or bz2) files or symlinks pointing to such files
+#
+# Function install targets in the same paths inside overlay but decompressed
+# and without extensions (.gz, .bz2).
+inst_decompress() {
+    local src dst realsrc realdst cmd
+
+    for src in $@
+    do
+        case ${src} in
+            *.gz) cmd='gzip -d' ;;
+            *.bz2) cmd='bzip2 -d' ;;
+            *) return 1 ;;
+        esac
+
+        if [[ -L ${src} ]]
+        then
+            realsrc="$(readlink -f ${src})" # symlink target with extension
+            dst="${src%.*}" # symlink without extension
+            realdst="${realsrc%.*}" # symlink target without extension
+            mksubdirs "${initdir}/${src}"
+            # Create symlink without extension to target without extension.
+            ln -s "${realdst}" "${initdir}/${dst}"
+        fi
+
+        # If the source is symlink we operate on its target.
+        [[ ${realsrc} ]] && src=${realsrc}
+        inst ${src}
+        # Decompress with chosen tool.  We assume that tool changes name e.g.
+        # from 'name.gz' to 'name'.
+        ${cmd} "${initdir}${src}"
+    done
+}
+
+# It's similar to above, but if file is not compressed, performs standard
+# install.
+# $@ = list of files
+inst_opt_decompress() {
+    local src
+
+    for src in $@
+    do
+        inst_decompress "${src}" || inst "${src}"
+    done
+}
+
+module_check() {
+    local moddir=$(echo ${dracutbasedir}/modules.d/??${1})
+    [[ -d $moddir ]] || return 1
+    if [[ ! -f $moddir/module-setup.sh ]]; then
+        # if we do not have a check script, we are unconditionally included
+        [[ -x $moddir/check ]] || return 0
+        $moddir/check $hostonly
+        return $?
+    else
+        unset check depends install installkernel
+        . $moddir/module-setup.sh
+        is_func check || return 0
+        check
+        ret=$?
+        unset check depends install installkernel
+        return $ret
+    fi
+}
+
+module_depends() {
+    local moddir=$(echo ${dracutbasedir}/modules.d/??${1})
+    [[ -d $moddir ]] || return 1
+    if [[ ! -f $moddir/module-setup.sh ]]; then
+        # if we do not have a check script, we have no deps
+        [[ -x $moddir/check ]] || return 0
+        $moddir/check -d
+        return $?
+    else
+        unset check depends install installkernel
+        . $moddir/module-setup.sh
+        is_func depends || return 0
+        depends
+        ret=$?
+        unset check depends install installkernel
+        return $ret
+    fi
+}
+
+module_install() {
+    local moddir=$(echo ${dracutbasedir}/modules.d/??${1})
+    [[ -d $moddir ]] || return 1
+    if [[ ! -f $moddir/module-setup.sh ]]; then
+        [[ -x $moddir/install ]] && . "$moddir/install"
+        return $?
+    else
+        unset check depends install installkernel
+        . $moddir/module-setup.sh
+        is_func install || return 0
+        install
+        ret=$?
+        unset check depends install installkernel
+        return $ret
+    fi
+}
+
+module_installkernel() {
+    local moddir=$(echo ${dracutbasedir}/modules.d/??${1})
+    [[ -d $moddir ]] || return 1
+    if [[ ! -f $moddir/module-setup.sh ]]; then
+        [[ -x $moddir/installkernel ]] && . "$moddir/installkernel"
+        return $?
+    else
+        unset check depends install installkernel
+        . $moddir/module-setup.sh
+        is_func installkernel || return 0
+        installkernel
+        ret=$?
+        unset check depends install installkernel
+        return $ret
+    fi
+}
+
+check_module() {
+    local mod=$1;
+    local moddir=$(echo ${dracutbasedir}/modules.d/??${1})
+    local moddep;
+    # If we are already scheduled to be loaded, no need to check again.
+    strstr " $mods_to_load " " $mod " && return 0
+    strstr " $mods_checked_as_dep " " $mod " && return 1
+
+    # This should never happen, but...
+    [[ -d $moddir ]] || return 1
+
+    [[ $2 ]] || mods_checked_as_dep+=" $mod "
+
+    strstr " $omit_dracutmodules " " $mod " && return 1
+
+    if strstr " $dracutmodules $add_dracutmodules " " $mod "; then
+        module_check $mod; ret=$?
+        # explicit module, so also accept ret=255
+        [[ $ret = 0 || $ret = 255 ]] || return 1
+    else
+        # module not in our list
+        if [[ $dracutmodules = all ]]; then
+            # check, if we can and should install this module
+            module_check $mod || return 1
+        else
+            # skip this module
+            return 1
+        fi
+    fi
+
+    for moddep in $(module_depends $mod); do
+        # handle deps as if they were manually added
+        strstr " $add_dracutmodules " " $moddep " || \
+            add_dracutmodules+=" $moddep "
+        # if a module we depend on fail, fail also
+        check_module $moddep || return 1
+    done
+
+    strstr " $mods_to_load " " $mod " || \
+        mods_to_load+=" $mod "
+
+    return 0
+}
+
+check_module_dir() {
+    local modcheck;
+    local mod;
+    mods_to_load=""
+    for moddir in "$dracutbasedir/modules.d"/[0-9][0-9]*; do
+        local mod=${moddir##*/}; mod=${mod#[0-9][0-9]}
+        check_module $mod 1
+    done
+}
+
+# Install a single kernel module along with any firmware it may require.
+# $1 = full path to kernel module to install
+install_kmod_with_fw() {
+    local modname=${1##*/} fwdir found
+    modname=${modname%.ko*}
+    inst_simple "$1" "/lib/modules/$kernel/${1##*/lib/modules/$kernel/}" || \
+        return 0 # no need to go further if the module is already installed
+    for fw in $(modinfo -k $kernel -F firmware $1 2>/dev/null); do
+        found=''
+        for fwdir in $fw_dir; do
+            if [[ -d $fwdir && -f $fwdir/$fw ]]; then
+                inst_simple "$fwdir/$fw" "/lib/firmware/$fw"
+                found=yes
+            fi
+        done
+        if [[ $found != yes ]]; then
+            dinfo "Possible missing firmware \"${fw}\" for kernel module \"${mod}.ko\""
+        fi
+    done
+}
+
+# Do something with all the dependencies of a kernel module.
+# Note that kernel modules depend on themselves using the technique we use
+# $1 = function to call for each dependency we find 
+#      It will be passed the full path to the found kernel module 
+# $2 = module to get dependencies for
+# rest of args = arguments to modprobe
+for_each_kmod_dep() {
+    local func=$1 kmod=$2 cmd modpapth options
+    shift 2
+    modprobe "$@" --ignore-install --show-depends $kmod 2>/dev/null | \
+        while read cmd modpath options; do
+        [[ $cmd = insmod ]] || continue
+        $func $modpath
+    done
+}
+
+# filter kernel modules to install certain modules that meet specific
+# requirements.
+# $1 = function to call with module name to filter.
+#      This function will be passed the full path to the module to test.
+# The behaviour of this function can vary depending on whether $hostonly is set.
+# If it is, we will only look at modules that are already in memory.
+# If it is not, we will look at all kernel modules
+# This function returns the full filenames of modules that match $1
+filter_kernel_modules () (
+    if ! [[ $hostonly ]]; then
+        filtercmd='find "$srcmods/kernel/drivers" "$srcmods/extra" "$srcmods/weak-updates" -name "*.ko" -o -name "*.ko.gz" 2>/dev/null'
+    else
+        filtercmd='cut -d " " -f 1 </proc/modules|xargs modinfo -F filename -k $kernel 2>/dev/null'
+    fi
+    for modname in $(eval $filtercmd); do
+        case $modname in
+            *.ko) "$1" "$modname" && echo "$modname";;
+            *.ko.gz) gzip -dc "$modname" > $initdir/$$.ko
+                $1 $initdir/$$.ko && echo "$modname"
+                rm -f $initdir/$$.ko;;
+        esac
+    done
+)
+
+# install kernel modules along with all their dependencies.
+instmods() {
+    [[ $no_kernel = yes ]] && return
+    local mod mpargs modpath modname cmd moddirname
+    while (($# > 0)); do
+        mod=${1%.ko*}
+        case $mod in
+            =*) 
+                # This introduces 2 incompatible meanings for =* arguments
+                # to instmods.  We need to decide which one to keep.
+                if [[ $mod = =ata && -f $srcmods/modules.block ]] ; then 
+                    instmods $mpargs $(egrep 'ata|ahci' "${srcmods}/modules.block")
+                elif [ -f $srcmods/modules.${mod#=} ]; then
+                    instmods $mpargs $(cat ${srcmods}/modules.${mod#=} )
+                else
+                    instmods $mpargs $(find "$srcmods" -path "*/${mod#=}/*")
+                fi
+                ;;
+            --*) 
+                mod=${mod##*/}
+                mpargs+=" $mod";;
+            i2o_scsi) shift; continue;; # Do not load this diagnostic-only module
+            *)  mod=${mod##*/}
+                # if we are already installed, skip this module and go on
+                # to the next one.
+                [[ -f $initdir/$1 ]] && { shift; continue; }
+                # If we are building a host-specific initramfs and this
+                # module is not already loaded, move on to the next one.
+                [[ $hostonly ]] && ! grep -qe "\<${mod//-/_}\>" /proc/modules && \
+                    ! echo $add_drivers | grep -qe "\<${mod}\>" &&  {
+                    shift; continue; 
+                }
+
+                # We use '-d' option in modprobe only if modules prefix path
+                # differs from default '/'.  This allows us to use Dracut with
+                # old version of modprobe which doesn't have '-d' option.
+                moddirname=${srcmods%%/lib/modules/*}
+                [[ -n ${moddirname} ]] && moddirname="-d ${moddirname}/"
+
+                # ok, load the module, all its dependencies, and any firmware
+                # it may require
+                for_each_kmod_dep install_kmod_with_fw $mod \
+                    --set-version $kernel ${moddirname}
+                ;;
+    esac      
+    shift
+    done
+} 
diff --git gen_cmdline.sh gen_cmdline.sh
index b3e451d..bc9f2dc 100755
--- gen_cmdline.sh
+++ gen_cmdline.sh
@@ -22,6 +22,7 @@ longusage() {
   echo "	--logfile=<outfile>	Output file for debug info"
   echo "	--color			Output debug in color"
   echo "	--no-color		Do not output debug in color"
+  echo "	--no-cleartmp		Do not clear temp directory"
   echo "  Kernel Configuration settings"
   echo "	--menuconfig		Run menuconfig after oldconfig"
   echo "	--no-menuconfig		Do not run menuconfig after oldconfig"
@@ -78,6 +79,8 @@ longusage() {
   echo "	--splash-res=<res>	Select splash theme resolutions to install"
   echo "	--do-keymap-auto	Forces keymap selection at boot"
   echo "	--no-keymap		Disables keymap selection support"
+  echo "	--udev			Include udev in the initramfs"
+  echo "	--no-udev		Exclude udev from the initramfs"
   echo "	--lvm			Include LVM support"
   echo "	--mdadm			Include MDADM/MDMON support"
   echo "	--mdadm-config=<file>	Use file as mdadm.conf in initramfs"
@@ -97,6 +100,8 @@ longusage() {
   echo "	--unionfs		Include support for unionfs"
   echo "	--netboot		Create a self-contained env in the initramfs"
   echo "	--real-root=<foo>	Specify a default for real_root="
+  echo "	--lscpi			Include lspci into the initramfs"
+  echo "	--no-lscpi		Exclude lspci from the initramfs"
   echo "  Internals"
   echo "	--arch-override=<arch>	Force to arch instead of autodetect"
   echo "	--cachedir=<dir>	Override the default cache location"
@@ -232,6 +237,22 @@ parse_cmdline() {
 			CMD_KEYMAP=0
 			print_info 2 "CMD_KEYMAP: ${CMD_KEYMAP}"
 			;;
+		--udev)
+			CMD_UDEV=1
+			print_info 2 "CMD_UDEV: ${CMD_UDEV}"
+			;;
+		--no-udev)
+			CMD_UDEV=0
+			print_info 2 "CMD_UDEV: ${CMD_UDEV}"
+			;;
+		--lspci)
+			CMD_LSPCI=1
+			print_info 2 "CMD_LSPCI: ${CMD_LSPCI}"
+			;;
+		--no-lspci)
+			CMD_UDEV=0
+			print_info 2 "CMD_LSPCI: ${CMD_LSPCI}"
+			;;
 		--lvm)
 			CMD_LVM=1
 			print_info 2 "CMD_LVM: ${CMD_LVM}"
@@ -441,6 +462,10 @@ parse_cmdline() {
 			print_info 2 "USECOLOR: ${USECOLOR}"
 			setColorVars
 			;;
+		--no-cleartmp)
+			NOCLEARTMP=1
+			print_info 2 "NOCLEARTMP: ${NOCLEARTMP}"
+			;;
 		--logfile=*)
 			CMD_LOGFILE=`parse_opt "$*"`
 			LOGFILE=`parse_opt "$*"`
diff --git gen_compile.sh gen_compile.sh
index 0758c3a..8a2339a 100755
--- gen_compile.sh
+++ gen_compile.sh
@@ -407,7 +407,10 @@ compile_busybox() {
 		yes '' 2>/dev/null | compile_generic oldconfig utils
 
 		print_info 1 'busybox: >> Compiling...'
+		OLDLOGLEVEL=$LOGLEVEL
+		LOGLEVEL=1
 		compile_generic all utils
+		LOGLEVEL=$OLDLOGLEVEL
 		print_info 1 'busybox: >> Copying to cache...'
 		[ -f "${TEMP}/${BUSYBOX_DIR}/busybox" ] ||
 			gen_die 'Busybox executable does not exist!'
diff --git gen_determineargs.sh gen_determineargs.sh
index ce479cb..bda14b8 100755
--- gen_determineargs.sh
+++ gen_determineargs.sh
@@ -107,6 +107,8 @@ determine_real_args() {
 	set_config_with_override BOOL   SYMLINK              CMD_SYMLINK
 	set_config_with_override STRING INSTALL_MOD_PATH     CMD_INSTALL_MOD_PATH
 	set_config_with_override BOOL   OLDCONFIG            CMD_OLDCONFIG
+	set_config_with_override BOOL   UDEV                 CMD_UDEV
+	set_config_with_override BOOL   LSPCI                CMD_LSPCI
 	set_config_with_override BOOL   LVM                  CMD_LVM
 	set_config_with_override BOOL   DMRAID               CMD_DMRAID
 	set_config_with_override BOOL   ISCSI                CMD_ISCSI
diff --git gen_initramfs.sh gen_initramfs.sh
index 7fe4421..76b6645 100755
--- gen_initramfs.sh
+++ gen_initramfs.sh
@@ -56,7 +56,13 @@ append_busybox() {
 	chmod +x "${TEMP}/initramfs-busybox-temp/usr/share/udhcpc/default.script"
 
 	# Set up a few default symlinks
-	for i in ${BUSYBOX_APPLETS:-[ ash sh mount uname echo cut cat}; do
+	if isTrue "${UDEV}"
+	then
+		BUSYBOX_APPLETS="${BUSYBOX_APPLETS:-[ ash sh uname echo cut cat}"
+	else
+		BUSYBOX_APPLETS="{$BUSYBOX_APPLETS:-[ ash sh mount uname echo cut cat}"
+	fi
+	for i in ${BUSYBOX_APPLETS}; do
 		rm -f ${TEMP}/initramfs-busybox-temp/bin/$i > /dev/null
 		ln -s busybox ${TEMP}/initramfs-busybox-temp/bin/$i ||
 			gen_die "Busybox error: could not link ${i}!"
@@ -410,7 +416,7 @@ append_firmware() {
 		IFS=","
 		for i in ${FIRMWARE_FILES}
 		do
-			cp -L "${i}" ${TEMP}/initramfs-firmware-temp/lib/firmware/
+			cp -rL "${i}" ${TEMP}/initramfs-firmware-temp/lib/firmware/
 		done
 		IFS=$OLD_IFS
 	else
@@ -438,9 +444,71 @@ append_gpg() {
 	chmod a+x "${TEMP}/initramfs-gpg-temp/sbin/gpg"
 	cd "${TEMP}/initramfs-gpg-temp/"
 	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	cd "${TEMP}"
 	rm -rf "${TEMP}/initramfs-gpg-temp" > /dev/null
 }
 
+append_udev() {
+	if [ -d "${TEMP}/initramfs-udev-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-udev-temp"
+	fi
+	cd ${TEMP}
+	mkdir -p "${TEMP}/initramfs-udev-temp/"
+	udevmod="${GK_SHARE}/modules/udev-rules/"
+	source ${udevmod}/module-setup.sh
+	initdir=${TEMP}/initramfs-udev-temp \
+		moddir=${udevmod} \
+		libdir=/lib/ \
+		usrlibdir=/usr/lib/ \
+		install_module
+
+	if isTrue $LSPCI
+	then
+		initdir=${TEMP}/initramfs-udev-temp \
+		dracut_install /usr/sbin/lspci /usr/share/misc/pci.ids
+	fi
+	# find net modules and sound 
+	(for pathname in ${INSTALL_MOD_PATH}/lib/modules/${KV}/net \
+			${INSTALL_MOD_PATH}/lib/modules/${KV}/kernel/net \
+			${INSTALL_MOD_PATH}/lib/modules/${KV}/kernel/drivers/net \
+			${INSTALL_MOD_PATH}/lib/modules/${KV}/kernel/sound
+	do
+		[[ -d $pathname ]] && find $pathname -name "*.ko"
+	done | 
+		while read module;do
+	# add them prefix blacklist
+			echo "blacklist `basename $module .ko`";
+	# concat with ready blacklist.conf
+		done;cat "${TEMP}/initramfs-udev-temp/etc/modprobe.d/blacklist.conf") |
+	# sort and rewrite blacklist.conf
+		sort | uniq > "${TEMP}/initramfs-udev-temp/etc/modprobe.d/blacklist.conf.new"
+	mv "${TEMP}/initramfs-udev-temp/etc/modprobe.d/blacklist.conf.new" \
+		"${TEMP}/initramfs-udev-temp/etc/modprobe.d/blacklist.conf"
+
+	cd "${TEMP}/initramfs-udev-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	cd "${TEMP}"
+	rm -rf "${TEMP}/initramfs-udev-temp" > /dev/null
+}
+
+append_lspci() {
+	if [ -d "${TEMP}/initramfs-lspci-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-lspci-temp"
+	fi
+	cd ${TEMP}
+	mkdir -p "${TEMP}/initramfs-lspci-temp/"
+
+	initdir=${TEMP}/initramfs-lspci-temp \
+		dracut_install /usr/sbin/lspci /usr/share/misc/pci.ids
+
+	cd "${TEMP}/initramfs-lspci-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	cd "${TEMP}"
+	rm -rf "${TEMP}/initramfs-lspci-temp" > /dev/null
+}
+
 print_list()
 {
 	local x
@@ -489,6 +557,11 @@ append_modules() {
 		print_list ${!group_modules} > "${TEMP}/initramfs-modules-${KV}-temp/etc/modules/${group}"
 	done
 	cd "${TEMP}/initramfs-modules-${KV}-temp/"
+	# remove sound and media
+	for x in `find . -type d -name media -o -type d -name sound`
+	do
+		rm -r "${x}" &>/dev/null
+	done
 	find . | cpio ${CPIO_ARGS} --append -F "${CPIO}" \
 			|| gen_die "compressing modules cpio"
 	cd "${TEMP}"
@@ -561,11 +634,14 @@ append_auxilary() {
 	done
 	echo '"' >> "${TEMP}/initramfs-aux-temp/etc/initrd.defaults"	
 
-	if [ -f "${GK_SHARE}/arch/${ARCH}/modprobe" ]
+	if ! isTrue "${UDEV}"
 	then
-		cp "${GK_SHARE}/arch/${ARCH}/modprobe" "${TEMP}/initramfs-aux-temp/sbin/modprobe"
-	else
-		cp "${GK_SHARE}/defaults/modprobe" "${TEMP}/initramfs-aux-temp/sbin/modprobe"
+		if [ -f "${GK_SHARE}/arch/${ARCH}/modprobe" ]
+		then
+			cp "${GK_SHARE}/arch/${ARCH}/modprobe" "${TEMP}/initramfs-aux-temp/sbin/modprobe"
+		else
+			cp "${GK_SHARE}/defaults/modprobe" "${TEMP}/initramfs-aux-temp/sbin/modprobe"
+		fi
 	fi
 	if isTrue $CMD_DOKEYMAPAUTO
 	then
@@ -582,7 +658,7 @@ append_auxilary() {
 	chmod +x "${TEMP}/initramfs-aux-temp/init"
 	chmod +x "${TEMP}/initramfs-aux-temp/etc/initrd.scripts"
 	chmod +x "${TEMP}/initramfs-aux-temp/etc/initrd.defaults"
-	chmod +x "${TEMP}/initramfs-aux-temp/sbin/modprobe"
+	isTrue "${UDEV}" || chmod +x "${TEMP}/initramfs-aux-temp/sbin/modprobe"
 
 	if isTrue ${NETBOOT}
 	then
@@ -609,6 +685,21 @@ append_data() {
 	fi
 }
 
+pack_cpio() {
+	print_info 1 "        >> Pack cpio data..."
+	if [ -d "${TEMP}/initramfs-repack-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-repack-temp"
+	fi
+	mkdir -p "${TEMP}/initramfs-repack-temp"
+	cd "${TEMP}/initramfs-repack-temp"
+	# unpack and pack cpio remove double files
+	cpio -di <${CPIO} 2>/dev/null
+	find . -print | cpio ${CPIO_ARGS} | gzip -9 >"${CPIO}"
+	cd "${TEMP}"
+	rm -rf "${TEMP}/initramfs-repack-temp" > /dev/null
+}
+
 create_initramfs() {
 	print_info 1 "initramfs: >> Initializing..."
 
@@ -619,6 +710,11 @@ create_initramfs() {
 
 	append_data 'base_layout'
 	append_data 'auxilary' "${BUSYBOX}"
+	append_data 'udev' "${UDEV}"
+	if ! isTrue "${UDEV}"
+	then
+		append_data 'lspci' "${LSPCI}"
+	fi
 	append_data 'busybox' "${BUSYBOX}"
 	append_data 'lvm' "${LVM}"
 	append_data 'dmraid' "${DMRAID}"
@@ -652,8 +748,7 @@ create_initramfs() {
 		append_data 'overlay'
 	fi
 
-	gzip -9 "${CPIO}"
-	mv -f "${CPIO}.gz" "${CPIO}"
+	pack_cpio
 
 	if isTrue "${INTEGRATED_INITRAMFS}"
 	then
diff --git genkernel genkernel
index 0a06cdd..1486c61 100755
--- genkernel
+++ genkernel
@@ -9,6 +9,7 @@ GK_V='3.4.18'
 TMPDIR='/var/tmp/genkernel'
 
 TODEBUGCACHE=1 # Until an error occurs or LOGFILE is fully qualified.
+NOCLEARTMP=0
 
 small_die() {
   echo $1
@@ -45,6 +46,7 @@ source ${GK_SHARE}/gen_initramfs.sh || gen_die "Could not read ${GK_SHARE}/gen_i
 source ${GK_SHARE}/gen_moddeps.sh || gen_die "Could not read ${GK_SHARE}/gen_moddeps.sh"
 source ${GK_SHARE}/gen_package.sh || gen_die "Could not read ${GK_SHARE}/gen_package.sh"
 source ${GK_SHARE}/gen_bootloader.sh || gen_die "Could not read ${GK_SHARE}/gen_bootloader.sh"
+source ${GK_SHARE}/dracut_funcs.sh || gen_die "Could not read ${GK_SHARE}/dracut_funcs.sh"
 
 TEMP=${TMPDIR}/$RANDOM.$RANDOM.$RANDOM.$$
 
@@ -55,21 +57,25 @@ trap_cleanup(){
 }
 
 cleanup(){
-    if [ -n "$TEMP" -a -d "$TEMP" ]; then
-	rm -rf "$TEMP"
-    fi
-
-    if isTrue ${POSTCLEAR}
-    then
-	    echo
-	    print_info 1 'RUNNING FINAL CACHE/TMP CLEANUP'
-	    print_info 1 "CACHE_DIR: ${CACHE_DIR}"
-	    CLEAR_CACHE_DIR='yes'
-	    setup_cache_dir
-	    echo
-	    print_info 1 "TMPDIR: ${TMPDIR}"
-	    clear_tmpdir
-	    fi
+	if [[ ${NOCLEARTMP} -ne 0 ]]
+	then
+		return
+	fi
+	if [ -n "$TEMP" -a -d "$TEMP" ]; then
+		rm -rf "$TEMP" &>/dev/null
+	fi
+
+	if isTrue ${POSTCLEAR}
+	then
+		echo
+		print_info 1 'RUNNING FINAL CACHE/TMP CLEANUP'
+		print_info 1 "CACHE_DIR: ${CACHE_DIR}"
+		CLEAR_CACHE_DIR='yes'
+		setup_cache_dir
+		echo
+		print_info 1 "TMPDIR: ${TMPDIR}"
+		clear_tmpdir
+	fi
 }
 
 trap trap_cleanup SIGHUP SIGQUIT SIGINT SIGTERM SIGKILL
diff --git genkernel.conf genkernel.conf
index 24fcd54..41f8e06 100644
--- genkernel.conf
+++ genkernel.conf
@@ -52,6 +52,12 @@ USECOLOR="yes"
 # argument is: <number of processors>*<number of cores per processor>+1
 # MAKEOPTS="-j2"
 
+# Add udev to initramfs
+UDEV="yes"
+
+# Add lspci to initramfs
+LSPCI="yes"
+
 # Add in LVM support from static binaries if they exist on the system, or
 # compile static LVM binaries if static ones do not exist.
 # LVM="no"
@@ -92,7 +98,7 @@ USECOLOR="yes"
 # Specify directory to pull from
 # FIRMWARE_DIR="/lib/firmware"
 # Specify specific firmware files to include. This overrides FIRMWARE_DIR
-# FIRMWARE_FILES=""
+FIRMWARE_FILES="/lib/firmware/radeon"
 
 # Enable disklabel support (copies blkid to initrd)
 DISKLABEL="yes"
diff --git modules/udev-rules/01-ignore.rules modules/udev-rules/01-ignore.rules
new file mode 100644
index 0000000..b32f22e
--- /dev/null
+++ modules/udev-rules/01-ignore.rules
@@ -0,0 +1 @@
+KERNEL=="ram[0-9]*", OPTIONS+="ignore_device", OPTIONS+="last_rule"
diff --git modules/udev-rules/59-persistent-storage-volid.rules modules/udev-rules/59-persistent-storage-volid.rules
new file mode 100644
index 0000000..0b798e6
--- /dev/null
+++ modules/udev-rules/59-persistent-storage-volid.rules
@@ -0,0 +1,7 @@
+SUBSYSTEM!="block", GOTO="psv_end"
+ACTION!="add|change", GOTO="psv_end"
+ACTION=="change", KERNEL=="dm-[0-9]*", ENV{DM_UDEV_DISABLE_OTHER_RULES_FLAG}!="1", IMPORT{program}="vol_id --export $tempnode"
+KERNEL=="cciss[0-9]*", IMPORT{program}="vol_id --export $tempnode"
+KERNEL=="nbd[0-9]*", IMPORT{program}="vol_id --export $tempnode"
+KERNEL=="md[0-9]*|md_d[0-9]*|md/*", IMPORT{program}="vol_id --export $tempnode"
+LABEL="psv_end"
diff --git modules/udev-rules/59-persistent-storage.rules modules/udev-rules/59-persistent-storage.rules
new file mode 100644
index 0000000..2b83e72
--- /dev/null
+++ modules/udev-rules/59-persistent-storage.rules
@@ -0,0 +1,38 @@
+SUBSYSTEM!="block", GOTO="ps_end"
+ACTION!="add|change", GOTO="ps_end"
+
+KERNEL=="cciss[0-9]*", IMPORT{program}="/sbin/blkid -o udev -p $tempnode"
+KERNEL=="nbd[0-9]*", IMPORT{program}="/sbin/blkid -o udev -p $tempnode"
+
+
+KERNEL!="md[0-9]*|md_d[0-9]*|md/*", KERNEL!="md*", GOTO="md_end"
+
+# partitions have no md/{array_state,metadata_version}
+ENV{DEVTYPE}=="partition", GOTO="md_ignore_state"
+
+# container devices have a metadata version of e.g. 'external:ddf' and
+# never leave state 'inactive'
+ATTR{md/metadata_version}=="external:[A-Za-z]*", ATTR{md/array_state}=="inactive", GOTO="md_ignore_state"
+TEST!="md/array_state", GOTO="md_end"
+ATTR{md/array_state}=="|clear|inactive", GOTO="md_end"
+
+LABEL="md_ignore_state"
+
+IMPORT{program}="/sbin/mdadm --detail --export $tempnode"
+IMPORT{program}="/sbin/blkid -o udev -p $tempnode"
+OPTIONS+="link_priority=100"
+OPTIONS+="watch"
+LABEL="md_end"
+
+
+KERNEL!="dm-[0-9]*", GOTO="ps_end"
+ACTION=="add", GOTO="ps_end"
+IMPORT{program}="/sbin/dmsetup info -c --nameprefixes --unquoted --rows --noheadings -o name,uuid,suspended,readonly,major,minor,open,tables_loaded,names_using_dev -j%M -m%m"
+ENV{DM_NAME}!="?*", GOTO="ps_end"
+ENV{DM_UDEV_DISABLE_OTHER_RULES_FLAG}=="1", GOTO="ps_end"
+ENV{DM_UUID}=="CRYPT-TEMP-?*", GOTO="ps_end"
+ENV{DM_UUID}!="?*", ENV{DM_NAME}=="temporary-cryptsetup-?*", GOTO="ps_end"
+IMPORT{program}="/sbin/blkid -o udev -p $tempnode"
+
+
+LABEL="ps_end"
diff --git modules/udev-rules/61-persistent-storage.rules modules/udev-rules/61-persistent-storage.rules
new file mode 100644
index 0000000..9cfdb0b
--- /dev/null
+++ modules/udev-rules/61-persistent-storage.rules
@@ -0,0 +1,20 @@
+SUBSYSTEM!="block", GOTO="pss_end"
+ACTION!="add|change", GOTO="pss_end"
+
+ACTION=="change", KERNEL=="dm-[0-9]*", ENV{DM_UDEV_DISABLE_OTHER_RULES_FLAG}!="1", GOTO="do_pss"
+KERNEL=="cciss[0-9]*", GOTO="do_pss"
+KERNEL=="nbd[0-9]*", GOTO="do_pss"
+KERNEL=="md[0-9]*|md_d[0-9]*|md/*", GOTO="do_pss"
+
+GOTO="pss_end"
+
+LABEL="do_pss"
+# by-path (parent device path)
+ENV{DEVTYPE}=="disk", ENV{ID_PATH}=="", DEVPATH!="*/virtual/*", IMPORT{program}="path_id %p"
+ENV{DEVTYPE}=="disk", ENV{ID_PATH}=="?*", SYMLINK+="disk/by-path/$env{ID_PATH}"
+ENV{DEVTYPE}=="partition", ENV{ID_PATH}=="?*", SYMLINK+="disk/by-path/$env{ID_PATH}-part%n"
+
+# by-label/by-uuid links (filesystem metadata)
+ENV{ID_FS_USAGE}=="filesystem|other|crypto", ENV{ID_FS_UUID_ENC}=="?*", SYMLINK+="disk/by-uuid/$env{ID_FS_UUID_ENC}"
+ENV{ID_FS_USAGE}=="filesystem|other", ENV{ID_FS_LABEL_ENC}=="?*", SYMLINK+="disk/by-label/$env{ID_FS_LABEL_ENC}"
+LABEL="pss_end"
diff --git modules/udev-rules/blacklist.conf modules/udev-rules/blacklist.conf
new file mode 100644
index 0000000..21ac71c
--- /dev/null
+++ modules/udev-rules/blacklist.conf
@@ -0,0 +1,162 @@
+blacklist ath_pci
+blacklist evbug
+blacklist usbmouse
+blacklist usbkbd
+blacklist eepro100
+blacklist de4x5
+blacklist eth1394
+blacklist snd_intel8x0m
+blacklist snd_aw2
+blacklist i2c_i801
+blacklist prism54
+blacklist bcm43xx
+blacklist garmin_gps
+blacklist asus_acpi
+blacklist snd_pcsp
+blacklist pcspkr
+blacklist amd76x_edac
+blacklist ohci1394
+blacklist sbp2
+blacklist dv1394
+blacklist raw1394
+blacklist video1394
+blacklist aty128fb
+blacklist atyfb
+blacklist radeonfb
+blacklist cirrusfb
+blacklist cyber2000fb
+blacklist cyblafb
+blacklist gx1fb
+blacklist hgafb
+blacklist i810fb
+blacklist intelfb
+blacklist kyrofb
+blacklist lxfb
+blacklist matroxfb_base
+blacklist neofb
+blacklist nvidiafb
+blacklist pm2fb
+blacklist rivafb
+blacklist s1d13xxxfb
+blacklist savagefb
+blacklist sisfb
+blacklist sstfb
+blacklist tdfxfb
+blacklist tridentfb
+blacklist vesafb
+blacklist vfb
+blacklist viafb
+blacklist vt8623fb
+blacklist ac97
+blacklist ac97_codec
+blacklist ac97_plugin_ad1980
+blacklist ad1848
+blacklist ad1889
+blacklist adlib_card
+blacklist aedsp16
+blacklist ali5455
+blacklist btaudio
+blacklist cmpci
+blacklist cs4232
+blacklist cs4281
+blacklist cs461x
+blacklist cs46xx
+blacklist emu10k1
+blacklist es1370
+blacklist es1371
+blacklist esssolo1
+blacklist forte
+blacklist gus
+blacklist i810_audio
+blacklist kahlua
+blacklist mad16
+blacklist maestro
+blacklist maestro3
+blacklist maui
+blacklist mpu401
+blacklist nm256_audio
+blacklist opl3
+blacklist opl3sa
+blacklist opl3sa2
+blacklist pas2
+blacklist pss
+blacklist rme96xx
+blacklist sb
+blacklist sb_lib
+blacklist sgalaxy
+blacklist sonicvibes
+blacklist sound
+blacklist sscape
+blacklist trident
+blacklist trix
+blacklist uart401
+blacklist uart6850
+blacklist via82cxxx_audio
+blacklist v_midi
+blacklist wavefront
+blacklist ymfpci
+blacklist ac97_plugin_wm97xx
+blacklist ad1816
+blacklist audio
+blacklist awe_wave
+blacklist dmasound_core
+blacklist dmasound_pmac
+blacklist harmony
+blacklist sequencer
+blacklist soundcard
+blacklist usb-midi
+blacklist acquirewdt
+blacklist advantechwdt
+blacklist alim1535_wdt
+blacklist alim7101_wdt
+blacklist booke_wdt
+blacklist cpu5wdt
+blacklist eurotechwdt
+blacklist i6300esb
+blacklist i8xx_tco
+blacklist ib700wdt
+blacklist ibmasr
+blacklist indydog
+blacklist iTCO_wdt
+blacklist it8712f_wdt
+blacklist it87_wdt
+blacklist ixp2000_wdt
+blacklist ixp4xx_wdt
+blacklist machzwd
+blacklist mixcomwd
+blacklist mpc8xx_wdt
+blacklist mpcore_wdt
+blacklist mv64x60_wdt
+blacklist pc87413_wdt
+blacklist pcwd
+blacklist pcwd_pci
+blacklist pcwd_usb
+blacklist s3c2410_wdt
+blacklist sa1100_wdt
+blacklist sbc60xxwdt
+blacklist sbc7240_wdt
+blacklist sb8360
+blacklist sc1200wdt
+blacklist sc520_wdt
+blacklist sch311_wdt
+blacklist scx200_wdt
+blacklist shwdt
+blacklist smsc37b787_wdt
+blacklist softdog
+blacklist twl4030_wdt
+blacklist w83627hf_wdt
+blacklist w83697hf_wdt
+blacklist w83697ug_wdt
+blacklist w83877f_wdt
+blacklist w83977f_wdt
+blacklist wafer5823wdt
+blacklist wdt
+blacklist wdt_pci
+blacklist wm8350_wdt
+# Not using kernel video drivers
+blacklist nvidia
+blacklist radeon
+blacklist nouveau
+blacklist i915
+blacklist uvesafb
+blacklist fglrx
diff --git modules/udev-rules/load-modules.sh modules/udev-rules/load-modules.sh
new file mode 100755
index 0000000..36972fd
--- /dev/null
+++ modules/udev-rules/load-modules.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+# -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
+# ex: ts=8 sw=4 sts=4 et filetype=sh
+
+# Implement blacklisting for udev-loaded modules
+
+modprobe -b "$@"
diff --git modules/udev-rules/module-setup.sh modules/udev-rules/module-setup.sh
new file mode 100755
index 0000000..1005627
--- /dev/null
+++ modules/udev-rules/module-setup.sh
@@ -0,0 +1,57 @@
+#!/bin/bash
+# -*- mode: shell-script; indent-tabs-mode: nil; sh-basic-offset: 4; -*-
+# ex: ts=8 sw=4 sts=4 et filetype=sh
+
+install_module() {
+    # FIXME: would be nice if we didn't have to know which rules to grab....
+    # ultimately, /lib/initramfs/rules.d or somesuch which includes links/copies
+    # of the rules we want so that we just copy those in would be best
+    dracut_install udevd udevadm /etc/udev/udev.conf /etc/group /bin/mount /sbin/modprobe
+    inst_rules 50-udev-default.rules 60-persistent-storage.rules \
+        61-persistent-storage-edd.rules 80-drivers.rules 95-udev-late.rules \
+        60-pcmcia.rules 
+    mkdir -p "$initdir"/etc/modprobe.d
+    inst_simple "$moddir/blacklist.conf" /etc/modprobe.d/
+
+    # ignore some devices in the initrd
+    inst_rules "$moddir/01-ignore.rules"
+
+    # for firmware loading
+    inst_rules 50-firmware.rules
+
+    if [ ! -x /lib/udev/vol_id ]; then
+        inst_rules "$moddir/59-persistent-storage.rules"
+    else
+        inst_rules "$moddir/59-persistent-storage-volid.rules"
+    fi
+    inst_rules "$moddir/61-persistent-storage.rules"
+
+    for i in \
+        ata_id \
+        cdrom_id \
+        create_floppy_devices \
+        edd_id \
+        firmware.sh \
+        firmware \
+        firmware.agent \
+        hotplug.functions \
+        fw_unit_symlinks.sh \
+        hid2hci \
+        path_id \
+        scsi_id \
+        usb_id \
+        vol_id \
+        pcmcia-socket-startup \
+        pcmcia-check-broken-cis \
+        ; do
+        for utilpath in /lib/udev /sbin /bin
+        do 
+            [ -e $utilpath/$i ] && dracut_install $utilpath/$i
+        done 
+    done
+
+    for i in {"$libdir","$usrlibdir"}/libnss_files*; do
+        [ -e "$i" ] && dracut_install "$i"
+    done
+}
+
