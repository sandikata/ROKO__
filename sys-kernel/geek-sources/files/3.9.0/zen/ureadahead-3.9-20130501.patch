diff -x .git -urN linux-3.9/fs/exec.c zen/fs/exec.c
--- linux-3.9/fs/exec.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/fs/exec.c	2013-05-01 11:54:54.960791752 +0300
@@ -56,6 +56,8 @@
 #include <linux/oom.h>
 #include <linux/compat.h>
 
+#include <trace/events/fs.h>
+
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
 #include <asm/tlb.h>
@@ -772,6 +774,8 @@
 
 	fsnotify_open(file);
 
+	trace_open_exec(name);
+
 	err = deny_write_access(file);
 	if (err)
 		goto exit;
diff -x .git -urN linux-3.9/fs/open.c zen/fs/open.c
--- linux-3.9/fs/open.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/fs/open.c	2013-05-01 11:54:54.960791752 +0300
@@ -34,6 +34,9 @@
 
 #include "internal.h"
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/fs.h>
+
 int do_truncate(struct dentry *dentry, loff_t length, unsigned int time_attrs,
 	struct file *filp)
 {
@@ -974,6 +977,7 @@
 			} else {
 				fsnotify_open(f);
 				fd_install(fd, f);
+				trace_do_sys_open(tmp, flags, mode);
 			}
 		}
 		putname(tmp);
diff -x .git -urN linux-3.9/include/linux/page-flags.h zen/include/linux/page-flags.h
--- linux-3.9/include/linux/page-flags.h	2013-04-29 03:36:01.000000000 +0300
+++ zen/include/linux/page-flags.h	2013-05-01 11:54:54.962791727 +0300
@@ -109,6 +109,7 @@
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 	PG_compound_lock,
 #endif
+	PG_readaheadunused,	/* user oriented readahead as yet unused*/
 	__NR_PAGEFLAGS,
 
 	/* Filesystems */
@@ -232,6 +233,8 @@
 PAGEFLAG(Reclaim, reclaim) TESTCLEARFLAG(Reclaim, reclaim)
 PAGEFLAG(Readahead, reclaim)		/* Reminder to do async read-ahead */
 
+PAGEFLAG(ReadaheadUnused, readaheadunused)
+
 #ifdef CONFIG_HIGHMEM
 /*
  * Must use a macro here due to header dependency issues. page_zone() is not
diff -x .git -urN linux-3.9/include/trace/events/fs.h zen/include/trace/events/fs.h
--- linux-3.9/include/trace/events/fs.h	1970-01-01 03:00:00.000000000 +0300
+++ zen/include/trace/events/fs.h	2013-05-01 11:54:54.962791727 +0300
@@ -0,0 +1,53 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM fs
+
+#if !defined(_TRACE_FS_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_FS_H
+
+#include <linux/fs.h>
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(do_sys_open,
+
+	TP_PROTO(char *filename, int flags, int mode),
+
+	TP_ARGS(filename, flags, mode),
+
+	TP_STRUCT__entry(
+		__string(	filename, filename		)
+		__field(	int, flags			)
+		__field(	int, mode			)
+	),
+
+	TP_fast_assign(
+		__assign_str(filename, filename);
+		__entry->flags = flags;
+		__entry->mode = mode;
+	),
+
+	TP_printk("\"%s\" %x %o",
+		  __get_str(filename), __entry->flags, __entry->mode)
+);
+
+TRACE_EVENT(open_exec,
+
+	TP_PROTO(char *filename),
+
+	TP_ARGS(filename),
+
+	TP_STRUCT__entry(
+		__string(	filename, filename		)
+	),
+
+	TP_fast_assign(
+		__assign_str(filename, filename);
+	),
+
+	TP_printk("\"%s\"",
+		  __get_str(filename))
+);
+
+#endif /* _TRACE_FS_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff -x .git -urN linux-3.9/mm/filemap.c zen/mm/filemap.c
--- linux-3.9/mm/filemap.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/mm/filemap.c	2013-05-01 11:54:55.038790776 +0300
@@ -1304,6 +1304,9 @@
 	if (size > count)
 		size = count;
 
+	if (PageReadaheadUnused(page))
+		ClearPageReadaheadUnused(page);
+
 	/*
 	 * Faults on the destination of a read are common, so do it before
 	 * taking the kmap.
diff -x .git -urN linux-3.9/mm/memory.c zen/mm/memory.c
--- linux-3.9/mm/memory.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/mm/memory.c	2013-05-01 11:54:55.039790764 +0300
@@ -3351,10 +3351,15 @@
 	else
 		VM_BUG_ON(!PageLocked(vmf.page));
 
+	page = vmf.page;
+
+	/* Mark the page as used on fault. */
+	if (PageReadaheadUnused(page))
+		ClearPageReadaheadUnused(page);
+
 	/*
 	 * Should we do an early C-O-W break?
 	 */
-	page = vmf.page;
 	if (flags & FAULT_FLAG_WRITE) {
 		if (!(vma->vm_flags & VM_SHARED)) {
 			page = cow_page;
diff -x .git -urN linux-3.9/mm/mincore.c zen/mm/mincore.c
--- linux-3.9/mm/mincore.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/mm/mincore.c	2013-05-01 11:54:55.040790751 +0300
@@ -80,6 +80,8 @@
 #endif
 	if (page) {
 		present = PageUptodate(page);
+		if (present)
+			present |= (PageReadaheadUnused(page) << 7);
 		page_cache_release(page);
 	}
 
diff -x .git -urN linux-3.9/mm/page_alloc.c zen/mm/page_alloc.c
--- linux-3.9/mm/page_alloc.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/mm/page_alloc.c	2013-05-01 11:54:55.043790714 +0300
@@ -6143,6 +6143,7 @@
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 	{1UL << PG_compound_lock,	"compound_lock"	},
 #endif
+	{1UL << PG_readaheadunused,	"readaheadunused"},
 };
 
 static void dump_page_flags(unsigned long flags)
diff -x .git -urN linux-3.9/mm/readahead.c zen/mm/readahead.c
--- linux-3.9/mm/readahead.c	2013-04-29 03:36:01.000000000 +0300
+++ zen/mm/readahead.c	2013-05-01 11:54:55.044790701 +0300
@@ -189,6 +189,7 @@
 		list_add(&page->lru, &page_pool);
 		if (page_idx == nr_to_read - lookahead_size)
 			SetPageReadahead(page);
+		SetPageReadaheadUnused(page);
 		ret++;
 	}
 
