diff -uHNrp wine-20071130/dlls/avifil32/api.c wine-20071130e/dlls/avifil32/api.c
--- wine-20071130/dlls/avifil32/api.c	2007-12-01 21:14:16.000000000 +0300
+++ wine-20071130e/dlls/avifil32/api.c	2008-02-04 18:31:20.000000000 +0300
@@ -1065,9 +1065,9 @@ HRESULT WINAPI AVIBuildFilterW(LPWSTR sz
     HeapFree(GetProcessHeap(), 0, lp);
     return AVIERR_ERROR;
   }
-  for (n = 0;RegEnumKeyW(hKey, n, szFileExt, sizeof(szFileExt)) == S_OK;n++) {
+  for (n = 0;RegEnumKeyW(hKey, n, szFileExt, sizeof(szFileExt)/sizeof(szFileExt[0])) == S_OK;n++) {
     /* get CLSID to extension */
-    size = sizeof(szValue)/sizeof(szValue[0]);
+    size = sizeof(szValue);
     if (RegQueryValueW(hKey, szFileExt, szValue, &size) != S_OK)
       break;
 
@@ -1116,7 +1116,7 @@ HRESULT WINAPI AVIBuildFilterW(LPWSTR sz
   for (n = 0; n <= count; n++) {
     /* first the description */
     if (n != 0) {
-      size = sizeof(szValue)/sizeof(szValue[0]);
+      size = sizeof(szValue);
       if (RegQueryValueW(hKey, lp[n].szClsid, szValue, &size) == S_OK) {
 	size = lstrlenW(szValue);
 	lstrcpynW(szFilter, szValue, cbFilter);
diff -uHNrp wine-20071130/dlls/comctl32/listview.c wine-20071130e/dlls/comctl32/listview.c
--- wine-20071130/dlls/comctl32/listview.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/comctl32/listview.c	2008-02-04 18:31:20.000000000 +0300
@@ -6381,10 +6381,12 @@ static INT LISTVIEW_InsertItemT(LISTVIEW
         memcpy(&item, lpLVItem, offsetof( LVITEMW, iIndent ));
     }
     item.iItem = nItem;
+    /* Do not use stateMask in InsertItem */
+    item.stateMask = ~0;
+
     if (infoPtr->dwLvExStyle & LVS_EX_CHECKBOXES)
     {
         item.mask |= LVIF_STATE;
-        item.stateMask |= LVIS_STATEIMAGEMASK;
         item.state &= ~LVIS_STATEIMAGEMASK;
         item.state |= INDEXTOSTATEIMAGEMASK(1);
     }
@@ -6934,8 +6936,12 @@ static HIMAGELIST LISTVIEW_CreateCheckBo
     HBRUSH hbr_black = GetStockObject(BLACK_BRUSH);
     HIMAGELIST himl;
 
-    himl = ImageList_Create(GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
+   /* himl = ImageList_Create(GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
+                            ILC_COLOR | ILC_MASK, 2, 2);
+*/
+    himl = ImageList_Create(GetSystemMetrics(SM_CXSMICON)+10, GetSystemMetrics(SM_CYSMICON),
                             ILC_COLOR | ILC_MASK, 2, 2);
+    
     hdc_wnd = GetDC(infoPtr->hwndSelf);
     hdc = CreateCompatibleDC(hdc_wnd);
     hbm_im = CreateCompatibleBitmap(hdc_wnd, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON));
@@ -6991,10 +6997,10 @@ static DWORD LISTVIEW_SetExtendedListVie
     else
 	infoPtr->dwLvExStyle = dwStyle;
 
-    if((infoPtr->dwLvExStyle ^ dwOldStyle) & LVS_EX_CHECKBOXES)
+/*    if((infoPtr->dwLvExStyle ^ dwOldStyle) & LVS_EX_CHECKBOXES)*/
     {
         HIMAGELIST himl = 0;
-        if(infoPtr->dwLvExStyle & LVS_EX_CHECKBOXES)
+/*         if(infoPtr->dwLvExStyle & LVS_EX_CHECKBOXES)*/
         {
             LVITEMW item;
             item.mask = LVIF_STATE;
@@ -8465,6 +8471,9 @@ static LRESULT LISTVIEW_LButtonDown(LIST
   lvHitTestInfo.pt.y = y;
 
   nItem = LISTVIEW_HitTest(infoPtr, &lvHitTestInfo, TRUE, TRUE);
+  infoPtr->nFocusedItem = nItem;
+  infoPtr->uCallbackMask &= LVIS_FOCUSED;
+
   TRACE("at %s, nItem=%d\n", wine_dbgstr_point(&pt), nItem);
   infoPtr->nEditLabelItem = -1;
   if ((nItem >= 0) && (nItem < infoPtr->nItemCount))
@@ -8542,7 +8551,10 @@ static LRESULT LISTVIEW_LButtonDown(LIST
     LISTVIEW_DeselectAll(infoPtr);
     ReleaseCapture();
   }
-  
+
+  if (lvHitTestInfo.flags & LVHT_NOWHERE)
+    SendMessageW(infoPtr->hwndSelf, WM_KEYDOWN, (WPARAM) VK_SPACE, (LPARAM) 0x00390001);
+
   if (bReceivedFocus)
     infoPtr->nEditLabelItem = -1;
 
diff -uHNrp wine-20071130/dlls/comctl32/tab.c wine-20071130e/dlls/comctl32/tab.c
--- wine-20071130/dlls/comctl32/tab.c	2007-12-01 21:14:16.000000000 +0300
+++ wine-20071130e/dlls/comctl32/tab.c	2008-02-04 18:31:20.000000000 +0300
@@ -78,6 +78,8 @@
 #include "wine/debug.h"
 #include <math.h>
 
+#include "wine/etersoft.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(tab);
 
 typedef struct
@@ -235,18 +237,26 @@ static inline LRESULT TAB_GetCurSel (con
 static inline LRESULT
 TAB_GetCurFocus (const TAB_INFO *infoPtr)
 {
+    TRACE("cur focus: %d, sel:%d\n",infoPtr->uFocus,infoPtr->iSelected);
+    if (infoPtr->uFocus<0) // Lav
+    {
+        TRACE("we have not to return negative value\n");
+        return 0;
+    }
     return infoPtr->uFocus;
 }
 
 static inline LRESULT TAB_GetToolTips (const TAB_INFO *infoPtr)
 {
     if (infoPtr == NULL) return 0;
+    TRACE("\n");
     return (LRESULT)infoPtr->hwndToolTip;
 }
 
 static inline LRESULT TAB_SetCurSel (TAB_INFO *infoPtr, INT iItem)
 {
   INT prevItem = infoPtr->iSelected;
+  TRACE("infoPtr=%p, iSelected=%d, iItem=%d, uNumItem=%d\n",infoPtr,infoPtr->iSelected, iItem, infoPtr->uNumItem);
 
   if (iItem < 0)
       infoPtr->iSelected=-1;
@@ -1642,7 +1652,8 @@ TAB_DrawItemInterior(const TAB_INFO *inf
   /*
    * if owner draw, tell the owner to draw
    */
-  if ((lStyle & TCS_OWNERDRAWFIXED) && GetParent(infoPtr->hwnd))
+  LOADETER_FUNC(etersoft_is_initialize);
+  if ( !(etersoft_is_initialize && etersoft_is_initialize()) && (lStyle & TCS_OWNERDRAWFIXED) && GetParent(infoPtr->hwnd))
   {
     DRAWITEMSTRUCT dis;
     UINT id;
@@ -1680,6 +1691,11 @@ TAB_DrawItemInterior(const TAB_INFO *inf
     /*
      * send the draw message
      */
+    /* Etersoft's fixes */
+    LOADETER_FUNC(etersoft_fixtab);
+    if (etersoft_fixtab)
+        etersoft_fixtab(&dis.itemData, sizeof(ULONG_PTR));
+
     SendMessageW( infoPtr->hwndNotify, WM_DRAWITEM, (WPARAM)id, (LPARAM)&dis );
   }
   else
diff -uHNrp wine-20071130/dlls/comctl32/tests/listview.c wine-20071130e/dlls/comctl32/tests/listview.c
--- wine-20071130/dlls/comctl32/tests/listview.c	2007-12-01 21:14:16.000000000 +0300
+++ wine-20071130e/dlls/comctl32/tests/listview.c	2008-02-04 18:31:20.000000000 +0300
@@ -835,7 +835,36 @@ static void test_icon_spacing(void)
     flush_sequences(sequences, NUM_MSG_SEQUENCES);
     DestroyWindow(hwnd);
 }
+ 
+LVITEM items[] = {
+    {LVIF_STATE, 0, 0, LVIS_SELECTED, LVIS_SELECTED},
+    {LVIF_STATE, 1, 0, LVIS_SELECTED, 0},
+    {LVIF_STATE, 2, 0, LVIS_SELECTED, LVIS_DROPHILITED}};
 
+static void test_item_state(void)
+{
+    /*LVM_INSERTITEMA*/
+
+    HWND hwnd;
+    int i;
+    UINT state;
+
+    hwnd = create_listview_control();
+    ok(hwnd != NULL, "failed to create a listview window\n");
+
+    flush_sequences(sequences, NUM_MSG_SEQUENCES);
+
+    for (i = 0; i < sizeof(items) / sizeof(LVITEM); i++)
+    {
+        SendMessage(hwnd, LVM_INSERTITEM, 0, (LPARAM) &items[i]);
+
+        state = SendMessage(hwnd, LVM_GETITEMSTATE, i, 0xffff);
+        ok(state == 0x2, "test_item_state: items[%d].state = 0x%x\n", i, state);
+    }
+
+    DestroyWindow(hwnd);
+}
+ 
 static void test_color(void)
 {
     /* SETBKCOLOR/GETBKCOLOR, SETTEXTCOLOR/GETTEXTCOLOR, SETTEXTBKCOLOR/GETTEXTBKCOLOR */
@@ -1064,4 +1093,5 @@ START_TEST(listview)
     test_item_count();
     test_item_position();
     test_columns();
+    test_item_state();
 }
diff -uHNrp wine-20071130/dlls/comctl32/toolbar.c wine-20071130e/dlls/comctl32/toolbar.c
--- wine-20071130/dlls/comctl32/toolbar.c	2007-12-01 21:14:16.000000000 +0300
+++ wine-20071130e/dlls/comctl32/toolbar.c	2008-02-04 18:31:20.000000000 +0300
@@ -3768,6 +3768,7 @@ TOOLBAR_InsertButtonT(HWND hwnd, WPARAM 
     TOOLBAR_INFO *infoPtr = TOOLBAR_GetInfoPtr (hwnd);
     LPTBBUTTON lpTbb = (LPTBBUTTON)lParam;
     INT nIndex = (INT)wParam;
+    LPARAM lParam1;
 
     if (lpTbb == NULL)
 	return FALSE;
@@ -3814,7 +3815,14 @@ TOOLBAR_InsertButtonT(HWND hwnd, WPARAM 
         infoPtr->buttons[nIndex].iString   = lpTbb->iString;
 
     TOOLBAR_TooltipAddTool(infoPtr, &infoPtr->buttons[nIndex]);
-
+    //MYCHANGE
+    if((infoPtr->buttons[4].iBitmap==-1)&&(infoPtr->buttons[3].iBitmap==-1)&& (infoPtr->buttons[2].iBitmap==-1)&&(infoPtr->buttons[1].iBitmap==-1)&& (infoPtr->buttons[0].iBitmap==-1)&&(infoPtr->nBitmapWidth<12))
+    {
+    TRACE("WORKING WITH MENU .... SBIS \n");
+    lParam1=(LPARAM)MAKELONG(infoPtr->nBitmapWidth,12);
+    SendMessageA(hwnd,TB_SETBITMAPSIZE,0,lParam1);
+    }
+    ///////
     if (infoPtr->nNumStrings > 0)
         TOOLBAR_CalcToolbar(hwnd);
     else
diff -uHNrp wine-20071130/dlls/comctl32/treeview.c wine-20071130e/dlls/comctl32/treeview.c
--- wine-20071130/dlls/comctl32/treeview.c	2007-12-01 21:14:16.000000000 +0300
+++ wine-20071130e/dlls/comctl32/treeview.c	2008-02-04 18:31:20.000000000 +0300
@@ -2800,6 +2800,20 @@ TREEVIEW_EraseBackground(const TREEVIEW_
     RECT rect;
 
     GetClientRect(infoPtr->hwnd, &rect);
+    if(!(GetWindowLongW(infoPtr->hwnd, GWL_STYLE) & TVS_NOSCROLL) )
+    {
+        rect.right += GetSystemMetrics(SM_CXVSCROLL);
+        rect.bottom += GetSystemMetrics(SM_CYVSCROLL);
+        rect.right += GetSystemMetrics(SM_CXHSCROLL);
+        rect.bottom += GetSystemMetrics(SM_CYHSCROLL);
+    }
+    else
+        if(!(GetWindowLongW(infoPtr->hwnd, GWL_STYLE) & TVS_NOHSCROLL))
+        {
+            rect.right += GetSystemMetrics(SM_CXHSCROLL);
+            rect.bottom += GetSystemMetrics(SM_CYHSCROLL);
+        }
+
     FillRect(hDC, &rect, hBrush);
     DeleteObject(hBrush);
 
@@ -4981,8 +4995,15 @@ TREEVIEW_Create(HWND hwnd, const CREATES
         initialize_checkboxes(infoPtr);
 
     /* Make sure actual scrollbar state is consistent with uInternalStatus */
-    ShowScrollBar(hwnd, SB_VERT, FALSE);
-    ShowScrollBar(hwnd, SB_HORZ, FALSE);
+    if(infoPtr->dwStyle & TVS_NOSCROLL)
+    {
+        ShowScrollBar(hwnd, SB_VERT, FALSE);
+        ShowScrollBar(hwnd, SB_HORZ, FALSE);
+    }
+    else
+        if(infoPtr->dwStyle & TVS_NOHSCROLL)
+            ShowScrollBar(hwnd, SB_HORZ, FALSE);
+    
     
     OpenThemeData (hwnd, themeClass);
 
diff -uHNrp wine-20071130/dlls/comctl32/updown.c wine-20071130e/dlls/comctl32/updown.c
--- wine-20071130/dlls/comctl32/updown.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/comctl32/updown.c	2008-02-04 18:31:20.000000000 +0300
@@ -71,7 +71,7 @@ typedef struct
 #define AUTOPRESS_DELAY	250    /* time to keep arrow pressed on KEY_DOWN */
 #define REPEAT_DELAY	50     /* delay between auto-increments */
 
-#define DEFAULT_WIDTH	    14 /* default width of the ctrl */
+#define DEFAULT_WIDTH	    18 /* default width of the ctrl */
 #define DEFAULT_XSEP         0 /* default separation between buddy and ctrl */
 #define DEFAULT_ADDTOP       0 /* amount to extend above the buddy window */
 #define DEFAULT_ADDBOT       0 /* amount to extend below the buddy window */
diff -uHNrp wine-20071130/dlls/comdlg32/filedlg.c wine-20071130e/dlls/comdlg32/filedlg.c
--- wine-20071130/dlls/comdlg32/filedlg.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/comdlg32/filedlg.c	2008-02-04 18:31:20.000000000 +0300
@@ -252,7 +252,7 @@ static BOOL WINAPI GetFileName95(FileOpe
     /* test for missing functionality */
     if (fodInfos->ofnInfos->Flags & UNIMPLEMENTED_FLAGS)
     {
-      FIXME("Flags 0x%08x not yet implemented\n",
+      TRACE("Flags 0x%08x not yet implemented\n",
          fodInfos->ofnInfos->Flags & UNIMPLEMENTED_FLAGS);
     }
 
@@ -1797,16 +1797,13 @@ BOOL FILEDLG95_OnOpen(HWND hwnd)
 
   TRACE("hwnd=%p\n", hwnd);
 
+  /* if the user selected a folder in the shellview */
+  if(BrowseSelectedFolder(hwnd))
+      return FALSE;
+
   /* get the files from the edit control */
   nFileCount = FILEDLG95_FILENAME_GetFileNames(hwnd, &lpstrFileList, &sizeUsed, '\0');
 
-  /* try if the user selected a folder in the shellview */
-  if(nFileCount == 0)
-  {
-      BrowseSelectedFolder(hwnd);
-      return FALSE;
-  }
-
   if(nFileCount > 1)
   {
       ret = FILEDLG95_OnOpenMultipleFiles(hwnd, lpstrFileList, nFileCount, sizeUsed);
diff -uHNrp wine-20071130/dlls/comdlg32/fontdlg.c wine-20071130e/dlls/comdlg32/fontdlg.c
--- wine-20071130/dlls/comdlg32/fontdlg.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/comdlg32/fontdlg.c	2008-02-04 18:31:20.000000000 +0300
@@ -512,7 +512,6 @@ INT AddFontStyle( const ENUMLOGFONTEXW *
 static INT CFn_FitFontSize( HWND hDlg, int points)
 {
     int i,n;
-    int ret = 0;
     /* look for fitting font size in combobox3 */
     n=SendDlgItemMessageW(hDlg, cmb3, CB_GETCOUNT, 0, 0);
     for (i=0;i<n;i++)
@@ -524,17 +523,20 @@ static INT CFn_FitFontSize( HWND hDlg, i
             SendMessageW(hDlg, WM_COMMAND,
                     MAKEWPARAM(cmb3, CBN_SELCHANGE),
                     (LPARAM)GetDlgItem(hDlg,cmb3));
-            ret = 1;
-            break;
+            return  1;
         }
     }
-    return ret;
+    /* no size fits: select the first one in the list */
+    SendDlgItemMessageW(hDlg, cmb3, CB_SETCURSEL, 0, 0);
+    SendMessageW(hDlg, WM_COMMAND, MAKEWPARAM(cmb3, CBN_SELCHANGE),
+            (LPARAM)GetDlgItem(hDlg,cmb3));
+    return 0;
 }
 
 static INT CFn_FitFontStyle( HWND hDlg, LONG packedstyle )
 {
     LONG id;
-    int i, ret = 0;
+    int i;
     /* look for fitting font style in combobox2 */
     for (i=0;i<TEXT_EXTRAS;i++)
     {
@@ -544,11 +546,15 @@ static INT CFn_FitFontStyle( HWND hDlg, 
             SendDlgItemMessageW(hDlg, cmb2, CB_SETCURSEL, i, 0);
             SendMessageW(hDlg, WM_COMMAND, MAKEWPARAM(cmb2, CBN_SELCHANGE),
                     (LPARAM)GetDlgItem(hDlg,cmb2));
-            ret = 1;
-            break;
+
+            return 1;
         }
     }
-    return ret;
+    /* no style fits: select the first one in the list */
+    SendDlgItemMessageW(hDlg, cmb2, CB_SETCURSEL, 0, 0);
+    SendMessageW(hDlg, WM_COMMAND, MAKEWPARAM(cmb2, CBN_SELCHANGE),
+            (LPARAM)GetDlgItem(hDlg,cmb2));
+    return 0;
 }
 
 
diff -uHNrp wine-20071130/dlls/comdlg32/printdlg.c wine-20071130e/dlls/comdlg32/printdlg.c
--- wine-20071130/dlls/comdlg32/printdlg.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/comdlg32/printdlg.c	2008-02-04 18:31:20.000000000 +0300
@@ -5,6 +5,8 @@
  * Copyright 1996 Albrecht Kleine
  * Copyright 1999 Klaas van Gend
  * Copyright 2000 Huw D M Davies
+ * Copyright 2005 Eugene Gorelov
+ * Copyright 2005 Vitaly Lipatov
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -36,6 +38,7 @@
 #include "winerror.h"
 
 #include "wine/debug.h"
+#include "wine/unicode.h"
 
 #include "commdlg.h"
 #include "dlgs.h"
@@ -90,7 +93,18 @@ BOOL PRINTDLG_OpenDefaultPrinter(HANDLE 
     DWORD dwBufLen = sizeof(buf) / sizeof(buf[0]);
     BOOL res;
     if(!GetDefaultPrinterW(buf, &dwBufLen))
-        return FALSE;
+    {
+        DWORD size, finded;
+        PRINTER_INFO_1W buffer;
+        if (EnumPrintersW(PRINTER_ENUM_LOCAL, 
+            NULL, 1, (LPBYTE) &buffer, sizeof(buffer), &size, &finded))
+        {
+            if (!finded) return FALSE;
+            strcpyW(buf, buffer.pName);
+        }
+        else
+            return FALSE;
+    }
     res = OpenPrinterW(buf, hprn, NULL);
     if (!res)
         WARN("Could not open printer %s\n", debugstr_w(buf));
@@ -306,6 +320,8 @@ static BOOL PRINTDLG_UpdatePrintDlgA(HWN
 	    WORD nFromPage;
 	    nFromPage = GetDlgItemInt(hDlg, edt1, NULL, FALSE);
 	    nToPage   = GetDlgItemInt(hDlg, edt2, NULL, FALSE);
+            if (nToPage < 1)
+                nToPage = lppd->nMaxPage;
 	    if (nFromPage < lppd->nMinPage || nFromPage > lppd->nMaxPage ||
 		nToPage < lppd->nMinPage || nToPage > lppd->nMaxPage) {
 	        char resourcestr[256];
@@ -355,12 +371,18 @@ static BOOL PRINTDLG_UpdatePrintDlgA(HWN
 		  (IsDlgButtonChecked(hDlg, chx2) == BST_CHECKED);
 	    if (lpdm->dmFields & DM_COPIES)
 	        lpdm->u1.s1.dmCopies = GetDlgItemInt(hDlg, edt3, NULL, FALSE);
+            if (lpdm->u1.s1.dmCopies < 1)
+                lpdm->u1.s1.dmCopies = 0;
 	} else {
 	    if (IsDlgButtonChecked(hDlg, chx2) == BST_CHECKED)
 	        lppd->Flags |= PD_COLLATE;
             else
                lppd->Flags &= ~PD_COLLATE;
             lppd->nCopies = GetDlgItemInt(hDlg, edt3, NULL, FALSE);
+            if (lppd->nCopies < 1)
+               lppd->nCopies = 0;
+            if (lpdm->dmFields & DM_COPIES)
+               lpdm->u1.s1.dmCopies = lppd->nCopies;
 	}
     }
     return TRUE;
@@ -930,7 +952,10 @@ BOOL PRINTDLG_ChangePrinterA(HWND hDlg, 
     if(!(lppd->Flags & PD_PRINTSETUP)) {
       /* Print range (All/Range/Selection) */
         SetDlgItemInt(hDlg, edt1, lppd->nFromPage, FALSE);
-	SetDlgItemInt(hDlg, edt2, lppd->nToPage, FALSE);
+        if (lppd->nToPage >= lppd->nMaxPage)
+              SetDlgItemTextA(hDlg, edt2, "");
+        else
+              SetDlgItemInt(hDlg, edt2, lppd->nToPage, FALSE);
 	CheckRadioButton(hDlg, rad1, rad3, rad1);		/* default */
 	if (lppd->Flags & PD_NOSELECTION)
 	    EnableWindow(GetDlgItem(hDlg, rad2), FALSE);
@@ -973,7 +998,8 @@ BOOL PRINTDLG_ChangePrinterA(HWND hDlg, 
 	/* nCopies */
 	{
 	  INT copies;
-	  if (lppd->hDevMode == 0)
+          copies = lppd->nCopies;
+ 	  if (lppd->hDevMode && !copies)
 	      copies = lppd->nCopies;
 	  else
 	      copies = lpdm->u1.s1.dmCopies;
@@ -2717,10 +2743,10 @@ PRINTDLG_PS_ChangePaperPrev(const PageSe
     LONG width, height, x, y;
     RECT rtTmp;
     
-    if(pda->curdlg.ptPaperSize.x > pda->curdlg.ptPaperSize.y) {
+    if(pda->curdlg.ptPaperSize.x > pda->curdlg.ptPaperSize.y && pda->curdlg.ptPaperSize.x) {
 	width  = pda->rtDrawRect.right - pda->rtDrawRect.left;
 	height = pda->curdlg.ptPaperSize.y * width / pda->curdlg.ptPaperSize.x;
-    } else {
+    } else if (pda->curdlg.ptPaperSize.y){
 	height = pda->rtDrawRect.bottom - pda->rtDrawRect.top;
 	width  = pda->curdlg.ptPaperSize.x * height / pda->curdlg.ptPaperSize.y;
     }
@@ -2890,10 +2916,10 @@ PRINTDLG_PS_WMCommandA(
     	GETVAL(id, pda->curdlg.rtMargin.left);
 	break;
     case edt5:
-    	GETVAL(id, pda->curdlg.rtMargin.right);
+    	GETVAL(id, pda->curdlg.rtMargin.top);
 	break;
     case edt6:
-    	GETVAL(id, pda->curdlg.rtMargin.top);
+    	GETVAL(id, pda->curdlg.rtMargin.right);
 	break;
     case edt7:
     	GETVAL(id, pda->curdlg.rtMargin.bottom);
@@ -2952,7 +2978,7 @@ PRINTDLG_DefaultPagePaintHook(HWND hwndD
     TRACE("uMsg: WM_USER+%d\n",uMsg-WM_USER);
     /* Call user paint hook if enable */
     if (pda->dlga->Flags & PSD_ENABLEPAGEPAINTHOOK)
-        if (pda->dlga->lpfnPagePaintHook(hwndDlg, uMsg, wParam, lParam))
+        if (pda->dlga->lpfnPagePaintHook && pda->dlga->lpfnPagePaintHook(hwndDlg, uMsg, wParam, lParam))
             return TRUE;
 
     switch (uMsg) {
@@ -3048,7 +3074,6 @@ PRINTDLG_PagePaintProc(HWND hWnd, UINT u
     HBRUSH hbrush, holdbrush;
     PageSetupDataA *pda;
     int papersize=0, orientation=0; /* FIXME: set this values for user paint hook */
-    double scalx, scaly;
 #define CALLPAINTHOOK(msg,lprc) PRINTDLG_DefaultPagePaintHook( hWnd, msg, (WPARAM)hdc, (LPARAM)lprc, pda)
 
     if (uMsg != WM_PAINT)
@@ -3066,15 +3091,14 @@ PRINTDLG_PagePaintProc(HWND hWnd, UINT u
     hdc = BeginPaint(hWnd, &ps);
     GetClientRect(hWnd, &rcClient);
     
-    scalx = rcClient.right  / (double)pda->curdlg.ptPaperSize.x;
-    scaly = rcClient.bottom / (double)pda->curdlg.ptPaperSize.y; 
     rcMargin = rcClient;
- 
-    rcMargin.left   += (LONG)pda->curdlg.rtMargin.left   * scalx;
-    rcMargin.top    += (LONG)pda->curdlg.rtMargin.top    * scalx;
-    rcMargin.right  -= (LONG)pda->curdlg.rtMargin.right  * scaly;
-    rcMargin.bottom -= (LONG)pda->curdlg.rtMargin.bottom * scaly;
-    
+    if (pda->curdlg.ptPaperSize.x && pda->curdlg.ptPaperSize.y) {
+        rcMargin.left   += pda->curdlg.rtMargin.left   * rcClient.right  / pda->curdlg.ptPaperSize.x;
+        rcMargin.top    += pda->curdlg.rtMargin.top    * rcClient.bottom / pda->curdlg.ptPaperSize.y;
+        rcMargin.right  -= pda->curdlg.rtMargin.right  * rcClient.right  / pda->curdlg.ptPaperSize.x;
+        rcMargin.bottom -= pda->curdlg.rtMargin.bottom * rcClient.bottom / pda->curdlg.ptPaperSize.y;
+    }
+
     /* if the space is too small then we make sure to not draw anything */
     rcMargin.left = min(rcMargin.left, rcMargin.right);
     rcMargin.top = min(rcMargin.top, rcMargin.bottom);
@@ -3161,10 +3185,10 @@ PRINTDLG_PageDlgProcA(HWND hDlg, UINT uM
             GWLP_WNDPROC,
             (ULONG_PTR)PRINTDLG_PagePaintProc);
 	
-	/* FIXME: Paint hook. Must it be at begin of initializtion or at end? */
+	/* Process WM_INITDIALOG with PageSetupHook before other messages */
 	res = TRUE;
 	if (pda->dlga->Flags & PSD_ENABLEPAGESETUPHOOK) {
-            if (!pda->dlga->lpfnPageSetupHook(hDlg,uMsg,wParam,(LPARAM)pda->dlga))
+            if (pda->dlga->lpfnPageSetupHook && !pda->dlga->lpfnPageSetupHook(hDlg,uMsg,wParam,(LPARAM)pda->dlga))
 		FIXME("Setup page hook failed?\n");
 	}
 
@@ -3249,14 +3273,20 @@ PRINTDLG_PageDlgProcA(HWND hDlg, UINT uM
 	    WARN("__WINE_PAGESETUPDLGDATA prop not set?\n");
 	    return FALSE;
 	}
-	if (pda->dlga->Flags & PSD_ENABLEPAGESETUPHOOK) {
-	    res = pda->dlga->lpfnPageSetupHook(hDlg,uMsg,wParam,lParam);
-	    if (res) return res;
-	}
+
+        if (pda->dlga->Flags & PSD_ENABLEPAGESETUPHOOK) {
+           if (pda->dlga->lpfnPageSetupHook && pda->dlga->lpfnPageSetupHook(hDlg, uMsg, wParam, lParam))
+               return TRUE; /* do not process this message with default procedure */
+               /* TODO: if hook processes message it must returns a valid brush handle */
+        }
     }
     switch (uMsg) {
     case WM_COMMAND:
         return PRINTDLG_PS_WMCommandA(hDlg, wParam, lParam, pda);
+/*    case WM_CTLCOLORDLG:*/
+        /* FIXME: any other WM_CTLCOLORDLG* ? */
+/*        FIXME("WM_CTLCOLORDLG do not realize yet\n");*/
+/*	return TRUE;*/
     }
     return FALSE;
 }
diff -uHNrp wine-20071130/dlls/dnsapi/dnsapi.h wine-20071130e/dlls/dnsapi/dnsapi.h
--- wine-20071130/dlls/dnsapi/dnsapi.h	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/dnsapi/dnsapi.h	2008-02-04 18:31:20.000000000 +0300
@@ -18,6 +18,19 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include <stdarg.h>
+#include <sys/types.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winnls.h"
+
+#ifdef HAVE_ARPA_NAMESER_H
+# undef NOERROR
+# undef DELETE
+# include <arpa/nameser.h>
+#endif
+
 
 static inline void *heap_alloc( SIZE_T size )
 {
diff -uHNrp wine-20071130/dlls/dnsapi/name.c wine-20071130e/dlls/dnsapi/name.c
--- wine-20071130/dlls/dnsapi/name.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/dnsapi/name.c	2008-02-04 18:31:20.000000000 +0300
@@ -29,10 +29,6 @@
 #ifdef HAVE_NETINET_IN_H
 # include <netinet/in.h>
 #endif
-#ifdef HAVE_ARPA_NAMESER_H
-# include <arpa/nameser.h>
-# undef NOERROR
-#endif
 #ifdef HAVE_RESOLV_H
 # include <resolv.h>
 #endif
diff -uHNrp wine-20071130/dlls/dnsapi/ns_name.c wine-20071130e/dlls/dnsapi/ns_name.c
--- wine-20071130/dlls/dnsapi/ns_name.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/dnsapi/ns_name.c	2008-02-04 18:31:20.000000000 +0300
@@ -22,9 +22,6 @@
 #ifdef HAVE_NETINET_IN_H
 # include <netinet/in.h>
 #endif
-#ifdef HAVE_ARPA_NAMESER_H
-# include <arpa/nameser.h>
-#endif
 
 #include <ctype.h>
 #include <errno.h>
@@ -33,6 +30,8 @@
 #endif
 #include <string.h>
 
+#include "dnsapi.h"
+
 /* Data. */
 
 static const char	digits[] = "0123456789";
diff -uHNrp wine-20071130/dlls/dnsapi/ns_parse.c wine-20071130e/dlls/dnsapi/ns_parse.c
--- wine-20071130/dlls/dnsapi/ns_parse.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/dnsapi/ns_parse.c	2008-02-04 18:31:20.000000000 +0300
@@ -24,9 +24,6 @@
 #ifdef HAVE_NETINET_IN_H
 # include <netinet/in.h>
 #endif
-#ifdef HAVE_ARPA_NAMESER_H
-# include <arpa/nameser.h>
-#endif
 
 #include <errno.h>
 #ifdef HAVE_RESOLV_H
@@ -36,6 +33,8 @@
 
 #include "windef.h"
 
+#include "dnsapi.h"
+
 /* Forward. */
 
 static void	setsection(ns_msg *msg, ns_sect sect);
diff -uHNrp wine-20071130/dlls/dnsapi/query.c wine-20071130e/dlls/dnsapi/query.c
--- wine-20071130/dlls/dnsapi/query.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/dnsapi/query.c	2008-02-04 18:31:20.000000000 +0300
@@ -29,9 +29,6 @@
 #ifdef HAVE_NETINET_IN_H
 # include <netinet/in.h>
 #endif
-#ifdef HAVE_ARPA_NAMESER_H
-# include <arpa/nameser.h>
-#endif
 #ifdef HAVE_RESOLV_H
 # include <resolv.h>
 #endif
diff -uHNrp wine-20071130/dlls/dnsapi/record.c wine-20071130e/dlls/dnsapi/record.c
--- wine-20071130/dlls/dnsapi/record.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/dnsapi/record.c	2008-02-04 18:31:20.000000000 +0300
@@ -29,9 +29,6 @@
 #ifdef HAVE_NETINET_IN_H
 # include <netinet/in.h>
 #endif
-#ifdef HAVE_ARPA_NAMESER_H
-# include <arpa/nameser.h>
-#endif
 #ifdef HAVE_RESOLV_H
 # include <resolv.h>
 #endif
diff -uHNrp wine-20071130/dlls/gdi32/enhmfdrv/graphics.c wine-20071130e/dlls/gdi32/enhmfdrv/graphics.c
--- wine-20071130/dlls/gdi32/enhmfdrv/graphics.c	2007-12-01 21:14:15.000000000 +0300
+++ wine-20071130e/dlls/gdi32/enhmfdrv/graphics.c	2008-02-04 18:31:20.000000000 +0300
@@ -462,8 +462,9 @@ BOOL
 EMFDRV_Polygon( PHYSDEV dev, const POINT* pt, INT count )
 {
     if(count < 2) return FALSE;
-    if( EMFDRV_Polylinegon16( dev, pt, count, EMR_POLYGON16 ) )
+/* FIXME: eterbug#140 */   if( EMFDRV_Polylinegon16( dev, pt, count, EMR_POLYGON16 ) )
         return TRUE;
+
     return EMFDRV_Polylinegon( dev, pt, count, EMR_POLYGON );
 }
 
diff -uHNrp wine-20071130/dlls/gdi32/font.c wine-20071130e/dlls/gdi32/font.c
--- wine-20071130/dlls/gdi32/font.c	2007-12-01 21:14:15.000000000 +0300
+++ wine-20071130e/dlls/gdi32/font.c	2008-02-04 18:31:20.000000000 +0300
@@ -1027,7 +1027,9 @@ INT WINAPI SetTextCharacterExtra( HDC hd
 BOOL WINAPI SetTextJustification( HDC hdc, INT extra, INT breaks )
 {
     BOOL ret = TRUE;
-    DC * dc = DC_GetDCPtr( hdc );
+    DC * dc;
+    return TRUE; /* skip this func */
+    dc = DC_GetDCPtr( hdc );
     if (!dc) return FALSE;
     if (dc->funcs->pSetTextJustification)
         ret = dc->funcs->pSetTextJustification( dc->physDev, extra, breaks );
@@ -3316,6 +3318,11 @@ UINT WINAPI GetTextCharsetInfo(HDC hdc, 
 
         DC_ReleaseDCPtr( dc );
     }
+    if (ret == ANSI_CHARSET )
+        ret = DEFAULT_CHARSET;
+
+    if (ret == VIETNAMESE_CHARSET)
+        ret = DEFAULT_CHARSET;
 
     if (ret == DEFAULT_CHARSET && fs)
         memset(fs, 0, sizeof(FONTSIGNATURE));
diff -uHNrp wine-20071130/dlls/gdi32/freetype.c wine-20071130e/dlls/gdi32/freetype.c
--- wine-20071130/dlls/gdi32/freetype.c	2007-12-01 21:14:15.000000000 +0300
+++ wine-20071130e/dlls/gdi32/freetype.c	2008-02-04 18:31:20.000000000 +0300
@@ -2168,6 +2168,15 @@ BOOL WineEngInit(void)
     /* load the system bitmap fonts */
     load_system_fonts();
 
+    /* Hack for first LiberationSans-Regular.ttf */
+    data_dir = wine_get_data_dir();
+    if (data_dir && (unixname = HeapAlloc(GetProcessHeap(), 0, strlen(data_dir) + sizeof("/fonts/LiberationSans-Regular.ttf")))) {
+        strcpy(unixname, data_dir);
+        strcat(unixname, "/fonts/LiberationSans-Regular.ttf");
+        AddFontFileToList(unixname, NULL, NULL, 0);
+        HeapFree(GetProcessHeap(), 0, unixname);
+    }
+
     /* load in the fonts from %WINDOWSDIR%\\Fonts first of all */
     GetWindowsDirectoryW(windowsdir, sizeof(windowsdir) / sizeof(WCHAR));
     strcatW(windowsdir, fontsW);
diff -uHNrp wine-20071130/dlls/gdi32/printdrv.c wine-20071130e/dlls/gdi32/printdrv.c
--- wine-20071130/dlls/gdi32/printdrv.c	2007-12-01 21:14:15.000000000 +0300
+++ wine-20071130e/dlls/gdi32/printdrv.c	2008-02-04 18:31:20.000000000 +0300
@@ -450,7 +450,7 @@ static int CreateSpoolFile(LPCSTR pszOut
 
     /* TTD convert the 'output device' into a spool file name */
 
-    if (pszOutput == NULL || *pszOutput == '\0')
+    if (pszOutput == NULL)
       return -1;
 
     psCmd[0] = 0;
@@ -463,6 +463,10 @@ static int CreateSpoolFile(LPCSTR pszOut
     }
     if (!psCmd[0] && !strncmp("LPR:",pszOutput,4))
         sprintf(psCmd,"|lpr -P'%s'",pszOutput+4);
+    else
+        /* Hack for print to lpr default if output device is empty. TODO: write test and use Windows default device */
+        if (*pszOutput == '\0')
+            strcpy( psCmd,"|lpr");
 
     TRACE("Got printerSpoolCommand '%s' for output device '%s'\n",
 	  psCmd, pszOutput);
diff -uHNrp wine-20071130/dlls/imagehlp/modify.c wine-20071130e/dlls/imagehlp/modify.c
--- wine-20071130/dlls/imagehlp/modify.c	2007-12-01 21:14:18.000000000 +0300
+++ wine-20071130e/dlls/imagehlp/modify.c	2008-02-04 18:31:20.000000000 +0300
@@ -48,7 +48,7 @@ BOOL WINAPI BindImageEx(
   DWORD Flags, PCSTR ImageName, PCSTR DllPath, PCSTR SymbolPath,
   PIMAGEHLP_STATUS_ROUTINE StatusRoutine)
 {
-  FIXME("(%d, %s, %s, %s, %p): stub\n",
+  TRACE("(%d, %s, %s, %s, %p): stub\n",
     Flags, debugstr_a(ImageName), debugstr_a(DllPath),
     debugstr_a(SymbolPath), StatusRoutine
   );
diff -uHNrp wine-20071130/dlls/inetcomm/mimeole.c wine-20071130e/dlls/inetcomm/mimeole.c
--- wine-20071130/dlls/inetcomm/mimeole.c	2007-12-01 21:14:22.000000000 +0300
+++ wine-20071130e/dlls/inetcomm/mimeole.c	2008-02-04 18:31:20.000000000 +0300
@@ -20,6 +20,7 @@
  */
 
 #define COBJMACROS
+#define NONAMELESSUNION
 
 #include <stdarg.h>
 #include <stdio.h>
@@ -343,7 +344,7 @@ static void read_value(header_t *header,
     }
 
     header->value.vt = VT_LPSTR;
-    header->value.pszVal = value;
+    header->value.u.pszVal = value;
 
     *cur = end;
 }
@@ -359,15 +360,15 @@ static void init_content_type(MimeBody *
         return;
     }
 
-    slash = strchr(header->value.pszVal, '/');
+    slash = strchr(header->value.u.pszVal, '/');
     if(!slash)
     {
         WARN("malformed context type value\n");
         return;
     }
-    len = slash - header->value.pszVal;
+    len = slash - header->value.u.pszVal;
     body->content_pri_type = HeapAlloc(GetProcessHeap(), 0, len + 1);
-    memcpy(body->content_pri_type, header->value.pszVal, len);
+    memcpy(body->content_pri_type, header->value.u.pszVal, len);
     body->content_pri_type[len] = '\0';
     body->content_sub_type = strdupA(slash + 1);
 }
diff -uHNrp wine-20071130/dlls/kernel32/comm.c wine-20071130e/dlls/kernel32/comm.c
--- wine-20071130/dlls/kernel32/comm.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/kernel32/comm.c	2008-02-04 18:31:20.000000000 +0300
@@ -760,7 +760,7 @@ BOOL WINAPI SetCommMask(HANDLE handle, D
 
 static void dump_dcb(const DCB* lpdcb)
 {
-    TRACE("bytesize=%d baudrate=%d fParity=%d Parity=%d stopbits=%d\n",
+    TRACE("ByteSize=%d BaudRate=%d fParity=%d Parity=%d StopBits=%d\n",
           lpdcb->ByteSize, lpdcb->BaudRate, lpdcb->fParity, lpdcb->Parity,
           (lpdcb->StopBits == ONESTOPBIT) ? 1 :
           (lpdcb->StopBits == TWOSTOPBITS) ? 2 : 0);
diff -uHNrp wine-20071130/dlls/kernel32/except.c wine-20071130e/dlls/kernel32/except.c
--- wine-20071130/dlls/kernel32/except.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/kernel32/except.c	2008-02-04 18:31:20.000000000 +0300
@@ -440,7 +440,7 @@ static inline BOOL check_no_exec( void *
     default: return FALSE;
     }
     /* FIXME: we should probably have a per-app option, and maybe a message box */
-    FIXME( "No-exec fault triggered at %p, enabling work-around\n", addr );
+    TRACE( "No-exec fault triggered at %p, enabling work-around\n", addr );
     return VirtualProtect( addr, 1, info.Protect, NULL );
 }
 
diff -uHNrp wine-20071130/dlls/kernel32/file.c wine-20071130e/dlls/kernel32/file.c
--- wine-20071130/dlls/kernel32/file.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/kernel32/file.c	2008-02-04 18:31:20.000000000 +0300
@@ -46,6 +46,7 @@
 #include "wine/unicode.h"
 #include "wine/debug.h"
 #include "thread.h"
+#include "wine/etersoft.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(file);
 
@@ -1059,7 +1060,13 @@ BOOL WINAPI LockFile( HANDLE hFile, DWOR
     status = NtLockFile( hFile, 0, NULL, NULL,
                          NULL, &offset, &count, NULL, TRUE, TRUE );
 
-    if (status != STATUS_SUCCESS) SetLastError( RtlNtStatusToDosError(status) );
+    if (status != STATUS_SUCCESS) 
+    {
+        SetLastError( RtlNtStatusToDosError(status) );
+        TRACE( "returning=%d, GetLastError=%d\n",
+           !status, GetLastError() );
+    }
+
     return !status;
 }
 
@@ -1886,7 +1893,21 @@ HANDLE WINAPI FindFirstFileExA( LPCSTR l
     WIN32_FIND_DATAW dataW;
     WCHAR *nameW;
 
-    if (!(nameW = FILE_name_AtoW( lpFileName, FALSE ))) return INVALID_HANDLE_VALUE;
+    LOADETER_FUNC(etersoft_1version);
+    if ( etersoft_1version && etersoft_1version() == 7 && GetVersion() & 0x80000000)
+    {
+        char* nameA;
+        char* c;
+        nameA = HeapAlloc(GetProcessHeap(), 0, strlen(lpFileName)+1);
+        if (!nameA) return INVALID_HANDLE_VALUE;
+        strcpy(nameA, lpFileName);
+        c = nameA + strlen(lpFileName) - 1;
+        if (c[0] == '\\') c[0] = '\0';
+        nameW = FILE_name_AtoW( nameA, FALSE );
+        HeapFree(GetProcessHeap(), 0, nameA);
+        if (!nameW) return INVALID_HANDLE_VALUE;
+    }
+    else if (!(nameW = FILE_name_AtoW( lpFileName, FALSE ))) return INVALID_HANDLE_VALUE;
 
     handle = FindFirstFileExW(nameW, fInfoLevelId, &dataW, fSearchOp, lpSearchFilter, dwAdditionalFlags);
     if (handle == INVALID_HANDLE_VALUE) return handle;
diff -uHNrp wine-20071130/dlls/kernel32/heap.c wine-20071130e/dlls/kernel32/heap.c
--- wine-20071130/dlls/kernel32/heap.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/kernel32/heap.c	2008-02-04 18:31:20.000000000 +0300
@@ -445,6 +445,7 @@ LPVOID WINAPI GlobalLock(HGLOBAL hmem)
         else
         {
             WARN("invalid handle %p (Magic: 0x%04x)\n", hmem, pintern->Magic);
+            FIXME("invalid handle %p (Magic: 0x%04x)\n", hmem, pintern->Magic);
             palloc = NULL;
             SetLastError(ERROR_INVALID_HANDLE);
         }
@@ -452,6 +453,7 @@ LPVOID WINAPI GlobalLock(HGLOBAL hmem)
     __EXCEPT_PAGE_FAULT
     {
         WARN("(%p): Page fault occurred ! Caused by bug ?\n", hmem);
+        FIXME("(%p): Page fault occurred ! Caused by bug ?\n", hmem);
         palloc = NULL;
         SetLastError(ERROR_INVALID_HANDLE);
     }
diff -uHNrp wine-20071130/dlls/kernel32/instr.c wine-20071130e/dlls/kernel32/instr.c
--- wine-20071130/dlls/kernel32/instr.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/kernel32/instr.c	2008-02-04 18:31:20.000000000 +0300
@@ -441,7 +441,11 @@ DWORD __wine_emulate_instruction( EXCEPT
     long_op = long_addr = (!ISV86(context) && IS_SELECTOR_32BIT(context->SegCs));
     instr = make_ptr( context, context->SegCs, context->Eip, TRUE );
     if (!instr) return ExceptionContinueSearch;
-
+    /* Try to catch logic error */
+    if (IsBadReadPtr(instr, 1)) {
+        ERR("instr=%p context=%p CS=%04lX IP=%04lX\n", instr, context, context->SegCs, context->Eip);
+        return ExceptionContinueSearch;
+    }
     /* First handle any possible prefix */
 
     segprefix = -1;  /* no prefix */
diff -uHNrp wine-20071130/dlls/kernel32/kernel_main.c wine-20071130e/dlls/kernel32/kernel_main.c
--- wine-20071130/dlls/kernel32/kernel_main.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/kernel32/kernel_main.c	2008-02-04 18:31:20.000000000 +0300
@@ -155,6 +155,13 @@ static BOOL process_attach( HMODULE modu
     {
         /* Securom checks for this one when version is NT */
         set_entry_point( module, "FT_Thunk", 0 );
+#ifdef __i386__
+        /* Bit of a CodeWeavers Hack, winehq made it so that win2k mode
+         * no longer did this. We need it for native dcom95. So until our
+         * ole implementation works right we need the shared heap*/
+        /* create the shared heap for broken win95 native dlls */
+        HeapCreate( HEAP_SHARED, 0, 0 );
+#endif
     }
 #ifdef __i386__
     else
diff -uHNrp wine-20071130/dlls/kernel32/locale.c wine-20071130e/dlls/kernel32/locale.c
--- wine-20071130/dlls/kernel32/locale.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/kernel32/locale.c	2008-02-04 18:31:20.000000000 +0300
@@ -51,6 +51,8 @@
 #include "kernel_private.h"
 #include "wine/debug.h"
 
+#include "wine/etersoft.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(nls);
 
 #define LOCALE_LOCALEINFOFLAGSMASK (LOCALE_NOUSEROVERRIDE|LOCALE_USE_CP_ACP|LOCALE_RETURN_NUMBER)
@@ -2710,6 +2712,14 @@ INT WINAPI CompareStringA(LCID lcid, DWO
     if (len1 < 0) len1 = strlen(str1);
     if (len2 < 0) len2 = strlen(str2);
 
+    LOADETER_FUNC(etersoft_force_compare_string);
+    if (etersoft_force_compare_string)
+    {
+        int res = etersoft_force_compare_string(lcid, style, str1, len1, str2, len2);
+        if( res != CSTR_NONFORCE )
+            return res; 
+    }
+    
     if (!(style & LOCALE_USE_CP_ACP)) locale_cp = get_lcid_codepage( lcid );
 
     len1W = MultiByteToWideChar(locale_cp, 0, str1, len1, buf1W, 130);
diff -uHNrp wine-20071130/dlls/kernel32/module.c wine-20071130e/dlls/kernel32/module.c
--- wine-20071130/dlls/kernel32/module.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/kernel32/module.c	2008-02-04 18:31:20.000000000 +0300
@@ -1030,7 +1030,11 @@ FARPROC WINAPI GetProcAddress( HMODULE h
     if (HIWORD(function))
     {
         ANSI_STRING     str;
-
+        /* On Win9X we have no VerSetConditionMask in kernel32 */
+        if ((GetVersion() & 0x80000000) && !lstrcmpiA(function, "VerSetConditionMask")) {
+            SetLastError( 2 );
+            return NULL;
+        }
         RtlInitAnsiString( &str, function );
         nts = LdrGetProcedureAddress( hModule, &str, 0, (void**)&fp );
     }
diff -uHNrp wine-20071130/dlls/kernel32/process.c wine-20071130e/dlls/kernel32/process.c
--- wine-20071130/dlls/kernel32/process.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/kernel32/process.c	2008-02-04 18:31:20.000000000 +0300
@@ -56,6 +56,8 @@
 #include <valgrind/memcheck.h>
 #endif
 
+#include "wine/etersoft.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(process);
 WINE_DECLARE_DEBUG_CHANNEL(file);
 WINE_DECLARE_DEBUG_CHANNEL(relay);
@@ -93,6 +95,10 @@ static const WCHAR cmdW[] = {'.','c','m'
 static const WCHAR pifW[] = {'.','p','i','f',0};
 static const WCHAR winevdmW[] = {'w','i','n','e','v','d','m','.','e','x','e',0};
 
+/*strings for disabling ddraw in java*/
+static const WCHAR javawstr[] = {'j','a','v','a','w','.','e','x','e',0};
+static const WCHAR ext_cmd_line[] = {' ','-','D','s','u','n','.', 'j','a','v','a','2','d','.','n','o','d','d','r','a','w',0};
+
 static void exec_process( LPCWSTR name );
 
 extern void SHELL_LoadRegistry(void);
@@ -865,6 +871,13 @@ static void set_process_name( int argc, 
     if ((p = strrchr( prctl_name, '\\' ))) prctl_name = p + 1;
     if ((p = strrchr( prctl_name, '/' ))) prctl_name = p + 1;
 
+    /* Set program path for libwine-etersoft needs */
+    LOADETER_FUNC(etersoft_init);
+    LOADETER_FUNC(etersoft_version);
+    if (etersoft_init) {
+        etersoft_init(sizeof(DWORD), FILE_READ_DATA|FILE_WRITE_DATA|FILE_EXECUTE, (char*)&etersoft_version);
+        etersoft_init(2*sizeof(DWORD), FILE_READ_DATA|FILE_WRITE_DATA|FILE_EXECUTE, prctl_name);
+    }
     if (prctl( PR_SET_NAME, prctl_name ) != -1)
     {
         offset = argv[1] - argv[0];
@@ -1619,6 +1632,21 @@ BOOL WINAPI CreateProcessW( LPCWSTR app_
 
     /* Process the AppName and/or CmdLine to get module name and path */
 
+    /*If running javaw.exe then ddraw signed off*/
+    WCHAR* pos;
+    if (cmd_line && (pos=strstrW(cmd_line,javawstr)))
+    {
+	WCHAR* new_cmd_line;
+	FIXME("Running javaw.exe. Ddraw signed off\n");
+	new_cmd_line = malloc((strlenW(cmd_line)+strlenW(ext_cmd_line))*sizeof(WCHAR));
+	strcpyW(new_cmd_line, cmd_line);
+	while (*pos && *pos!=' ')
+		pos++;
+	strcpyW(new_cmd_line+(pos-cmd_line), ext_cmd_line);
+	strcatW(new_cmd_line, pos);
+	cmd_line = new_cmd_line;
+    }
+
     TRACE("app %s cmdline %s\n", debugstr_w(app_name), debugstr_w(cmd_line) );
 
     if (!(tidy_cmdline = get_file_name( app_name, cmd_line, name, sizeof(name)/sizeof(WCHAR), &hFile )))
@@ -2679,7 +2707,7 @@ BOOL WINAPI SetProcessWorkingSetSize(HAN
 BOOL WINAPI GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T minset,
                                      PSIZE_T maxset)
 {
-    FIXME("(%p,%p,%p): stub\n",hProcess,minset,maxset);
+    TRACE("(%p,%p,%p): stub\n",hProcess,minset,maxset);
     /* 32 MB working set size */
     if (minset) *minset = 32*1024*1024;
     if (maxset) *maxset = 32*1024*1024;
@@ -2830,7 +2858,7 @@ DWORD WINAPI RegisterServiceProcess(DWOR
  */
 BOOL WINAPI IsWow64Process(HANDLE hProcess, PBOOL Wow64Process)
 {
-    FIXME("(%p %p) stub!\n", hProcess, Wow64Process);
+    TRACE("(%p %p) stub!\n", hProcess, Wow64Process);
     *Wow64Process = FALSE;
     return TRUE;
 }
diff -uHNrp wine-20071130/dlls/kernel32/sync.c wine-20071130e/dlls/kernel32/sync.c
--- wine-20071130/dlls/kernel32/sync.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/kernel32/sync.c	2008-02-04 18:31:20.000000000 +0300
@@ -1914,7 +1914,7 @@ BOOL WINAPI BindIoCompletionCallback( HA
 {
     FIXME("%p, %p, %d, stub!\n", FileHandle, Function, Flags);
     SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return FALSE;
+    return TRUE;
 }
 
 /******************************************************************************
diff -uHNrp wine-20071130/dlls/kernel32/tests/locale.c wine-20071130e/dlls/kernel32/tests/locale.c
--- wine-20071130/dlls/kernel32/tests/locale.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/kernel32/tests/locale.c	2008-02-04 18:31:20.000000000 +0300
@@ -35,6 +35,8 @@
 #include "winerror.h"
 #include "winnls.h"
 
+#include "tables_CP.h"
+
 static inline unsigned int strlenW( const WCHAR *str )
 {
     const WCHAR *s = str;
@@ -1462,6 +1464,42 @@ static void test_sorting(void)
     }
 }
 
+static int compare_string2_non_latin(const void *e1, const void *e2)
+{
+    const char *s1 = (char *)e1;
+    const char *s2 = (char *)e2;
+
+   return CompareStringA(GetThreadLocale(),0,s1,1, s2,1) - 2;
+}
+
+static void test_sorting_non_latin(void)
+{
+    const int cSize = 223;
+    int j=0;
+    unsigned char mas[cSize];
+    int i=0;
+    
+    while(Locales[j].pcTable)
+    {
+        if(SetThreadLocale(MAKELCID(MAKELANGID(Locales[j].pcLocalID,SUBLANG_NEUTRAL),SORT_DEFAULT)))
+        {
+            for(i=0;i<cSize;i++)
+            {
+                mas[i] = i+33;
+            }
+            qsort(mas,cSize,sizeof(mas[0]),compare_string2_non_latin);
+
+            for(i=0;i<cSize;i++)
+            { 
+                ok(mas[i] == Locales[j].pcTable[i],"LocaleID:%x Expected: [%d]= \"%c\" (0x%x),Got\" %c\"(0x%x).\n",Locales[j].pcLocalID,i,Locales[j].pcTable[i],Locales[j].pcTable[i],mas[i],mas[i]);
+            }
+        }
+        else
+            trace("Can not set locale: %x\n",Locales[j].pcLocalID);
+        j++;
+    }
+}
+
 static void test_FoldStringA(void)
 {
   int ret, i;
@@ -2308,4 +2346,5 @@ START_TEST(locale)
   test_GetCPInfo();
   /* this requires collation table patch to make it MS compatible */
   if (0) test_sorting();
+  /*if (0)*/ test_sorting_non_latin();
 }
diff -uHNrp wine-20071130/dlls/kernel32/tests/tables_CP.h wine-20071130e/dlls/kernel32/tests/tables_CP.h
--- wine-20071130/dlls/kernel32/tests/tables_CP.h	1970-01-01 03:00:00.000000000 +0300
+++ wine-20071130e/dlls/kernel32/tests/tables_CP.h	2008-02-04 18:31:20.000000000 +0300
@@ -0,0 +1,313 @@
+/* If you want to get the source code of the program generating a file,
+ * please write to me on vostok@etersoft.ru.
+ * Automatically generated file; DO NOT EDIT!!
+ */
+
+
+/* The symbols sorted with qsort!  */
+static const unsigned char Table_BEL[223] =
+   {
+      0x7f, 0x98, 0x27, 0x2d, 0xad, 0x96, 0x97, 0xa0, 0x21, 0x22, 0x23,
+      0x24, 0x25, 0x26, 0x28, 0x29, 0x2a, 0x2c, 0x2e, 0x2f, 0x3a, 0x3b,
+      0x3f, 0x40, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x7b, 0x7c, 0x7d,
+      0x7e, 0xa6, 0x91, 0x92, 0x82, 0x93, 0x94, 0x84, 0x8b, 0x9b, 0x2b,
+      0x3c, 0x3d, 0x3e, 0xb1, 0xab, 0xbb, 0xa4, 0xa7, 0xa9, 0xac, 0xae,
+      0xb0, 0xb5, 0xb6, 0xb7, 0x86, 0x87, 0x95, 0x85, 0x89, 0x88, 0x30,
+      0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x61, 0x41,
+      0x62, 0x42, 0x63, 0x43, 0x64, 0x44, 0x65, 0x45, 0x66, 0x46, 0x67,
+      0x47, 0x68, 0x48, 0x69, 0x49, 0x6a, 0x4a, 0x6b, 0x4b, 0x6c, 0x4c,
+      0x6d, 0x4d, 0x6e, 0x4e, 0xb9, 0x6f, 0x4f, 0x70, 0x50, 0x71, 0x51,
+      0x72, 0x52, 0x73, 0x53, 0x74, 0x54, 0x99, 0x75, 0x55, 0x76, 0x56,
+      0x77, 0x57, 0x78, 0x58, 0x79, 0x59, 0x7a, 0x5a, 0xe0, 0xc0, 0xe1,
+      0xc1, 0xe2, 0xc2, 0xe3, 0xc3, 0xb4, 0xa5, 0x83, 0x81, 0xe4, 0xc4,
+      0x90, 0x80, 0xe5, 0xc5, 0xb8, 0xa8, 0xba, 0xaa, 0xe6, 0xc6, 0xe7,
+      0xc7, 0xbe, 0xbd, 0xe8, 0xc8, 0xb3, 0xb2, 0xbf, 0xaf, 0xe9, 0xc9,
+      0xbc, 0xa3, 0xea, 0xca, 0x9d, 0x8d, 0xeb, 0xcb, 0x9a, 0x8a, 0xec,
+      0xcc, 0xed, 0xcd, 0x9c, 0x8c, 0xee, 0xce, 0xef, 0xcf, 0xf0, 0xd0,
+      0xf1, 0xd1, 0xf2, 0xd2, 0x9e, 0x8e, 0xf3, 0xd3, 0xa2, 0xa1, 0xf4,
+      0xd4, 0xf5, 0xd5, 0xf6, 0xd6, 0xf7, 0xd7, 0x9f, 0x8f, 0xf8, 0xd8,
+      0xf9, 0xd9, 0xfa, 0xda, 0xfb, 0xdb, 0xfc, 0xdc, 0xfd, 0xdd, 0xfe,
+      0xde, 0xff, 0xdf
+   };
+
+
+/* The symbols sorted with qsort!  */
+static const unsigned char Table_EST[223] =
+   {
+      0x7f, 0x81, 0x83, 0x88, 0x8a, 0x8c, 0x90, 0x98, 0x9a, 0x9c, 0x9f,
+      0x27, 0x2d, 0xad, 0x96, 0x97, 0xa0, 0x21, 0x22, 0x23, 0x24, 0x25,
+      0x26, 0x28, 0x29, 0x2a, 0x2c, 0x2e, 0x2f, 0x3a, 0x3b, 0x3f, 0x40,
+      0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x7b, 0x7c, 0x7d, 0x7e, 0xa6,
+      0x8d, 0x9d, 0xb4, 0x8f, 0x8e, 0xff, 0x9e, 0x91, 0x92, 0x82, 0x93,
+      0x94, 0x84, 0x8b, 0x9b, 0x2b, 0x3c, 0x3d, 0x3e, 0xb1, 0xab, 0xbb,
+      0xd7, 0xf7, 0xa2, 0xa3, 0xa4, 0xa7, 0xa9, 0xac, 0xae, 0xb0, 0xb5,
+      0xb6, 0xb7, 0x86, 0x87, 0x95, 0x85, 0x89, 0x80, 0x30, 0xbc, 0xbd,
+      0xbe, 0x31, 0xb9, 0x32, 0xb2, 0x33, 0xb3, 0x34, 0x35, 0x36, 0x37,
+      0x38, 0x39, 0x61, 0x41, 0xe2, 0xc2, 0xe5, 0xc5, 0xe0, 0xc0, 0xbf,
+      0xaf, 0x62, 0x42, 0x63, 0x43, 0xe3, 0xc3, 0xe8, 0xc8, 0x64, 0x44,
+      0x65, 0x45, 0xe9, 0xc9, 0xeb, 0xcb, 0xe7, 0xc7, 0xe6, 0xc6, 0x66,
+      0x46, 0x67, 0x47, 0xec, 0xcc, 0x68, 0x48, 0x69, 0x49, 0xee, 0xce,
+      0xe1, 0xc1, 0x6a, 0x4a, 0x6b, 0x4b, 0xed, 0xcd, 0x6c, 0x4c, 0xef,
+      0xcf, 0xf9, 0xd9, 0x6d, 0x4d, 0x6e, 0x4e, 0xf1, 0xd1, 0xf2, 0xd2,
+      0x6f, 0x4f, 0xf3, 0xd3, 0xf4, 0xd4, 0xb8, 0xa8, 0x70, 0x50, 0x71,
+      0x51, 0x72, 0x52, 0xba, 0xaa, 0x73, 0x53, 0xfa, 0xda, 0xdf, 0xf0,
+      0xd0, 0x7a, 0x5a, 0xea, 0xca, 0xfd, 0xdd, 0xfe, 0xde, 0x74, 0x54,
+      0x99, 0x75, 0x55, 0xfb, 0xdb, 0xf8, 0xd8, 0x76, 0x56, 0x77, 0x57,
+      0xf5, 0xd5, 0xe4, 0xc4, 0xf6, 0xd6, 0xfc, 0xdc, 0x78, 0x58, 0x79,
+      0x59, 0xa1, 0xa5
+   };
+
+
+/* The symbols sorted with qsort!  */
+static const unsigned char Table_LAT[223] =
+   {
+      0x7f, 0x81, 0x83, 0x88, 0x8a, 0x8c, 0x90, 0x98, 0x9a, 0x9c, 0x9f,
+      0x27, 0x2d, 0xad, 0x96, 0x97, 0xa0, 0x21, 0x22, 0x23, 0x24, 0x25,
+      0x26, 0x28, 0x29, 0x2a, 0x2c, 0x2e, 0x2f, 0x3a, 0x3b, 0x3f, 0x40,
+      0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x7b, 0x7c, 0x7d, 0x7e, 0xa6,
+      0x8d, 0x9d, 0xb4, 0x8f, 0x8e, 0xff, 0x9e, 0x91, 0x92, 0x82, 0x93,
+      0x94, 0x84, 0x8b, 0x9b, 0x2b, 0x3c, 0x3d, 0x3e, 0xb1, 0xab, 0xbb,
+      0xd7, 0xf7, 0xa2, 0xa3, 0xa4, 0xa7, 0xa9, 0xac, 0xae, 0xb0, 0xb5,
+      0xb6, 0xb7, 0x86, 0x87, 0x95, 0x85, 0x89, 0x80, 0x30, 0xbc, 0xbd,
+      0xbe, 0x31, 0xb9, 0x32, 0xb2, 0x33, 0xb3, 0x34, 0x35, 0x36, 0x37,
+      0x38, 0x39, 0x61, 0x41, 0xe4, 0xc4, 0xe2, 0xc2, 0xe5, 0xc5, 0xe0,
+      0xc0, 0xbf, 0xaf, 0x62, 0x42, 0x63, 0x43, 0xe3, 0xc3, 0xe8, 0xc8,
+      0x64, 0x44, 0x65, 0x45, 0xe9, 0xc9, 0xeb, 0xcb, 0xe7, 0xc7, 0xe6,
+      0xc6, 0x66, 0x46, 0x67, 0x47, 0xec, 0xcc, 0x68, 0x48, 0x69, 0x49,
+      0xee, 0xce, 0xe1, 0xc1, 0x6a, 0x4a, 0x6b, 0x4b, 0xed, 0xcd, 0x6c,
+      0x4c, 0xf9, 0xd9, 0xef, 0xcf, 0x6d, 0x4d, 0x6e, 0x4e, 0xf1, 0xd1,
+      0xf2, 0xd2, 0x6f, 0x4f, 0xf3, 0xd3, 0xf6, 0xd6, 0xf4, 0xd4, 0xf5,
+      0xd5, 0xb8, 0xa8, 0x70, 0x50, 0x71, 0x51, 0x72, 0x52, 0xba, 0xaa,
+      0x73, 0x53, 0xfa, 0xda, 0xdf, 0xf0, 0xd0, 0x74, 0x54, 0x99, 0x75,
+      0x55, 0xfc, 0xdc, 0xfb, 0xdb, 0xf8, 0xd8, 0x76, 0x56, 0x77, 0x57,
+      0x78, 0x58, 0x79, 0x59, 0x7a, 0x5a, 0xea, 0xca, 0xfd, 0xdd, 0xfe,
+      0xde, 0xa1, 0xa5
+   };
+
+
+/* The symbols sorted with qsort!  */
+static const unsigned char Table_RUS[223] =
+   {
+      0x7f, 0x98, 0x27, 0x2d, 0xad, 0x96, 0x97, 0xa0, 0x21, 0x22, 0x23,
+      0x24, 0x25, 0x26, 0x28, 0x29, 0x2a, 0x2c, 0x2e, 0x2f, 0x3a, 0x3b,
+      0x3f, 0x40, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x7b, 0x7c, 0x7d,
+      0x7e, 0xa6, 0x91, 0x92, 0x82, 0x93, 0x94, 0x84, 0x8b, 0x9b, 0x2b,
+      0x3c, 0x3d, 0x3e, 0xb1, 0xab, 0xbb, 0xa4, 0xa7, 0xa9, 0xac, 0xae,
+      0xb0, 0xb5, 0xb6, 0xb7, 0x86, 0x87, 0x95, 0x85, 0x89, 0x88, 0x30,
+      0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x61, 0x41,
+      0x62, 0x42, 0x63, 0x43, 0x64, 0x44, 0x65, 0x45, 0x66, 0x46, 0x67,
+      0x47, 0x68, 0x48, 0x69, 0x49, 0x6a, 0x4a, 0x6b, 0x4b, 0x6c, 0x4c,
+      0x6d, 0x4d, 0x6e, 0x4e, 0xb9, 0x6f, 0x4f, 0x70, 0x50, 0x71, 0x51,
+      0x72, 0x52, 0x73, 0x53, 0x74, 0x54, 0x99, 0x75, 0x55, 0x76, 0x56,
+      0x77, 0x57, 0x78, 0x58, 0x79, 0x59, 0x7a, 0x5a, 0xe0, 0xc0, 0xe1,
+      0xc1, 0xe2, 0xc2, 0xe3, 0xc3, 0xb4, 0xa5, 0x83, 0x81, 0xe4, 0xc4,
+      0x90, 0x80, 0xe5, 0xc5, 0xb8, 0xa8, 0xba, 0xaa, 0xe6, 0xc6, 0xe7,
+      0xc7, 0xbe, 0xbd, 0xe8, 0xc8, 0xb3, 0xb2, 0xbf, 0xaf, 0xe9, 0xc9,
+      0xbc, 0xa3, 0xea, 0xca, 0x9d, 0x8d, 0xeb, 0xcb, 0x9a, 0x8a, 0xec,
+      0xcc, 0xed, 0xcd, 0x9c, 0x8c, 0xee, 0xce, 0xef, 0xcf, 0xf0, 0xd0,
+      0xf1, 0xd1, 0xf2, 0xd2, 0x9e, 0x8e, 0xf3, 0xd3, 0xa2, 0xa1, 0xf4,
+      0xd4, 0xf5, 0xd5, 0xf6, 0xd6, 0xf7, 0xd7, 0x9f, 0x8f, 0xf8, 0xd8,
+      0xf9, 0xd9, 0xfa, 0xda, 0xfb, 0xdb, 0xfc, 0xdc, 0xfd, 0xdd, 0xfe,
+      0xde, 0xff, 0xdf
+   };
+
+
+/* The symbols sorted with qsort!  */
+static const unsigned char Table_UKR[223] =
+   {
+      0x7f, 0x98, 0x27, 0x2d, 0xad, 0x96, 0x97, 0xa0, 0x21, 0x22, 0x23,
+      0x24, 0x25, 0x26, 0x28, 0x29, 0x2a, 0x2c, 0x2e, 0x2f, 0x3a, 0x3b,
+      0x3f, 0x40, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x7b, 0x7c, 0x7d,
+      0x7e, 0xa6, 0x91, 0x92, 0x82, 0x93, 0x94, 0x84, 0x8b, 0x9b, 0x2b,
+      0x3c, 0x3d, 0x3e, 0xb1, 0xab, 0xbb, 0xa4, 0xa7, 0xa9, 0xac, 0xae,
+      0xb0, 0xb5, 0xb6, 0xb7, 0x86, 0x87, 0x95, 0x85, 0x89, 0x88, 0x30,
+      0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x61, 0x41,
+      0x62, 0x42, 0x63, 0x43, 0x64, 0x44, 0x65, 0x45, 0x66, 0x46, 0x67,
+      0x47, 0x68, 0x48, 0x69, 0x49, 0x6a, 0x4a, 0x6b, 0x4b, 0x6c, 0x4c,
+      0x6d, 0x4d, 0x6e, 0x4e, 0xb9, 0x6f, 0x4f, 0x70, 0x50, 0x71, 0x51,
+      0x72, 0x52, 0x73, 0x53, 0x74, 0x54, 0x99, 0x75, 0x55, 0x76, 0x56,
+      0x77, 0x57, 0x78, 0x58, 0x79, 0x59, 0x7a, 0x5a, 0xe0, 0xc0, 0xe1,
+      0xc1, 0xe2, 0xc2, 0xe3, 0xc3, 0xb4, 0xa5, 0x83, 0x81, 0xe4, 0xc4,
+      0x90, 0x80, 0xe5, 0xc5, 0xb8, 0xa8, 0xba, 0xaa, 0xe6, 0xc6, 0xe7,
+      0xc7, 0xbe, 0xbd, 0xe8, 0xc8, 0xb3, 0xb2, 0xbf, 0xaf, 0xe9, 0xc9,
+      0xbc, 0xa3, 0xea, 0xca, 0x9d, 0x8d, 0xeb, 0xcb, 0x9a, 0x8a, 0xec,
+      0xcc, 0xed, 0xcd, 0x9c, 0x8c, 0xee, 0xce, 0xef, 0xcf, 0xf0, 0xd0,
+      0xf1, 0xd1, 0xf2, 0xd2, 0x9e, 0x8e, 0xf3, 0xd3, 0xa2, 0xa1, 0xf4,
+      0xd4, 0xf5, 0xd5, 0xf6, 0xd6, 0xf7, 0xd7, 0x9f, 0x8f, 0xf8, 0xd8,
+      0xf9, 0xd9, 0xfa, 0xda, 0xfb, 0xdb, 0xfd, 0xdd, 0xfe, 0xde, 0xff,
+      0xdf, 0xfc, 0xdc
+   };
+
+/* Array locales */
+
+const struct GenLocalMas
+{
+   const WORD pcLocalID;
+   const unsigned char *pcTable;
+}
+
+Locales[] = {
+
+               {LANG_BELARUSIAN, Table_BEL},
+               {LANG_ESTONIAN, Table_EST},
+               {LANG_LATVIAN, Table_LAT},
+               {LANG_RUSSIAN, Table_RUS},
+               {LANG_UKRAINIAN, Table_UKR},
+               {0, 0}
+            };
+
+#if 0
+The generating program.
+ 
+#include <stdio.h>
+#include <windows.h>
+#include <locale.h>
+#include <winnt.h>
+ 
+#define  MAXLENCOUNT 10
+#define  nSize 256
+ 
+static int compare_string1(const void *e1,const void *e2)
+{
+    char *s1 = (char *)e1;
+    char *s2 = (char *)e2;
+ 
+    return CompareStringA(GetThreadLocale(),0,s1,1, s2,1) - 2;
+}
+      
+void FormMasChar(FILE *fp,char *ID);
+void FormMasLocale(FILE *fp);
+       
+const WORD locales[] =
+{
+    LANG_BELARUSIAN,
+    LANG_ESTONIAN,
+    LANG_LATVIAN,
+    LANG_RUSSIAN,
+    LANG_UKRAINIAN,
+};
+       
+const char *Names_locales[] =
+{
+    "LANG_BELARUSIAN",
+    "LANG_ESTONIAN",
+    "LANG_LATVIAN",
+    "LANG_RUSSIAN",
+    "LANG_UKRAINIAN"
+};
+              
+int main()
+{
+    FILE *fp;
+    char buf[50];
+    int i=0;
+    char ID[4];
+    int j=0;
+    const char *Filename = "tables_CP.h";
+            
+    if( (fp =fopen(Filename,"w")) != NULL)
+    {
+	fputs("/* If you want to get the source code of the program generating a file,\n",fp);
+        fputs(" * please write to me on vostok@etersoft.ru.\n",fp);
+        fputs(" * Automatically generated file; DO NOT EDIT!!\n",fp);
+        fprintf(fp," *%s\n",'/');
+	fputs("\n",fp);
+
+	for(i=0;i<sizeof(locales)/sizeof(WORD);i++)
+	{
+	    if( SetThreadLocale(MAKELCID(MAKELANGID(locales[i],SUBLANG_NEUTRAL),SORT_DEFAULT)) )
+	    {
+		printf("Set locale:%x\n",GetThreadLocale());
+		for(j=5;j<8;j++)
+		    ID[j-5] = Names_locales[i][j];
+		ID[3] = '\0';
+		FormMasChar(fp,ID);
+	    }	
+	    else
+		fputs("Can not change locale\n",fp);
+	}
+
+	FormMasLocale(fp);
+
+	fclose(fp);
+    }
+    else
+	printf("Can not create file!\n");
+    return 0;
+}
+
+void FormMasLocale(FILE *fp)
+{
+    int i=0;
+    char ID[4];
+    int  j;
+
+    fprintf(fp,"/* Array locales *%s\n",'/');
+
+    fputs("const struct GenLocalMas\n",fp);
+    fputs("{ \n",fp);
+    fputs("    const WORD pcLocalID;\n",fp);
+    fputs("    const unsigned char *pcTable;\n",fp);
+    fputs("} Locales[] = {\n",fp);
+    fputs("\n",fp);
+
+    for(i=0;i<sizeof(locales)/sizeof(WORD);i++)
+    {
+	 for(j=5;j<8;j++)
+	    ID[j-5] = Names_locales[i][j];
+    	 ID[3] = '\0';
+         fprintf(fp,"    {%s, Table_%s},\n",Names_locales[i],ID);
+     }
+     fputs("    {0, 0}\n",fp);
+     fputs("};\n",fp);
+
+
+}
+
+void FormMasChar(FILE *fp,char *ID)
+{
+    int i;
+    unsigned char ch;
+    char buf[50];
+    int j;
+    unsigned char mas[nSize-33];
+
+    fputs("\n",fp);
+
+    fprintf(fp,"/* The symbols sorted with qsort!  *%s\n",'/');
+    fprintf(fp,"static const unsigned char Table_%s[%d] = \n",ID,nSize-33);
+    fputs("{\n",fp);
+
+    for(i=33;i<nSize;i++)
+    {
+	sprintf(buf,"%c",i);
+	mas[i-33] = buf[0];
+    }
+
+    j=0;
+
+    qsort(mas,sizeof(mas)/sizeof(mas[0]),sizeof(mas[0]),compare_string1);
+
+    for(i=33;i<nSize;i++)
+    {
+	ch = mas[i-33];
+        if(i != nSize-1)
+    	    fprintf(fp,"0x%x, ",ch);
+	else
+    	    fprintf(fp,"0x%x ",ch);
+
+	if(j == MAXLENCOUNT)
+        {
+    	    j=0;
+	    fputs("\n",fp);
+	}
+        else
+        {
+    	     j++;
+	}
+    }
+
+    fputs("};\n",fp);
+    fputs("\n",fp);
+}
+#endif
diff -uHNrp wine-20071130/dlls/kernel32/vxd.c wine-20071130e/dlls/kernel32/vxd.c
--- wine-20071130/dlls/kernel32/vxd.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/kernel32/vxd.c	2008-02-04 18:31:20.000000000 +0300
@@ -207,7 +207,7 @@ HANDLE VXD_Open( LPCWSTR filenameW, DWOR
 
     if (!(module = LoadLibraryW( name )))
     {
-        FIXME( "Unknown/unsupported VxD %s. Try setting Windows version to 'nt40' or 'win31'.\n",
+        TRACE( "Unknown/unsupported VxD %s. Try setting Windows version to 'nt40' or 'win31'.\n",
                debugstr_w(name) );
         SetLastError( ERROR_FILE_NOT_FOUND );
         return 0;
diff -uHNrp wine-20071130/dlls/midimap/midimap.c wine-20071130e/dlls/midimap/midimap.c
--- wine-20071130/dlls/midimap/midimap.c	2007-12-01 21:14:16.000000000 +0300
+++ wine-20071130e/dlls/midimap/midimap.c	2008-02-04 18:31:20.000000000 +0300
@@ -168,7 +168,7 @@ static BOOL	MIDIMAP_LoadSettingsScheme(M
 	return FALSE;
     }
 
-    for (idx = 0; !RegEnumKeyW(hKey, idx, buffer, sizeof(buffer)); idx++)
+    for (idx = 0; !RegEnumKeyW(hKey, idx, buffer, sizeof(buffer)/sizeof(buffer[0])); idx++)
     {
 	if (RegOpenKeyW(hKey, buffer, &hPortKey)) continue;
 
diff -uHNrp wine-20071130/dlls/mshtml/install.c wine-20071130e/dlls/mshtml/install.c
--- wine-20071130/dlls/mshtml/install.c	2007-12-01 21:14:18.000000000 +0300
+++ wine-20071130e/dlls/mshtml/install.c	2008-02-04 18:31:20.000000000 +0300
@@ -219,22 +219,47 @@ static BOOL install_from_unix_file(const
 
 static BOOL install_from_registered_dir(void)
 {
-    char *file_name;
+    /* WCHAR hardcoded_path[]={'C',':','\\','W','I','N','D','O','W','S','\\','D','o','w','n','l','o','a','d','s','\\','\0'};
+    */
+    char hardcoded_path[]="C:\\WINDOWS\\DOWNLOADS\\";
+    LPWSTR gecko_path;
+    char *file_name, dos_file_name[MAX_PATH];
     HKEY hkey;
     DWORD res, type, size = MAX_PATH;
     BOOL ret;
 
+    TRACE("\n");
     /* @@ Wine registry key: HKCU\Software\Wine\MSHTML */
     res = RegOpenKeyW(HKEY_CURRENT_USER, mshtml_keyW, &hkey);
-    if(res != ERROR_SUCCESS)
-        return FALSE;
+    if(res == ERROR_SUCCESS) {
+        /* Trying to get dos dir for Gecko */
+        res = RegQueryValueExA(hkey, "GeckoCabDosDir", NULL, &type, (PBYTE)dos_file_name, &size);
+    }
+    if(!(res == ERROR_SUCCESS && type == REG_SZ)) {
+        TRACE("Hack for initial register Gecko: load from hardcoded path\n");
+        strcpy(dos_file_name,hardcoded_path);
+    }
+    strcat(dos_file_name, GECKO_FILE_NAME);
+    
+    size = MultiByteToWideChar(CP_ACP, 0, dos_file_name, -1, NULL, 0)-1;
+    gecko_path = mshtml_alloc(size*sizeof(WCHAR));
+    MultiByteToWideChar(CP_ACP, 0, dos_file_name, -1, gecko_path, size*sizeof(WCHAR));
+    TRACE("Trying %s\n", debugstr_w(gecko_path));
+    ret = install_cab(gecko_path);
+    mshtml_free(gecko_path);
+    if(ret)
+            return ret;
+    
+    size = MAX_PATH;
 
+    /* Trying to get unix dir for Gecko */
     file_name = mshtml_alloc(size+sizeof(GECKO_FILE_NAME));
     res = RegQueryValueExA(hkey, "GeckoCabDir", NULL, &type, (PBYTE)file_name, &size);
     if(res == ERROR_MORE_DATA) {
         file_name = mshtml_realloc(file_name, size+sizeof(GECKO_FILE_NAME));
         res = RegQueryValueExA(hkey, "GeckoCabDir", NULL, &type, (PBYTE)file_name, &size);
     }
+
     RegCloseKey(hkey);
     if(res != ERROR_SUCCESS || type != REG_SZ)
         return FALSE;
diff -uHNrp wine-20071130/dlls/mshtml/nsembed.c wine-20071130e/dlls/mshtml/nsembed.c
--- wine-20071130/dlls/mshtml/nsembed.c	2007-12-01 21:14:18.000000000 +0300
+++ wine-20071130e/dlls/mshtml/nsembed.c	2008-02-04 18:31:20.000000000 +0300
@@ -789,8 +789,9 @@ void set_ns_editmode(NSContainer *This)
 
 void close_gecko(void)
 {
-    TRACE("()\n");
+    TRACE("All release functions is disabled\n");
 
+/*
     if(pCompMgr)
         nsIComponentManager_Release(pCompMgr);
 
@@ -802,6 +803,7 @@ void close_gecko(void)
 
     if(hXPCOM)
         FreeLibrary(hXPCOM);
+*/
 }
 
 /**********************************************************
diff -uHNrp wine-20071130/dlls/msi/action.c wine-20071130e/dlls/msi/action.c
--- wine-20071130/dlls/msi/action.c	2007-12-01 21:14:14.000000000 +0300
+++ wine-20071130e/dlls/msi/action.c	2008-02-04 18:31:20.000000000 +0300
@@ -2068,18 +2068,21 @@ static UINT msi_check_file_install_state
         if (file->IsCompressed)
             comp->ForceLocalState = TRUE;
 
-        /* calculate target */
-        p = resolve_folder(package, comp->Directory, FALSE, FALSE, TRUE, NULL);
-
         msi_free(file->TargetPath);
+        msi_free(file->SourcePath);
 
-        TRACE("file %s is named %s\n",
-               debugstr_w(file->File), debugstr_w(file->FileName));
-
+        /* calculate target */
+        p = resolve_folder(package, comp->Directory, FALSE, FALSE, TRUE, NULL);
         file->TargetPath = build_directory_name(2, p, file->FileName);
+        msi_free(p);
 
+        /* calculate source */
+        p = resolve_folder(package, comp->Directory, TRUE, FALSE, TRUE, NULL);
+        file->SourcePath = build_directory_name(2, p, file->FileName);
         msi_free(p);
 
+        TRACE("file %s is named %s\n",
+               debugstr_w(file->File), debugstr_w(file->FileName));
         TRACE("file %s resolves to %s\n",
                debugstr_w(file->File), debugstr_w(file->TargetPath));
 
diff -uHNrp wine-20071130/dlls/msi/custom.c wine-20071130e/dlls/msi/custom.c
--- wine-20071130/dlls/msi/custom.c	2007-12-01 21:14:14.000000000 +0300
+++ wine-20071130e/dlls/msi/custom.c	2008-02-04 18:31:20.000000000 +0300
@@ -960,7 +960,7 @@ static UINT HANDLE_CustomType17(MSIPACKA
         return ERROR_FUNCTION_FAILED;
     }
 
-    info = do_msidbCustomActionTypeDll( package, type, file->TargetPath, target, action );
+    info = do_msidbCustomActionTypeDll( package, type, file->SourcePath, target, action );
 
     return wait_thread_handle( info );
 }
diff -uHNrp wine-20071130/dlls/msi/package.c wine-20071130e/dlls/msi/package.c
--- wine-20071130/dlls/msi/package.c	2007-12-01 21:14:14.000000000 +0300
+++ wine-20071130e/dlls/msi/package.c	2008-02-04 18:31:20.000000000 +0300
@@ -415,6 +415,7 @@ static VOID set_installer_properties(MSI
     static const WCHAR szVersionDatabase[] = { 'V','e','r','s','i','o','n','D','a','t','a','b','a','s','e',0 };
     static const WCHAR szPhysicalMemory[] = { 'P','h','y','s','i','c','a','l','M','e','m','o','r','y',0 };
     static const WCHAR szFormat2[] = {'%','l','i','.','%','l','i',0};
+    static const WCHAR szIE50[] = {'I','E','5','0','I','N','S','T','A','L','L','E','D',0};
 /* Screen properties */
     static const WCHAR szScreenX[] = {'S','c','r','e','e','n','X',0};
     static const WCHAR szScreenY[] = {'S','c','r','e','e','n','Y',0};
@@ -566,6 +567,10 @@ static VOID set_installer_properties(MSI
     sprintfW( bufstr, szFormat, MSI_MAJORVERSION * 100);
     MSI_SetPropertyW( package, szVersionDatabase, bufstr );
 
+    /* hack for IE50 dummy present */
+    sprintfW( bufstr, szScreenFormat, 1 );
+    MSI_SetPropertyW( package, szIE50, bufstr );
+
     GetSystemInfo( &sys_info );
     if (sys_info.u.s.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
     {
diff -uHNrp wine-20071130/dlls/ntdll/loader.c wine-20071130e/dlls/ntdll/loader.c
--- wine-20071130/dlls/ntdll/loader.c	2007-12-01 21:14:15.000000000 +0300
+++ wine-20071130e/dlls/ntdll/loader.c	2008-02-04 18:31:20.000000000 +0300
@@ -40,6 +40,7 @@
 #include "wine/unicode.h"
 #include "wine/debug.h"
 #include "wine/server.h"
+#include "wine/etersoft.h"
 #include "ntdll_misc.h"
 #include "ddk/wdm.h"
 
@@ -1405,6 +1406,11 @@ static NTSTATUS load_native_dll( LPCWSTR
         return STATUS_DLL_NOT_FOUND;
     }
 
+    LOADETER_FUNC(etersoft_protect);
+    if (etersoft_protect)
+        if (!etersoft_protect(module, debugstr_w(name)))
+            return STATUS_NO_MEMORY;
+
     /* create the MODREF */
 
     if (!(wm = alloc_module( module, name ))) return STATUS_NO_MEMORY;
@@ -2465,7 +2471,9 @@ void __wine_init_windows_dir( const WCHA
 
     RtlCreateUnicodeString( &windows_dir, windir );
     RtlCreateUnicodeString( &system_dir, sysdir );
+#if !defined(__FreeBSD__)
     strcpyW( user_shared_data->NtSystemRoot, windir );
+#endif
 
     /* prepend the system dir to the name of the already created modules */
     mark = &NtCurrentTeb()->Peb->LdrData->InLoadOrderModuleList;
diff -uHNrp wine-20071130/dlls/ntdll/Makefile.in wine-20071130e/dlls/ntdll/Makefile.in
--- wine-20071130/dlls/ntdll/Makefile.in	2007-12-01 21:14:15.000000000 +0300
+++ wine-20071130e/dlls/ntdll/Makefile.in	2008-02-04 18:31:20.000000000 +0300
@@ -51,7 +51,8 @@ C_SRCS = \
 	time.c \
 	version.c \
 	virtual.c \
-	wcstring.c
+	wcstring.c \
+	mcache.c
 
 RC_SRCS = version.rc
 
diff -uHNrp wine-20071130/dlls/ntdll/mcache.c wine-20071130e/dlls/ntdll/mcache.c
--- wine-20071130/dlls/ntdll/mcache.c	1970-01-01 03:00:00.000000000 +0300
+++ wine-20071130e/dlls/ntdll/mcache.c	2008-02-04 18:31:20.000000000 +0300
@@ -0,0 +1,338 @@
+#include <unistd.h>
+#include <stdio.h>
+#include "wine/server.h"
+#include "wine/server_protocol.h"
+
+#define CACHE_MAX_NUM 300
+
+struct CacheInfo
+{
+	void* handle;
+	struct __server_request_info reply;
+	ULONG	ms;
+	thread_id_t  tid; // use for get_thread_input_request
+};
+
+struct CacheInfo mcache_win_tree[CACHE_MAX_NUM];
+struct CacheInfo mcache_win_child[CACHE_MAX_NUM];
+struct CacheInfo mcache_get_thread[CACHE_MAX_NUM];
+
+static int win_tree_curindex = 0;
+static int win_child_curindex = 0;
+static int get_thread_curindex = 0;
+static int win_tree_empty = 1;
+static int win_child_empty = 1;
+static int get_thread_empty = 1;
+static int cache_clear = 0;
+
+static const int get_window_children_timeout_msec = 1000;
+static const int get_window_tree_timeout_msec = 200;
+static const int get_thread_input_timeout_msec = 200;
+
+static int mcache_init_ok = 0;
+
+// -----------------------------------------------------------------------------
+void mcache_init()
+{
+	if( mcache_init_ok )
+		return;
+		
+	memset(mcache_win_tree,0,sizeof(mcache_win_tree));
+	memset(mcache_win_child,0,sizeof(mcache_win_child));
+	memset(mcache_get_thread,0,sizeof(mcache_get_thread));
+	
+	mcache_init_ok = 1;
+}
+
+// -----------------------------------------------------------------------------
+static BOOL mcache_compare_win_tree( int ind,  const struct __server_request_info* req )
+{
+	struct get_window_tree_request* r = (struct get_window_tree_request*)(&req->u.req);
+	return ( mcache_win_tree[ind].handle==r->handle );
+}
+// -----------------------------------------------------------------------------
+static BOOL mcache_compare_win_child( int ind,  const struct __server_request_info* req )
+{
+	struct get_window_children_request* r = (struct get_window_children_request*)(&req->u.req);
+	return ( mcache_win_child[ind].handle==r->parent );
+}
+// -----------------------------------------------------------------------------
+static BOOL mcache_compare_get_thread( int ind,  const struct __server_request_info* req )
+{
+	struct get_thread_input_request* r = (struct get_thread_input_request*)(&req->u.req);
+	return ( mcache_get_thread[ind].tid==r->tid );
+}
+// -----------------------------------------------------------------------------
+
+static BOOL mcache_filtr( const struct __server_request_info* req )
+{
+//	return 0;
+	
+	switch( req->u.req.request_header.req )
+	{
+		case REQ_get_window_tree:
+//		case REQ_get_window_children:
+		case REQ_get_thread_input:
+		break;
+
+		//    
+		case REQ_set_window_owner:
+		case REQ_set_window_pos:
+		case REQ_set_window_region:
+		case REQ_set_window_property:
+		case REQ_set_foreground_window:
+		case REQ_set_focus_window:
+		case REQ_set_active_window:
+		case REQ_set_capture_window:
+		case REQ_set_caret_window:
+		case REQ_set_global_windows:
+			cache_clear = 1;
+		return 0;
+
+		case REQ_set_window_info:
+		{
+			struct set_window_info_request* r = (struct set_window_info_request*)(&req->u.req);
+			if( r->flags )
+				cache_clear = 1;
+		}
+		return 0;
+	
+		default:
+			return 0;
+	}
+
+	return 1;	
+}
+
+// -----------------------------------------------------------------------------
+static void mcache_clear()
+{
+	if( win_child_empty && win_tree_empty && get_thread_empty )
+		return;
+
+	memset(mcache_win_tree,0,sizeof(mcache_win_tree));
+	memset(mcache_win_child,0,sizeof(mcache_win_child));
+	memset(mcache_get_thread,0,sizeof(mcache_get_thread));
+	win_tree_curindex 	= 0;
+	win_child_curindex 	= 0;
+	get_thread_curindex = 0;
+	win_tree_empty 		= 1;
+	win_child_empty 	= 1;
+	get_thread_empty 	= 1;
+}
+// -----------------------------------------------------------------------------
+//   ''
+static BOOL mcache_check( struct CacheInfo* mcache, 
+							BOOL (*mcache_compare)( int ind,  const struct __server_request_info* req ),
+							const struct __server_request_info* req, 
+							struct __server_request_info* rep, int* curindex, int cache_timeout );
+// -----------------------------------------------------------------------------
+static BOOL mcache_get_win_tree( const struct __server_request_info* req, struct __server_request_info* rep )
+{
+	return mcache_check( mcache_win_tree,mcache_compare_win_tree,req,rep, 
+							&win_tree_curindex, get_window_tree_timeout_msec );
+}
+// -----------------------------------------------------------------------------
+static BOOL mcache_get_win_child( const struct __server_request_info* req, struct __server_request_info* rep )
+{
+	return mcache_check( mcache_win_child,mcache_compare_win_child,req,rep, 
+							&win_child_curindex, get_window_children_timeout_msec );
+}
+// -----------------------------------------------------------------------------
+static BOOL mcache_get_thread_input( const struct __server_request_info* req, struct __server_request_info* rep )
+{
+	return mcache_check( mcache_get_thread,mcache_compare_get_thread,req,rep, 
+							&get_thread_curindex,get_thread_input_timeout_msec );
+}
+// -----------------------------------------------------------------------------
+
+BOOL mcache_check_msg( const struct __server_request_info* req,
+						struct __server_request_info* rep )
+{
+	if( !mcache_filtr(req) )
+	{
+		if( cache_clear )
+		{
+			mcache_clear();
+			cache_clear = 0;
+		}
+		return 0;
+	}
+
+	switch( req->u.req.request_header.req )
+	{
+		case REQ_get_window_tree:
+			return mcache_get_win_tree(req,rep);
+
+		case REQ_get_window_children:
+			return mcache_get_win_child(req,rep);
+
+		case REQ_get_thread_input:
+			return mcache_get_thread_input(req,rep);
+
+		default:
+			break;
+	}
+
+	return 0;
+
+}
+// -----------------------------------------------------------------------------
+//              (tm=0)
+static int mcache_find_index( struct CacheInfo* mcache,
+						BOOL (*mcache_compare)( int ind,  const struct __server_request_info* req ),
+						struct __server_request_info* req )
+{
+	int i=0;
+	int first = -1;
+	for( ;i<CACHE_MAX_NUM; i++ )
+	{
+		if( mcache_compare(i,req) )
+			return i;
+		
+		if( first < 0 && !mcache[i].ms )
+			first = i;
+	}
+
+	return first;
+}
+// -----------------------------------------------------------------------------
+static void mcache_update_win_tree( struct __server_request_info* req, struct __server_request_info* rep )
+{
+	struct get_window_tree_request* r = (struct get_window_tree_request*)(&req->u.req);
+
+	int ind = mcache_find_index( mcache_win_tree, mcache_compare_win_tree, req );
+	
+	if( ind < 0 )
+		ind = win_tree_curindex;
+
+	mcache_win_tree[ind].handle 	= r->handle;
+	mcache_win_tree[ind].ms 		= NtGetTickCount();
+	mcache_win_tree[ind].reply 		= (*rep);
+	win_tree_curindex++;
+	if( win_tree_curindex >= CACHE_MAX_NUM )
+		win_tree_curindex = 0;
+
+	win_tree_empty = 0;
+
+//	fprintf(stderr,"(mcache_update): add reply to cache for %p curindex=%d\n",r->handle,curindex);
+}
+// -----------------------------------------------------------------------------
+static void mcache_update_win_child( struct __server_request_info* req, struct __server_request_info* rep )
+{
+	struct get_window_children_request* r = (struct get_window_children_request*)(&req->u.req);
+
+	int ind = mcache_find_index( mcache_win_child, mcache_compare_win_child, req );
+	if( ind < 0 )
+		ind = win_child_curindex;
+
+	mcache_win_child[ind].handle 	= r->parent;
+	mcache_win_child[ind].ms 	= NtGetTickCount();
+	mcache_win_child[ind].reply 	= (*rep);
+	win_child_curindex++;
+	if( win_child_curindex >= CACHE_MAX_NUM )
+		win_child_curindex = 0;
+
+	win_child_empty = 0;
+
+//	fprintf(stderr,"(mcache_update): add reply to cache for %p curindex=%d\n",r->handle,curindex);
+}
+// -----------------------------------------------------------------------------
+static void mcache_update_get_thread( struct __server_request_info* req, struct __server_request_info* rep )
+{
+	struct get_thread_input_request* r = (struct get_thread_input_request*)(&req->u.req);
+
+	int ind = mcache_find_index( mcache_get_thread, mcache_compare_get_thread, req );
+	
+	if( ind < 0 )
+		ind = get_thread_curindex;
+
+	mcache_get_thread[ind].handle 	= 0;
+	mcache_get_thread[ind].tid 	= r->tid;
+	mcache_get_thread[ind].ms 	= NtGetTickCount();
+	mcache_get_thread[ind].reply 	= *rep;
+	get_thread_curindex++;
+	if( get_thread_curindex >= CACHE_MAX_NUM )
+		get_thread_curindex = 0;
+
+	get_thread_empty = 0;
+
+//	fprintf(stderr,"(mcache_update_get_thread): add reply to cache for %p tid_in=%d curindex=%d\n",
+//						r->handle,r->tid_in,get_thread_curindex);
+}
+// -----------------------------------------------------------------------------
+
+void mcache_update( struct __server_request_info* req, struct __server_request_info* rep )
+{
+	if( !mcache_init_ok )
+		mcache_init();
+
+	if( !mcache_filtr(req) )
+		return;
+
+	switch( req->u.req.request_header.req )
+	{
+		case REQ_get_window_tree:
+			mcache_update_win_tree(req, rep);
+		break;
+
+		case REQ_get_window_children:
+			mcache_update_win_child(req, rep);
+		break;
+
+		case REQ_get_thread_input:
+			mcache_update_get_thread(req, rep);
+		break;
+
+		default:
+			return;
+	}
+}
+// -----------------------------------------------------------------------------
+//      
+//     ()    
+//     (  )
+//   ...
+static BOOL mcache_check( struct CacheInfo* mcache,
+					BOOL (*mcache_compare)( int ind,  const struct __server_request_info* req ),
+					const struct __server_request_info* req, struct __server_request_info* rep,
+					int* curindex, int cache_timeout )
+{
+	int i 		= 0;
+	BOOL old 	= 0;
+	BOOL empty 	= 1;
+	ULONG t2 	= NtGetTickCount();
+
+	/*            !
+	//    update,    () 
+	//    ,    difftime    ( mcache_compare)
+	//       ....
+	*/
+	for( ; i<CACHE_MAX_NUM; i++ )
+	{
+		if( !mcache[i].ms )
+			continue;
+
+		old = ((t2 - mcache[i].ms) >= cache_timeout );
+
+		if( mcache_compare(i,req) )
+		{
+			if( !old )
+			{
+/*				fprintf(stderr,"(mcache_check): find in cache handle=%p\n",mcache[i].handle); */
+				*rep = mcache[i].reply;
+				return 1;
+			}
+		}
+		
+		if( old )
+			mcache[i].ms = 0; /* ,    */
+		else
+			empty = 0;
+	}
+
+	if( empty )
+		*curindex = 0;
+
+	return 0;
+}
diff -uHNrp wine-20071130/dlls/ntdll/serial.c wine-20071130e/dlls/ntdll/serial.c
--- wine-20071130/dlls/ntdll/serial.c	2007-12-01 21:14:15.000000000 +0300
+++ wine-20071130e/dlls/ntdll/serial.c	2008-02-04 18:31:20.000000000 +0300
@@ -947,6 +947,21 @@ static DWORD WINAPI check_events(int fd,
 	if (queue)
 	    ret |= EV_RXCHAR;
     }
+    if (mask & EV_RXFLAG)
+    {
+        if ( !(ret^EV_RXCHAR)) 
+	{
+		queue = 0;
+#ifdef TIOCINQ
+		if (ioctl(fd, TIOCINQ, &queue))
+	    	WARN("TIOCINQ returned error\n");
+#endif
+	}
+	if (queue)
+	{
+	    ret |= EV_RXCHAR|EV_RXFLAG;
+	}
+    }
     if (mask & EV_TXEMPTY)
     {
 	queue = 0;
@@ -1069,7 +1084,7 @@ static NTSTATUS wait_on(HANDLE hDevice, 
 	goto error_caps;
 #endif
     if (commio->evtmask & EV_RXFLAG)
-	FIXME("EV_RXFLAG not handled\n");
+	WARN("EV_RXFLAG released as EV_RXCHAR\n");
     if ((status = get_irq_info(fd, &commio->irq_info)) ||
         (status = get_modem_status(fd, &commio->mstat)))
         goto out_now;
diff -uHNrp wine-20071130/dlls/ntdll/server.c wine-20071130e/dlls/ntdll/server.c
--- wine-20071130/dlls/ntdll/server.c	2007-12-01 21:14:15.000000000 +0300
+++ wine-20071130e/dlls/ntdll/server.c	2008-02-04 18:31:20.000000000 +0300
@@ -61,6 +61,14 @@
 #include "wine/debug.h"
 #include "ntdll_misc.h"
 
+/* mcache */
+extern BOOL mcache_check_msg( const struct __server_request_info* req, 
+								struct __server_request_info* rep );
+
+extern void mcache_update( struct __server_request_info* req, 
+							struct __server_request_info* rep );
+
+
 WINE_DEFAULT_DEBUG_CHANNEL(server);
 
 /* Some versions of glibc don't define this */
@@ -320,11 +328,18 @@ unsigned int wine_server_call( void *req
     struct __server_request_info * const req = req_ptr;
     sigset_t old_set;
     unsigned int ret;
+    struct __server_request_info old_req = *req;
+
+    if( mcache_check_msg(&old_req, req) )
+        return req->u.reply.reply_header.error;
 
     pthread_functions.sigprocmask( SIG_BLOCK, &server_block_set, &old_set );
     ret = send_request( req );
     if (!ret) ret = wait_reply( req );
     pthread_functions.sigprocmask( SIG_SETMASK, &old_set, NULL );
+
+    mcache_update(&old_req, req);
+
     return ret;
 }
 
diff -uHNrp wine-20071130/dlls/ntdll/thread.c wine-20071130e/dlls/ntdll/thread.c
--- wine-20071130/dlls/ntdll/thread.c	2007-12-01 21:14:15.000000000 +0300
+++ wine-20071130e/dlls/ntdll/thread.c	2008-02-04 18:31:20.000000000 +0300
@@ -228,6 +228,7 @@ HANDLE thread_init(void)
     SIZE_T size, info_size;
     HANDLE exe_file = 0;
     LARGE_INTEGER now;
+    NTSTATUS status;
     struct ntdll_thread_data *thread_data;
     struct wine_pthread_thread_info thread_info;
     static struct debug_info debug_info;  /* debug info for initial thread */
@@ -238,7 +239,14 @@ HANDLE thread_init(void)
 
     addr = (void *)0x7ffe0000;
     size = 0x10000;
-    NtAllocateVirtualMemory( NtCurrentProcess(), &addr, 0, &size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE );
+    status = NtAllocateVirtualMemory( NtCurrentProcess(), &addr, 0, &size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE );
+	
+    if ( status != STATUS_SUCCESS )
+    {
+        MESSAGE( "wine: can`t allocate virtual memory for addr=%p\n", addr );
+        exit(1);
+    }
+	
     user_shared_data = addr;
 
     /* allocate and initialize the PEB */
@@ -329,12 +337,15 @@ HANDLE thread_init(void)
 
     /* initialize time values in user_shared_data */
     NtQuerySystemTime( &now );
+
+#if !defined(__FreeBSD__)
     user_shared_data->SystemTime.LowPart = now.u.LowPart;
     user_shared_data->SystemTime.High1Time = user_shared_data->SystemTime.High2Time = now.u.HighPart;
     user_shared_data->u.TickCountQuad = (now.QuadPart - server_start_time) / 10000;
     user_shared_data->u.TickCount.High2Time = user_shared_data->u.TickCount.High1Time;
     user_shared_data->TickCountLowDeprecated = user_shared_data->u.TickCount.LowPart;
     user_shared_data->TickCountMultiplier = 1 << 24;
+#endif
 
     return exe_file;
 }
diff -uHNrp wine-20071130/dlls/ntdll/version.c wine-20071130e/dlls/ntdll/version.c
--- wine-20071130/dlls/ntdll/version.c	2007-12-01 21:14:15.000000000 +0300
+++ wine-20071130e/dlls/ntdll/version.c	2008-02-04 18:31:20.000000000 +0300
@@ -375,6 +375,49 @@ static BOOL get_win9x_registry_version( 
     return ret;
 }
 
+/**********************************************************************
+ *         parse_version_string
+ */
+static BOOL parse_version_string( const WCHAR *str, DWORD length )
+{
+    int i;
+    DWORD len;
+    char buffer[50];
+
+    RtlUnicodeToMultiByteN( buffer, sizeof(buffer)-1, &len, str, length );
+    buffer[len] = 0;
+
+    for (i = 0; i < NB_WINDOWS_VERSIONS; i++)
+    {
+        const char *p, *pCurr = WinVersionNames[i];
+        /* iterate through all winver aliases separated by comma */
+        do {
+            p = strchr(pCurr, ',');
+            len = p ? p - pCurr : strlen(pCurr);
+            if ( (!strncmp( pCurr, buffer, len )) && (buffer[len] == 0) )
+            {
+                current_version = &VersionData[i];
+                TRACE( "got win version %s\n", WinVersionNames[i] );
+                return TRUE;
+            }
+            pCurr = p+1;
+        } while (p);
+    }
+
+    MESSAGE("Invalid Windows version value '%s' specified in config file.\n", buffer );
+    MESSAGE("Valid versions are:" );
+    for (i = 0; i < NB_WINDOWS_VERSIONS; i++)
+    {
+        /* only list the first, "official" alias in case of aliases */
+        const char *pCurr = WinVersionNames[i];
+        const char *p = strchr(pCurr, ',');
+        len = (p) ? p - pCurr : strlen(pCurr);
+
+        MESSAGE(" '%.*s'%c", (int)len, pCurr, (i == NB_WINDOWS_VERSIONS - 1) ? '\n' : ',' );
+    }
+    return FALSE;
+}
+
 
 /**********************************************************************
  *         parse_win_version
@@ -445,6 +488,23 @@ void version_init( const WCHAR *appname 
 
     current_version = &VersionData[NT2K];  /* default if nothing else is specified */
 
+    /* awful CrossOver hack^H^H^H^Hproprietary enhancement */
+    {
+        static const WCHAR cxverW[] = {'W','I','N','D','O','W','S','_','V','E','R','S','I','O','N',0};
+        UNICODE_STRING valueW;
+        WCHAR cxversion[32];
+
+        RtlInitUnicodeString( &nameW, cxverW );
+        valueW.MaximumLength = sizeof(cxversion);
+        valueW.Buffer = cxversion;
+        if (RtlQueryEnvironmentVariable_U(NULL, &nameW, &valueW) == STATUS_SUCCESS)
+        {
+            TRACE( "getting version from WINDOWS_VERSION\n" );
+            got_win_ver = parse_version_string( cxversion, strlenW(cxversion) * sizeof(WCHAR) );
+            goto done;
+        }
+    }
+
     RtlOpenCurrentUser( KEY_ALL_ACCESS, &root );
     attr.Length = sizeof(attr);
     attr.RootDirectory = root;
@@ -506,12 +566,14 @@ done:
     NtCurrentTeb()->Peb->OSBuildNumber  = current_version->dwBuildNumber;
     NtCurrentTeb()->Peb->OSPlatformId   = current_version->dwPlatformId;
 
+#if ! defined(__FreeBSD__)
     user_shared_data->NtProductType      = current_version->wProductType;
     user_shared_data->ProductTypeIsValid = TRUE;
     user_shared_data->MajorNtVersion     = current_version->dwMajorVersion;
     user_shared_data->MinorNtVersion     = current_version->dwMinorVersion;
     user_shared_data->MinorNtVersion     = current_version->dwMinorVersion;
     user_shared_data->SuiteMask          = current_version->wSuiteMask;
+#endif
 
     TRACE( "got %d.%d plaform %d build %x name %s service pack %d.%d product %d\n",
            current_version->dwMajorVersion, current_version->dwMinorVersion,
diff -uHNrp wine-20071130/dlls/ole32/storage32.c wine-20071130e/dlls/ole32/storage32.c
--- wine-20071130/dlls/ole32/storage32.c	2007-12-01 21:14:15.000000000 +0300
+++ wine-20071130e/dlls/ole32/storage32.c	2008-02-04 18:31:20.000000000 +0300
@@ -1125,12 +1125,14 @@ static HRESULT WINAPI StorageBaseImpl_Se
   REFCLSID         clsid) /* [in] */
 {
   StorageBaseImpl *This = (StorageBaseImpl *)iface;
-  HRESULT hRes = E_FAIL;
+  HRESULT hRes = E_FAIL; /* STG_E_MEDIUMFULL according to MSDN */
   StgProperty curProperty;
   BOOL success;
 
   TRACE("(%p, %p)\n", iface, clsid);
 
+  if (clsid == NULL)
+    return STG_E_INVALIDPOINTER;
   success = StorageImpl_ReadProperty(This->ancestorStorage,
                                        This->rootPropertySetIndex,
                                        &curProperty);
@@ -6297,7 +6299,7 @@ HRESULT WINAPI WriteClassStg(IStorage* p
 {
   HRESULT hRes;
 
-  if(!pStg)
+  if (!IsValidInterface((LPUNKNOWN)pStg))
     return E_INVALIDARG;
 
   hRes = IStorage_SetClass(pStg, rclsid);
diff -uHNrp wine-20071130/dlls/ole32/tests/storage32.c wine-20071130e/dlls/ole32/tests/storage32.c
--- wine-20071130/dlls/ole32/tests/storage32.c	2007-12-01 21:14:15.000000000 +0300
+++ wine-20071130e/dlls/ole32/tests/storage32.c	2008-02-04 18:31:20.000000000 +0300
@@ -48,6 +48,14 @@ static void test_hglobal_storage_stat(vo
     r = StgCreateDocfileOnILockBytes( ilb, mode, 0,  &stg );
     ok( r == S_OK, "StgCreateDocfileOnILockBytes failed\n");
 
+    /* Tests for call with broken params */
+    r = WriteClassStg(NULL, &test_stg_cls);
+    ok( r == E_INVALIDARG, "WriteClassStg must returns E_INVALIDARG with NULL as arg stg\n");
+    r = WriteClassStg((IStorage*)&stat, &test_stg_cls);
+    ok( r == E_INVALIDARG, "WriteClassStg must returns E_INVALIDARG when stg have no IStorage object\n");
+    r = WriteClassStg(stg, NULL);
+    ok( r == STG_E_INVALIDPOINTER, "WriteClassStg must returns E_INVALIDARG with NULL as arg rclid\n");
+
     r = WriteClassStg( stg, &test_stg_cls );
     ok( r == S_OK, "WriteClassStg failed\n");
 
diff -uHNrp wine-20071130/dlls/oledlg/insobjdlg.c wine-20071130e/dlls/oledlg/insobjdlg.c
--- wine-20071130/dlls/oledlg/insobjdlg.c	2007-12-01 21:14:18.000000000 +0300
+++ wine-20071130e/dlls/oledlg/insobjdlg.c	2008-02-04 18:31:20.000000000 +0300
@@ -332,38 +332,39 @@ static void UIINSERTOBJECTDLG_SelectCrea
  */
 static BOOL UIINSERTOBJECTDLG_PopulateObjectTypes(InsertObjectDlgInfo* pdlgInfo)
 {
+  static const WCHAR szClsid[] = {'C','L','S','I','D',0};
+  static const WCHAR szInsertable[] = {'I','n','s','e','r','t','a','b','l','e',0};
+  static const WCHAR szNotInsertable[] = {'N','o','t','I','n','s','e','r','t','a','b','l','e',0};
   DWORD i;
   LONG len;
   HKEY hkclsids;
   HKEY hkey;
   CLSID clsid;
   HRESULT ret;
-  CHAR szclsid[128];
-  CHAR keydesc[MAX_PATH];
-  CHAR keyname[MAX_PATH];
-  WCHAR wszclsid[128];
+  WCHAR keydesc[MAX_PATH];
+  WCHAR keyname[MAX_PATH];
+  WCHAR szclsid[128];
   DWORD index = 0;
 
   UIINSERTOBJECTDLG_FreeObjectTypes(pdlgInfo);
 
-  RegOpenKeyExA(HKEY_CLASSES_ROOT, "CLSID", 0, KEY_READ, &hkclsids);
+  RegOpenKeyExW(HKEY_CLASSES_ROOT, szClsid, 0, KEY_READ, &hkclsids);
 
-  while (ERROR_SUCCESS == (ret = RegEnumKeyA(hkclsids, index, szclsid, MAX_PATH)))
+  while (ERROR_SUCCESS == (ret = RegEnumKeyW(hkclsids, index, szclsid, sizeof(szclsid)/sizeof(szclsid[0]))))
   {
     index++;
 
-    RegOpenKeyExA(hkclsids, szclsid, 0, KEY_READ, &hkey);
+    RegOpenKeyExW(hkclsids, szclsid, 0, KEY_READ, &hkey);
 
-    len = MAX_PATH;
-    if (ERROR_SUCCESS != RegQueryValueA(hkey, "Insertable", keyname, &len))
+    len = sizeof(keyname);
+    if (ERROR_SUCCESS != RegQueryValueW(hkey, szInsertable, keyname, &len))
         continue;
 
-    len = MAX_PATH;
-    if (ERROR_SUCCESS == RegQueryValueA(hkey, "NotInsertable", keyname, &len))
+    len = sizeof(keyname);
+    if (ERROR_SUCCESS == RegQueryValueW(hkey, szNotInsertable, keyname, &len))
         continue;
 
-    RtlMultiByteToUnicodeN(wszclsid, MAX_PATH, NULL, szclsid, MAX_PATH); 
-    CLSIDFromString(wszclsid, &clsid);
+    CLSIDFromString(szclsid, &clsid);
 
     for (i = 0; i < pdlgInfo->lpOleUIInsertObject->cClsidExclude; i++)
       if (IsEqualGUID(&pdlgInfo->lpOleUIInsertObject->lpClsidExclude[i], &clsid))
@@ -372,14 +373,14 @@ static BOOL UIINSERTOBJECTDLG_PopulateOb
     if (i < pdlgInfo->lpOleUIInsertObject->cClsidExclude)
       continue;
 
-    len = MAX_PATH;
-    if (ERROR_SUCCESS == RegQueryValueA(hkey, NULL, keydesc, &len))
+    len = sizeof(keydesc);
+    if (ERROR_SUCCESS == RegQueryValueW(hkey, NULL, keydesc, &len))
     {
        CLSID* lpclsid = HeapAlloc(GetProcessHeap(), 0, sizeof(CLSID));
        memcpy(lpclsid, &clsid, sizeof(CLSID));
 
-       len = SendMessageA(pdlgInfo->hwndObjTypeLB, LB_ADDSTRING, 0, (LPARAM)keydesc);
-       SendMessageA(pdlgInfo->hwndObjTypeLB, LB_SETITEMDATA, (WPARAM)len, (LPARAM)lpclsid);
+       len = SendMessageW(pdlgInfo->hwndObjTypeLB, LB_ADDSTRING, 0, (LPARAM)keydesc);
+       SendMessageW(pdlgInfo->hwndObjTypeLB, LB_SETITEMDATA, (WPARAM)len, (LPARAM)lpclsid);
     }
   }
 
@@ -471,17 +472,15 @@ static BOOL UIINSERTOBJECTDLG_OnOpen(Ins
   }
   else if (BST_CHECKED == SendMessageA(pdlgInfo->hwndCreateFromFileCB, BM_GETCHECK, 0, 0))
   {
-    char fname[MAX_PATH];
-
     if (pdlgInfo->lpOleUIInsertObject->lpszFile)
     {
       HRESULT hres;
       WCHAR wcsFile[MAX_PATH];
 
-      SendMessageA(pdlgInfo->hwndFileTB, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)fname);
-      lstrcpynA(pdlgInfo->lpOleUIInsertObject->lpszFile, fname, pdlgInfo->lpOleUIInsertObject->cchFile);
+      if (SendMessageW(pdlgInfo->hwndFileTB, WM_GETTEXT, (WPARAM)sizeof(wcsFile), (LPARAM)wcsFile))
+          WideCharToMultiByte(CP_ACP, 0, wcsFile, -1,
+              pdlgInfo->lpOleUIInsertObject->lpszFile, pdlgInfo->lpOleUIInsertObject->cchFile, NULL, NULL);
 
-      RtlMultiByteToUnicodeN(wcsFile, MAX_PATH, NULL, fname, MAX_PATH); 
       if (ERROR_SUCCESS == (hres = GetClassFile(wcsFile, &pdlgInfo->lpOleUIInsertObject->clsid)))
       {
          if (pdlgInfo->lpOleUIInsertObject->dwFlags & IOF_CREATEFILEOBJECT)
diff -uHNrp wine-20071130/dlls/oledlg/Makefile.in wine-20071130e/dlls/oledlg/Makefile.in
--- wine-20071130/dlls/oledlg/Makefile.in	2007-12-01 21:14:18.000000000 +0300
+++ wine-20071130e/dlls/oledlg/Makefile.in	2008-02-04 18:31:20.000000000 +0300
@@ -4,7 +4,7 @@ SRCDIR    = @srcdir@
 VPATH     = @srcdir@
 MODULE    = oledlg.dll
 IMPORTLIB = liboledlg.$(IMPLIBEXT)
-IMPORTS   = ole32 comdlg32 user32 advapi32 kernel32 ntdll
+IMPORTS   = ole32 comdlg32 user32 advapi32 kernel32
 
 C_SRCS = \
 	insobjdlg.c \
diff -uHNrp wine-20071130/dlls/oledlg/oledlg_En.rc wine-20071130e/dlls/oledlg/oledlg_En.rc
--- wine-20071130/dlls/oledlg/oledlg_En.rc	2007-12-01 21:14:18.000000000 +0300
+++ wine-20071130e/dlls/oledlg/oledlg_En.rc	2008-02-04 18:31:20.000000000 +0300
@@ -52,6 +52,9 @@ STRINGTABLE DISCARDABLE
   IDS_BROWSE            "Browse"
   IDS_NOTOLEMOD         "File does not appear to be a valid OLE module. Unable to register OLE control."
   IDS_NOTOLEMODCAPTION  "Add Control"
+  IDS_OBJECT            "Object: "
+  IDS_NOOBJECT          "No OLE object"
+  IDS_CONVERTING        "Converting..."
 }
 
 IDD_PASTESPECIAL4 DIALOG DISCARDABLE 3, 15, 293, 140
diff -uHNrp wine-20071130/dlls/oledlg/oledlg_main.c wine-20071130e/dlls/oledlg/oledlg_main.c
--- wine-20071130/dlls/oledlg/oledlg_main.c	2007-12-01 21:14:18.000000000 +0300
+++ wine-20071130e/dlls/oledlg/oledlg_main.c	2008-02-04 18:31:20.000000000 +0300
@@ -2,6 +2,7 @@
  *	OLEDLG library
  *
  *	Copyright 1998	Patrik Stridvall
+ *	Copyright 2008  Vitaly Lipatov (Etersoft)
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -25,9 +26,14 @@
 #include "winerror.h"
 #include "wingdi.h"
 #include "winuser.h"
+
+#define COBJMACROS
 #include "oledlg.h"
 #include "ole2.h"
+#include "oleidl.h"
 #include "oledlg_private.h"
+#include "wine/unicode.h"
+#include "resource.h"
 
 #include "wine/debug.h"
 
@@ -101,36 +107,135 @@ BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
 
 /***********************************************************************
  *           OleUIAddVerbMenuA (OLEDLG.1)
+ *  See OleUIAddVerbMenuW description
  */
 BOOL WINAPI OleUIAddVerbMenuA(
   LPOLEOBJECT lpOleObj, LPCSTR lpszShortType,
   HMENU hMenu, UINT uPos, UINT uIDVerbMin, UINT uIDVerbMax,
   BOOL bAddConvert, UINT idConvert, HMENU *lphMenu)
 {
-  FIXME("(%p, %s, %p, %d, %d, %d, %d, %d, %p): stub\n",
-    lpOleObj, debugstr_a(lpszShortType),
-    hMenu, uPos, uIDVerbMin, uIDVerbMax,
-    bAddConvert, idConvert, lphMenu
-  );
-  SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-  return FALSE;
+    LPWSTR newstr = NULL;
+    BOOL ret = FALSE;
+
+    if (lpszShortType) {
+        INT len = MultiByteToWideChar( CP_ACP, 0, lpszShortType, -1, NULL, 0 );
+        newstr = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR) );
+        if (newstr)
+            MultiByteToWideChar( CP_ACP, 0, lpszShortType, -1, newstr, len );
+    }
+    ret = OleUIAddVerbMenuW(
+                          lpOleObj, newstr,
+                          hMenu, uPos, uIDVerbMin, uIDVerbMax,
+                          bAddConvert, idConvert, lphMenu);
+    HeapFree( GetProcessHeap(), 0, newstr );
+    return ret;
 }
 
 /***********************************************************************
  *           OleUIAddVerbMenuW (OLEDLG.14)
+ *  Adds Object menu for the OLE object
+ *
+ * PARAMS
+ *  lpOleObj       [I ] pointer to the OLE object
+ *  lpszShortType  [I ] short name of the object or NULL if it is unknown
+ *  hMenu          [I ] menu handle
+ *  uPos           [I ] menu item position
+ *  uIDVerbMin,    [I ] min Verb ID
+ *  uIDVerbMax,    [I ] max Verb ID (0 if it's not used)
+ *  bAddConvert    [I ] TRUE if the item "Converting" is needed in the bottom of menu
+ *  idConvert      [I ] ID of the item "Converting"
+ *  lphMenu        [IO] pointer to the popup menu, if created
+ *
+ * NOTES
+ *  If lpOleObj is NULL, then a default disabled menu item is created.
+ *
+ * RETURNS
+ *  TRUE if at least one verb was added to the menu
+ *  FALSE if disabled default menu item was created
+ *
+ * TODO
+ *  Check if OLE object has no verbs
  */
 BOOL WINAPI OleUIAddVerbMenuW(
   LPOLEOBJECT lpOleObj, LPCWSTR lpszShortType,
   HMENU hMenu, UINT uPos, UINT uIDVerbMin, UINT uIDVerbMax,
   BOOL bAddConvert, UINT idConvert, HMENU *lphMenu)
 {
-  FIXME("(%p, %s, %p, %d, %d, %d, %d, %d, %p): stub\n",
-    lpOleObj, debugstr_w(lpszShortType),
-    hMenu, uPos, uIDVerbMin, uIDVerbMax,
-    bAddConvert, idConvert, lphMenu
-  );
-  SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-  return FALSE;
+    HRESULT hr;
+    IEnumOLEVERB *pEnumVerbs;
+    HMENU popup = NULL;
+
+    FIXME("(%p, %s, %p, %d, %d, %d, %d, %d, %p): stub\n",
+        lpOleObj, debugstr_w(lpszShortType),
+        hMenu, uPos, uIDVerbMin, uIDVerbMax,
+        bAddConvert, idConvert, lphMenu );
+
+    if (!lpOleObj) {
+        WCHAR buf[MAX_PATH];
+        TRACE("Create disabled menu entry\n");
+        LoadStringW(OLEDLG_hInstance, IDS_NOOBJECT, buf, MAX_PATH);
+        DeleteMenu(hMenu, uPos, MF_BYPOSITION);
+        InsertMenuW(hMenu, uPos, MF_BYPOSITION|MF_STRING|MF_DISABLED, uIDVerbMin, buf);
+        return FALSE;
+    }
+
+    hr = IOleObject_EnumVerbs(lpOleObj, &pEnumVerbs);
+    if (hr == S_OK) {
+        int num; /* Number of menu entries */
+        OLEVERB oleVerb;
+        /* FIXME: there is OLE_S_USEREG, OLEOBJ_E_NOVERBS also */
+        for (num = 0; IEnumOLEVERB_Next(pEnumVerbs, 1, &oleVerb, NULL) == S_OK ; num++)
+            CoTaskMemFree(oleVerb.lpszVerbName);
+        IEnumOLEVERB_Reset(pEnumVerbs);
+        
+        /* It destroys popup menu also */
+        if (num)
+            DeleteMenu(hMenu, uPos, MF_BYPOSITION);
+
+        /* If there is a few entries or converting entry needed */
+        if (num > 1 || bAddConvert) {
+            WCHAR menustr[MAX_PATH];
+            int len;
+            /* Prepare menu entry for popup menu */
+            LoadStringW(OLEDLG_hInstance, IDS_OBJECT, menustr, MAX_PATH);
+            len = strlenW(menustr);
+            if (lpszShortType)
+                strcpyW(menustr+len, lpszShortType);
+            else {
+                LPOLESTR lpszUserType;
+                IOleObject_GetUserType(lpOleObj, 0, &lpszUserType);
+                TRACE("Get UserType: %s\n", debugstr_w(lpszUserType));
+                strcpyW(menustr+len, lpszUserType);
+                CoTaskMemFree(lpszUserType);
+            }
+
+            popup = CreatePopupMenu();
+            InsertMenuW(hMenu, uPos, MF_BYPOSITION|MF_POPUP|MF_STRING, (UINT_PTR)popup, menustr);
+            uPos = -1;
+            hMenu = popup;
+        }
+
+        while (IEnumOLEVERB_Next(pEnumVerbs, 1, &oleVerb, NULL) == S_OK) {
+            TRACE("lVerb=%d VerbName=%s fuFlags=%x\n", oleVerb.lVerb,
+                  debugstr_w(oleVerb.lpszVerbName), oleVerb.fuFlags);
+            if (uIDVerbMax && (oleVerb.lVerb > uIDVerbMax-uIDVerbMin))
+                break;
+            InsertMenuW(hMenu, uPos, oleVerb.fuFlags|MF_BYPOSITION|MF_STRING, oleVerb.lVerb+uIDVerbMin, oleVerb.lpszVerbName);
+            /* FIXME: Is it really needed and documented? */
+            CoTaskMemFree(oleVerb.lpszVerbName);
+        }
+
+        /* Converting entry may be only in popup menu */
+        if (popup && bAddConvert) {
+            WCHAR buf[MAX_PATH];
+            InsertMenuW(hMenu, uPos, MF_BYPOSITION|MF_SEPARATOR, 0, NULL);
+            if (LoadStringW(OLEDLG_hInstance, IDS_CONVERTING, buf, MAX_PATH))
+                InsertMenuW(hMenu, uPos, MF_BYPOSITION|MF_STRING, idConvert, buf);
+        }
+        IEnumOLEVERB_Release(pEnumVerbs);
+    }
+    *lphMenu = popup;
+    return TRUE;
 }
 
 /***********************************************************************
diff -uHNrp wine-20071130/dlls/oledlg/oledlg_Ru.rc wine-20071130e/dlls/oledlg/oledlg_Ru.rc
--- wine-20071130/dlls/oledlg/oledlg_Ru.rc	1970-01-01 03:00:00.000000000 +0300
+++ wine-20071130e/dlls/oledlg/oledlg_Ru.rc	2008-02-04 18:31:20.000000000 +0300
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2007 Vitaly Lipatov for Etersoft
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+LANGUAGE LANG_RUSSIAN, SUBLANG_DEFAULT
+
+UIINSERTOBJECT DIALOG DISCARDABLE  0, 0, 294, 151
+STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
+CAPTION " "
+FONT 8, "MS Shell Dlg"
+BEGIN
+    LISTBOX         IDC_OBJTYPELIST,82,19,131,66,LBS_SORT |
+                    LBS_NOINTEGRALHEIGHT | WS_VISIBLE | WS_VSCROLL |
+                    WS_TABSTOP
+    LTEXT           " :",IDC_OBJTYPELBL,82,7,53,8,WS_VISIBLE
+    DEFPUSHBUTTON   "OK",IDOK,221,7,66,14
+    PUSHBUTTON      "",IDCANCEL,221,24,66,14
+    GROUPBOX        "",IDC_RESULT,7,103,208,41
+    CONTROL         " ",IDC_CREATENEW,"Button",BS_AUTORADIOBUTTON | 
+                    WS_GROUP,7,20,62,10
+    CONTROL         "  ",IDC_CREATECONTROL,"Button",
+                    BS_AUTORADIOBUTTON | NOT WS_VISIBLE,7,54,62,10
+    CONTROL         "  ",IDC_CREATEFROMFILE,"Button",
+                    BS_AUTORADIOBUTTON,7,37,67,10
+    LTEXT           "",IDC_RESULTDESC,49,112,159,23
+    PUSHBUTTON      "&  ...",IDC_ADDCONTROL,81,88,63,14,NOT WS_VISIBLE
+    CONTROL         "Display As Icon",IDC_ASICON,"Button",BS_AUTOCHECKBOX | 
+                    WS_TABSTOP | NOT WS_VISIBLE,223,58,64,10
+    PUSHBUTTON      "...",IDC_BROWSE,83,53,50,14,NOT WS_VISIBLE
+    LTEXT           ":",IDC_FILELBL,83,27,20,8, NOT WS_VISIBLE
+    EDITTEXT        IDC_FILE,83,37,132,13,ES_AUTOHSCROLL | NOT WS_VISIBLE
+END
+
+STRINGTABLE DISCARDABLE
+{
+  IDS_RESULTOBJDESC	"   %s  "
+  IDS_RESULTFILEOBJDESC	"     .         ."
+  IDS_BROWSE            ""
+  IDS_NOTOLEMOD         "     OLE.     OLE."
+  IDS_NOTOLEMODCAPTION  "  "
+}
+
+IDD_PASTESPECIAL4 DIALOG DISCARDABLE 3, 15, 293, 140
+STYLE DS_MODALFRAME | DS_SETFONT | WS_POPUP | WS_CAPTION | WS_SYSMENU
+CAPTION " "
+FONT 8, "MS Shell Dlg"
+BEGIN
+    LTEXT         ":", -1, 6, 9, 30, 8, WS_VISIBLE | WS_GROUP
+    CONTROL       "&", IDC_PS_PASTE, "Button", BS_AUTORADIOBUTTON | WS_TABSTOP | WS_GROUP | WS_VISIBLE,
+                  6, 38, 55, 10
+    CONTROL       " &", IDC_PS_PASTELINK, "Button", BS_AUTORADIOBUTTON | WS_VISIBLE,
+                  6, 63, 55, 10
+    LTEXT         "&:", -1, 65, 25, 16, 8, WS_VISIBLE | WS_GROUP
+    LISTBOX       IDC_PS_PASTELIST,     65, 36, 153, 57, LBS_NOTIFY | LBS_USETABSTOPS | WS_VSCROLL | WS_BORDER | NOT WS_VISIBLE
+    LISTBOX       IDC_PS_PASTELINKLIST, 65, 36, 153, 57, LBS_NOTIFY | LBS_USETABSTOPS | WS_VSCROLL | WS_BORDER | NOT WS_VISIBLE
+    LISTBOX       IDC_PS_DISPLAYLIST,   65, 36, 153, 57, LBS_NOTIFY | LBS_USETABSTOPS | WS_VSCROLL | WS_BORDER | WS_VISIBLE
+    CONTROL       "OK", IDOK, "Button", BS_DEFPUSHBUTTON | WS_TABSTOP | WS_GROUP | WS_VISIBLE, 224, 6, 66, 14
+    CONTROL       "", IDCANCEL, "Button", BS_PUSHBUTTON | WS_TABSTOP | WS_VISIBLE, 224, 23, 66, 14
+    CONTROL       "&", IDC_OLEUIHELP, "Button", BS_PUSHBUTTON | WS_TABSTOP | WS_VISIBLE, 224, 42, 66, 14
+    CONTROL       "&  ", IDC_PS_DISPLAYASICON, "Button", BS_AUTOCHECKBOX | WS_TABSTOP | WS_VISIBLE, 224, 59, 66, 14
+    CONTROL       "", IDC_PS_ICONDISPLAY, "Static", SS_ICON | WS_VISIBLE, 224, 75, 66, 44
+    CONTROL       " &...", IDC_PS_CHANGEICON, "Button", BS_PUSHBUTTON | WS_TABSTOP | WS_VISIBLE, 224, 123, 66, 14
+    CONTROL       "", IDC_PS_RESULTIMAGE, "Static", SS_ICON | WS_VISIBLE, 8, 101, 42, 34
+    CONTROL       "<< result text goes here >>", IDC_PS_RESULTTEXT, "Static", SS_NOPREFIX | WS_VISIBLE, 54, 100, 159, 35
+    CONTROL       "", -1, "Button", BS_GROUPBOX | WS_GROUP | WS_VISIBLE, 6, 90, 212, 48
+    CONTROL       "", IDC_PS_SOURCETEXT, "Edit", ES_READONLY | ES_AUTOHSCROLL | WS_VISIBLE, 37, 9, 180, 8
+END
+
+STRINGTABLE DISCARDABLE
+{
+    IDS_PS_PASTE_DATA                     "       %s."
+    IDS_PS_PASTE_OBJECT                   "      ,    ,  %s."
+    IDS_PS_PASTE_OBJECT_AS_ICON           "      ,    ,  %s.      ."
+    IDS_PS_PASTE_LINK_DATA                "       %s.      ,         ."
+    IDS_PS_PASTE_LINK_OBJECT              "      .      ,         ."
+    IDS_PS_PASTE_LINK_OBJECT_AS_ICON      " ,        .      ,         ."
+    IDS_PS_NON_OLE                        "     ."
+    IDS_PS_UNKNOWN_TYPE                   " "
+    IDS_PS_UNKNOWN_SRC                    " "
+    IDS_PS_UNKNOWN_APP                    ",   "
+}
diff -uHNrp wine-20071130/dlls/oledlg/resource.h wine-20071130e/dlls/oledlg/resource.h
--- wine-20071130/dlls/oledlg/resource.h	2007-12-01 21:14:18.000000000 +0300
+++ wine-20071130e/dlls/oledlg/resource.h	2008-02-04 18:31:20.000000000 +0300
@@ -23,6 +23,9 @@
 #define IDS_BROWSE                      103
 #define IDS_NOTOLEMOD                   104
 #define IDS_NOTOLEMODCAPTION            105
+#define IDS_OBJECT                      2000
+#define IDS_NOOBJECT                    2001
+#define IDS_CONVERTING                  2002
 
 #define UIINSERTOBJECT                  129
 
diff -uHNrp wine-20071130/dlls/oledlg/rsrc.rc wine-20071130e/dlls/oledlg/rsrc.rc
--- wine-20071130/dlls/oledlg/rsrc.rc	2007-12-01 21:14:18.000000000 +0300
+++ wine-20071130e/dlls/oledlg/rsrc.rc	2008-02-04 18:31:20.000000000 +0300
@@ -46,5 +46,6 @@
 #include "oledlg_No.rc"
 #include "oledlg_Pl.rc"
 #include "oledlg_Pt.rc"
+#include "oledlg_Ru.rc"
 #include "oledlg_Sv.rc"
 #include "oledlg_Tr.rc"
diff -uHNrp wine-20071130/dlls/rasapi32/rasapi.c wine-20071130e/dlls/rasapi32/rasapi.c
--- wine-20071130/dlls/rasapi32/rasapi.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/rasapi32/rasapi.c	2008-02-04 18:31:20.000000000 +0300
@@ -149,6 +149,10 @@ DWORD WINAPI RasEnumEntriesW( LPCWSTR Re
 
 DWORD WINAPI RasGetConnectStatusA(HRASCONN hrasconn, LPRASCONNSTATUSA lprasconnstatus)
 {
+    if (!hrasconn) return ERROR_INVALID_HANDLE;
+    if (!lprasconnstatus) return ERROR_UNKNOWN;
+    if ((lprasconnstatus->dwSize != sizeof(RASCONNSTATUSA)) && (lprasconnstatus->dwSize != sizeof(RASCONNSTATUSW)))
+        return ERROR_INVALID_SIZE;
     FIXME("(%p,%p),stub!\n",hrasconn,lprasconnstatus);
     return 0;
 }
diff -uHNrp wine-20071130/dlls/rpcrt4/rpc_server.c wine-20071130e/dlls/rpcrt4/rpc_server.c
--- wine-20071130/dlls/rpcrt4/rpc_server.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/rpcrt4/rpc_server.c	2008-02-04 18:31:20.000000000 +0300
@@ -1072,7 +1072,7 @@ RPC_STATUS WINAPI I_RpcServerStopListeni
  */
 UINT WINAPI I_RpcWindowProc( void *hWnd, UINT Message, UINT wParam, ULONG lParam )
 {
-  FIXME( "(%p,%08x,%08x,%08x): stub\n", hWnd, Message, wParam, lParam );
+  TRACE( "FIXME(%p,%08x,%08x,%08x): stub\n", hWnd, Message, wParam, lParam );
 
   return 0;
 }
diff -uHNrp wine-20071130/dlls/setupapi/fakedll.c wine-20071130e/dlls/setupapi/fakedll.c
--- wine-20071130/dlls/setupapi/fakedll.c	2007-12-01 21:14:20.000000000 +0300
+++ wine-20071130e/dlls/setupapi/fakedll.c	2008-02-04 18:31:20.000000000 +0300
@@ -326,7 +326,7 @@ BOOL create_fake_dll( const WCHAR *name,
         h = CreateFileW( name, GENERIC_WRITE, 0, NULL, CREATE_NEW, 0, NULL );
         if (h == INVALID_HANDLE_VALUE)
         {
-            ERR( "failed to create %s (error=%u)\n", debugstr_w(name), GetLastError() );
+            TRACE( "failed to create %s (error=%u)\n", debugstr_w(name), GetLastError() );
             return FALSE;
         }
     }
diff -uHNrp wine-20071130/dlls/setupapi/install.c wine-20071130e/dlls/setupapi/install.c
--- wine-20071130/dlls/setupapi/install.c	2007-12-01 21:14:20.000000000 +0300
+++ wine-20071130e/dlls/setupapi/install.c	2008-02-04 18:31:20.000000000 +0300
@@ -341,6 +341,19 @@ static BOOL do_reg_operation( HKEY hkey,
         }
         else
         {
+            /*in windows 98 we must expand string before write it to registry*/
+            if ((GetVersion() & 0x80000000) && (type == REG_EXPAND_SZ)) 
+            {
+                WCHAR *new_str;
+                DWORD new_size;
+
+                new_size = ExpandEnvironmentStringsW( str, NULL, 0);
+                new_str = HeapAlloc( GetProcessHeap(), 0, new_size * sizeof(WCHAR));
+                ExpandEnvironmentStringsW( str, new_str, new_size);
+                HeapFree( GetProcessHeap(), 0, str );
+                str = new_str;
+                type = REG_SZ;
+            }
             TRACE( "setting value %s to %s\n", debugstr_w(value), debugstr_w(str) );
             if (str) RegSetValueExW( hkey, value, 0, type, (BYTE *)str, size * sizeof(WCHAR) );
             else RegSetValueExW( hkey, value, 0, type, (const BYTE *)&empty, sizeof(WCHAR) );
diff -uHNrp wine-20071130/dlls/shell32/classes.c wine-20071130e/dlls/shell32/classes.c
--- wine-20071130/dlls/shell32/classes.c	2007-12-01 21:14:16.000000000 +0300
+++ wine-20071130e/dlls/shell32/classes.c	2008-02-04 18:31:20.000000000 +0300
@@ -135,7 +135,7 @@ BOOL HCR_GetDefaultVerbW( HKEY hkeyClass
             return TRUE;
         }
 
-        size=len;
+        size=len*sizeof(szDest[0]);
         *szDest='\0';
         if (!RegQueryValueW(hkeyClass, swShell, szDest, &size) && *szDest)
         {
@@ -187,7 +187,7 @@ BOOL HCR_GetExecuteCommandW( HKEY hkeyCl
             return FALSE;
         ret = FALSE;
 
-        if (HCR_GetDefaultVerbW(hkeyClass, szVerb, sTempVerb, sizeof(sTempVerb)))
+        if (HCR_GetDefaultVerbW(hkeyClass, szVerb, sTempVerb, sizeof(sTempVerb)/sizeof(sTempVerb[0])))
         {
             WCHAR sTemp[MAX_PATH];
             lstrcpyW(sTemp, swShell);
diff -uHNrp wine-20071130/dlls/shell32/Makefile.in wine-20071130e/dlls/shell32/Makefile.in
--- wine-20071130/dlls/shell32/Makefile.in	2007-12-01 21:14:16.000000000 +0300
+++ wine-20071130e/dlls/shell32/Makefile.in	2008-02-04 18:31:20.000000000 +0300
@@ -52,7 +52,7 @@ C_SRCS = \
 	trash.c \
 	xdg.c
 
-RC_SRCS = shres.rc
+RC_SRCS = shres.rc version.rc
 
 C_SRCS16  = shell.c
 RC_SRCS16 = version16.rc
diff -uHNrp wine-20071130/dlls/shell32/shlexec.c wine-20071130e/dlls/shell32/shlexec.c
--- wine-20071130/dlls/shell32/shlexec.c	2007-12-01 21:14:16.000000000 +0300
+++ wine-20071130e/dlls/shell32/shlexec.c	2008-02-04 18:31:20.000000000 +0300
@@ -308,6 +308,9 @@ static UINT_PTR SHELL_ExecuteW(const WCH
     DWORD dwCreationFlags;
     const WCHAR *lpDirectory = NULL;
 
+    WCHAR* t=lpCmd+strlenW(lpCmd)-3;
+    if( t[0]==' ' && t[1]=='\"' && t[2]=='\"') t[0]='\0';
+
     TRACE("Execute %s from directory %s\n", debugstr_w(lpCmd), debugstr_w(psei->lpDirectory));
 
     /* make sure we don't fail the CreateProcess if the calling app passes in
@@ -472,7 +475,7 @@ static UINT SHELL_FindExecutableByOperat
 
     if (RegOpenKeyExW(HKEY_CLASSES_ROOT, filetype, 0, 0x02000000, &hkeyClass))
         return SE_ERR_NOASSOC;
-    if (!HCR_GetDefaultVerbW(hkeyClass, lpOperation, verb, sizeof(verb)))
+    if (!HCR_GetDefaultVerbW(hkeyClass, lpOperation, verb, sizeof(verb)/sizeof(verb[0])))
         return SE_ERR_NOASSOC;
     RegCloseKey(hkeyClass);
 
@@ -1266,7 +1269,7 @@ static LONG ShellExecute_FromContextMenu
         i = 0;
         while ( 1 )
         {
-            r = RegEnumKeyW( hkeycm, i++, szguid, 39 );
+            r = RegEnumKeyW( hkeycm, i++, szguid, sizeof(szguid)/sizeof(szguid[0]) );
             if ( r != ERROR_SUCCESS )
                 break;
 
@@ -1541,7 +1544,8 @@ BOOL SHELL_execute( LPSHELLEXECUTEINFOW 
 
     if (sei_tmp.fMask & unsupportedFlags)
     {
-        FIXME("flags ignored: 0x%08x\n", sei_tmp.fMask & unsupportedFlags);
+        if ((sei_tmp.fMask & unsupportedFlags) != (SEE_MASK_NOASYNC|SEE_MASK_FLAG_NO_UI))
+            FIXME("flags ignored: 0x%08x\n", sei_tmp.fMask & unsupportedFlags);
     }
 
     /* process the IDList */
diff -uHNrp wine-20071130/dlls/shell32/version.rc wine-20071130e/dlls/shell32/version.rc
--- wine-20071130/dlls/shell32/version.rc	2007-12-01 21:14:16.000000000 +0300
+++ wine-20071130e/dlls/shell32/version.rc	2008-02-04 18:31:20.000000000 +0300
@@ -24,4 +24,7 @@
 #define WINE_FILEVERSION WINE_FILEVERSION_MAJOR,WINE_FILEVERSION_MINOR,WINE_FILEVERSION_BUILD,WINE_FILEVERSION_PLATFORMID
 #define WINE_FILENAME_STR "shell32.dll"
 
+#define WINE_PRODUCTVERSION WINE_FILEVERSION
+#define WINE_PRODUCTVERSION_STR WINE_FILENAME_STR
+
 #include <wine/wine_common_ver.rc>
diff -uHNrp wine-20071130/dlls/user32/dialog.c wine-20071130e/dlls/user32/dialog.c
--- wine-20071130/dlls/user32/dialog.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/user32/dialog.c	2008-02-04 18:31:20.000000000 +0300
@@ -918,6 +918,9 @@ static BOOL DIALOG_IsAccelerator( HWND h
         if ((style & (WS_VISIBLE | WS_DISABLED)) == WS_VISIBLE)
         {
             dlgCode = SendMessageW( hwndControl, WM_GETDLGCODE, 0, 0 );
+            if (dlgCode & DLGC_WANTCHARS)
+                break; /* prevent endless loop */
+
             if ( (dlgCode & (DLGC_BUTTON | DLGC_STATIC)) &&
                  GetWindowTextW( hwndControl, buffer, sizeof(buffer)/sizeof(WCHAR) ))
             {
@@ -1183,9 +1186,9 @@ BOOL WINAPI IsDialogMessageW( HWND hwndD
                 }
                 else if (DC_HASDEFID == HIWORD(dw = SendMessageW (hwndDlg, DM_GETDEFID, 0, 0)))
                 {
-                    HWND hwndDef = GetDlgItem(hwndDlg, LOWORD(dw));
+               /*     HWND hwndDef = GetDlgItem(hwndDlg, LOWORD(dw));
                     if (!hwndDef || !IsWindowEnabled(hwndDef))
-                        return TRUE;
+                        return TRUE;*/
                     SendMessageW( hwndDlg, WM_COMMAND, MAKEWPARAM( LOWORD(dw), BN_CLICKED ),
                                     (LPARAM)GetDlgItem(hwndDlg, LOWORD(dw)));
                 }
diff -uHNrp wine-20071130/dlls/user32/edit.c wine-20071130e/dlls/user32/edit.c
--- wine-20071130/dlls/user32/edit.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/user32/edit.c	2008-02-04 18:31:20.000000000 +0300
@@ -4106,6 +4106,7 @@ static void EDIT_WM_ContextMenu(EDITSTAT
 	HMENU popup = GetSubMenu(menu, 0);
 	UINT start = es->selection_start;
 	UINT end = es->selection_end;
+       int ret;
 
 	ORDER_UINT(start, end);
 
@@ -4131,8 +4132,14 @@ static void EDIT_WM_ContextMenu(EDITSTAT
             x = rc.left + (rc.right - rc.left) / 2;
             y = rc.top + (rc.bottom - rc.top) / 2;
         }
+    
+    ret = TrackPopupMenu(popup, TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD, x, y, 0, es->hwndSelf, NULL);
+    
+    if( ret == WM_PASTE)
+        SendMessageW(es->hwndSelf, WM_PASTE, 0, 0);
+    else
+        SendMessageW(es->hwndSelf, WM_COMMAND, ret, 0);
 
-	TrackPopupMenu(popup, TPM_LEFTALIGN | TPM_RIGHTBUTTON, x, y, 0, es->hwndSelf, NULL);
 	DestroyMenu(menu);
 }
 
@@ -4610,6 +4617,11 @@ static LRESULT EDIT_WM_KeyDown(EDITSTATE
  */
 static LRESULT EDIT_WM_KillFocus(EDITSTATE *es)
 {
+    if( GetCapture() == es->hwndSelf )
+    {
+        ReleaseCapture();
+        es->bCaptureState = FALSE;
+    }
 	es->flags &= ~EF_FOCUSED;
 	DestroyCaret();
 	if(!(es->style & ES_NOHIDESEL))
diff -uHNrp wine-20071130/dlls/user32/focus.c wine-20071130e/dlls/user32/focus.c
--- wine-20071130/dlls/user32/focus.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/user32/focus.c	2008-02-04 18:31:20.000000000 +0300
@@ -33,6 +33,8 @@
 #include "wine/server.h"
 #include "wine/debug.h"
 
+#include "wine/etersoft.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(win);
 
 
@@ -114,8 +116,16 @@ static BOOL set_active_window( HWND hwnd
             SendMessageTimeoutW( HWND_BROADCAST, WM_PALETTEISCHANGING, (WPARAM)hwnd, 0,
                                  SMTO_ABORTIFHUNG, 2000, NULL );
 
-        if (!GetPropA( hwnd, "__wine_x11_managed" ))
-            SetWindowPos( hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE );
+        LOADETER_FUNC(etersoft_1version);
+        if ( etersoft_1version && (etersoft_1version() == 8) )
+
+        {
+            if(!GetPropA( hwnd, "__wine_x11_managed" ) )
+                SetWindowPos( hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE /*| SWP_NOACTIVATE*/);
+        }
+        else
+            SetWindowPos( hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE /*| SWP_NOACTIVATE*/);
+            
 
         if (!IsWindow(hwnd)) return FALSE;
     }
diff -uHNrp wine-20071130/dlls/user32/mdi.c wine-20071130e/dlls/user32/mdi.c
--- wine-20071130/dlls/user32/mdi.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/user32/mdi.c	2008-02-04 18:31:20.000000000 +0300
@@ -99,6 +99,7 @@
 #include "controls.h"
 #include "user_private.h"
 #include "wine/debug.h"
+#include "wine/etersoft.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mdi);
 
@@ -528,18 +529,21 @@ static void MDI_SwitchActiveChild( MDICL
 
         if (was_zoomed)
         {
+            ci->hwndChildMaximized = hwndTo;
+            /* maximize new MDI child */
+            ShowWindow( hwndTo, SW_MAXIMIZE );
+            /* activate new MDI child */
+            SetWindowPos( hwndTo, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE| (activate ? 0 : SWP_NOACTIVATE) );
+
             /* restore old MDI child */
             SendMessageW( hwndPrev, WM_SETREDRAW, FALSE, 0 );
             ShowWindow( hwndPrev, SW_RESTORE );
             SendMessageW( hwndPrev, WM_SETREDRAW, TRUE, 0 );
 
-            /* activate new MDI child */
-            SetWindowPos( hwndTo, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE );
-            /* maximize new MDI child */
-            ShowWindow( hwndTo, SW_MAXIMIZE );
+            ci->hwndActiveChild = hwndTo;
         }
-        /* activate new MDI child */
-        SetWindowPos( hwndTo, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | (activate ? 0 : SWP_NOACTIVATE) );
+       else
+            SetWindowPos( hwndTo, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | (activate ? 0 : SWP_NOACTIVATE) );
     }
 }
 
@@ -861,8 +865,11 @@ static BOOL MDI_AugmentFrameMenu( HWND f
                 (LPCWSTR)HBMMENU_MBAR_CLOSE : (LPCWSTR)HBMMENU_MBAR_CLOSE_D );
     AppendMenuW(menu, MF_HELP | MF_BITMAP,
                 SC_RESTORE, (LPCWSTR)HBMMENU_MBAR_RESTORE );
-    AppendMenuW(menu, MF_HELP | MF_BITMAP,
-                SC_MINIMIZE, (LPCWSTR)HBMMENU_MBAR_MINIMIZE ) ;
+
+    LOADETER_FUNC(etersoft_1version);
+    if ( etersoft_1version && (etersoft_1version() != 7) )
+        AppendMenuW(menu, MF_HELP | MF_BITMAP,
+            SC_MINIMIZE, (LPCWSTR)HBMMENU_MBAR_MINIMIZE ) ;
 
     /* The system menu is replaced by the child icon */
     hIcon = (HICON)SendMessageW(hChild, WM_GETICON, ICON_SMALL, 0);
@@ -1145,6 +1152,11 @@ static LRESULT MDIClientWndProc_common( 
             else
             {
                 MDICREATESTRUCTA *csA = (MDICREATESTRUCTA *)lParam;
+
+                LOADETER_FUNC(etersoft_1version);
+                if ( etersoft_1version && (etersoft_1version() == 7) )
+                    csA->style &= ~WS_MINIMIZEBOX;
+
                 child = CreateWindowExA(WS_EX_MDICHILD, csA->szClass,
                                             csA->szTitle, csA->style,
                                             csA->x, csA->y, csA->cx, csA->cy,
diff -uHNrp wine-20071130/dlls/user32/menu.c wine-20071130e/dlls/user32/menu.c
--- wine-20071130/dlls/user32/menu.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/user32/menu.c	2008-02-04 18:31:20.000000000 +0300
@@ -61,6 +61,8 @@
 #include "user_private.h"
 #include "wine/debug.h"
 
+#include "wine/etersoft.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(menu);
 WINE_DECLARE_DEBUG_CHANNEL(accel);
 
@@ -75,6 +77,7 @@ typedef struct {
     UINT fType;			/* Item type. */
     UINT fState;		/* Item state.  */
     UINT_PTR wID;		/* Item id.  */
+    WORD  wMagic;               /* Magic number */
     HMENU hSubMenu;		/* Pop-up menu.  */
     HBITMAP hCheckBit;		/* Bitmap when checked.  */
     HBITMAP hUnCheckBit;	/* Bitmap when unchecked.  */
@@ -170,6 +173,45 @@ typedef struct
 
 #define WIN_ALLOWED_MENU(style) ((style & (WS_CHILD | WS_POPUP)) != WS_CHILD)
 
+#undef USER_HEAP_ALLOC
+#undef USER_HEAP_FREE
+
+static inline HANDLE ETER_HeapAlloc( SIZE_T size )
+{
+    LOADETER_FUNC(etersoft_1version);
+    if ( etersoft_1version && (etersoft_1version() == 7) )
+        return ((HANDLE)HeapAlloc( GetProcessHeap(), 0, (size) ));
+    else 
+        return ((HANDLE)(ULONG_PTR)LOCAL_Alloc( USER_HeapSel, LMEM_FIXED, (size) ));
+}
+
+static inline void ETER_HeapFree( HANDLE handle )
+{
+    LOADETER_FUNC(etersoft_1version);
+    if ( etersoft_1version && (etersoft_1version() == 7) )
+        HeapFree( GetProcessHeap(),0, handle );
+    else 
+        LOCAL_Free( USER_HeapSel, LOWORD(handle) );
+}
+
+static inline LPPOPUPMENU ETER_GetMenu( HMENU hMenu )
+{
+    LOADETER_FUNC(etersoft_1version);
+    if ( etersoft_1version && (etersoft_1version() == 7) )
+        return (LPPOPUPMENU)hMenu;
+    else 
+        return USER_HEAP_LIN_ADDR(hMenu);
+}
+
+#define USER_HEAP_ALLOC(size) \
+            ETER_HeapAlloc( size )
+
+#define USER_HEAP_FREE(handle) \
+            ETER_HeapFree( handle )
+
+#define ETER_GETMENU(menu) \
+            ETER_GetMenu( menu )
+
 static SIZE     menucharsize;
 static UINT     ODitemheight; /* default owner drawn item height */      
 
@@ -291,7 +333,8 @@ static void do_debug_print_menuitem(cons
  */
 static POPUPMENU *MENU_GetMenu(HMENU hMenu)
 {
-    POPUPMENU *menu = USER_HEAP_LIN_ADDR(hMenu);
+    LPPOPUPMENU menu = ETER_GETMENU( hMenu );
+
     if (!menu || menu->wMagic != MENU_MAGIC)
     {
         WARN("invalid menu handle=%p, ptr=%p, magic=%x\n", hMenu, menu, menu? menu->wMagic:0);
@@ -313,6 +356,10 @@ static HMENU get_win_sys_menu( HWND hwnd
     {
         ret = win->hSysMenu;
         WIN_ReleasePtr( win );
+        if (!MENU_GetMenu(ret)) {
+            ERR("Error with win %p, sysmenu %x\n", win, ret);
+            return NULL;
+        }
     }
     return ret;
 }
@@ -419,7 +466,8 @@ static HMENU MENU_CopySysPopup(void)
 
     if( hMenu ) {
         POPUPMENU* menu = MENU_GetMenu(hMenu);
-        menu->wFlags |= MF_SYSMENU | MF_POPUP;
+        if (menu)
+            menu->wFlags |= MF_SYSMENU | MF_POPUP;
 	SetMenuDefaultItem(hMenu, SC_CLOSE, FALSE);
     }
     else
@@ -590,6 +638,7 @@ static MENUITEM *MENU_FindItem( HMENU *h
     if (wFlags & MF_BYPOSITION)
     {
 	if (*nPos >= menu->nItems) return NULL;
+	if (menu->items[*nPos].wMagic != MENU_MAGIC) return NULL;
 	return &menu->items[*nPos];
     }
     else
@@ -644,13 +693,22 @@ UINT MENU_FindSubMenu( HMENU *hmenu, HME
         return NO_SELECTED_ITEM;
     item = menu->items;
     for (i = 0; i < menu->nItems; i++, item++) {
+        if (item->wMagic != MENU_MAGIC) {
+            ERR("Incorrect menu item %d (0x%p) for hmenu=0x%x\n", i, item, *hmenu);
+            break;
+        }
         if(!(item->fType & MF_POPUP)) continue;
         if (item->hSubMenu == hSubTarget) {
             return i;
         }
         else  {
             HMENU hsubmenu = item->hSubMenu;
-            UINT pos = MENU_FindSubMenu( &hsubmenu, hSubTarget );
+            UINT pos;
+            if (hsubmenu == *hmenu) {
+                ERR("Enter to recursion with hmenu=0x%x\n", *hmenu);
+                break;
+            }
+            pos = MENU_FindSubMenu( &hsubmenu, hSubTarget );
             if (pos != NO_SELECTED_ITEM) {
                 *hmenu = hsubmenu;
                 return pos;
@@ -665,6 +723,10 @@ UINT MENU_FindSubMenu( HMENU *hmenu, HME
  */
 static void MENU_FreeItemData( MENUITEM* item )
 {
+    if (item->wMagic != MENU_MAGIC) {
+            ERR("Free incorrect item 0x%p\n", item);
+            return;
+    }
     /* delete text */
     HeapFree( GetProcessHeap(), 0, item->text );
 }
@@ -986,6 +1048,8 @@ static void MENU_CalcItemSize( HDC hdc, 
          * width of a menufont character to the width of an owner-drawn menu. 
          */
         lpitem->rect.right += mis.itemWidth + 2 * menucharsize.cx;
+	if (lpitem->text && strchrW( lpitem->text, '\t' ) != NULL)
+	    lpitem->rect.right += 15 * menucharsize.cx;
         if (menuBar) {
             /* under at least win95 you seem to be given a standard
                height for the menu and the height value is ignored */
@@ -1342,7 +1406,10 @@ static void MENU_DrawMenuItem( HWND hwnd
     RECT bmprc;
 
     debug_print_menuitem("MENU_DrawMenuItem: ", lpitem, "");
-
+    if (!menu) {
+        ERR("broken hmenu, return\n");
+        return;
+    }
     if (!menuBar) {
         BITMAP bmp;
         GetObjectW( get_arrow_bitmap(), sizeof(bmp), &bmp );
@@ -1997,7 +2064,7 @@ static BOOL MENU_SetItemData( MENUITEM *
                                 LPCWSTR str )
 {
     debug_print_menuitem("MENU_SetItemData from: ", item, "");
-    TRACE("flags=%x str=%p\n", flags, str);
+    TRACE("flags=%x str=%p id=0x%x\n", flags, str, id);
 
     if (IS_STRING_ITEM(flags))
     {
@@ -2051,6 +2118,7 @@ static BOOL MENU_SetItemData( MENUITEM *
             item->hSubMenu = 0;
             item->fType = 0;
             item->fState = 0;
+            item->wMagic = 0;
 	    return FALSE;
         }
     }
@@ -2112,7 +2180,7 @@ static MENUITEM *MENU_InsertItem( HMENU 
     TRACE("inserting at %u by pos %u\n", pos, flags & MF_BYPOSITION);
 
     /* Create new items array */
-
+    /* Lav: Why in RemoveMenu we do HeapReAlloc and HeapAlloc here? */
     newItems = HeapAlloc( GetProcessHeap(), 0, sizeof(MENUITEM) * (menu->nItems+1) );
     if (!newItems)
     {
@@ -2129,7 +2197,8 @@ static MENUITEM *MENU_InsertItem( HMENU 
     }
     menu->items = newItems;
     menu->nItems++;
-    memset( &newItems[pos], 0, sizeof(*newItems) );
+    ZeroMemory( &newItems[pos], sizeof(*newItems) );
+    newItems[pos].wMagic = MENU_MAGIC;
     menu->Height = 0; /* force size recalculate */
     return &newItems[pos];
 }
@@ -2290,6 +2359,8 @@ static void MENU_HideSubPopups( HWND hwn
 	} else return;
 
 	submenu = MENU_GetMenu( hsubmenu );
+        if (!submenu)
+            return;
 	MENU_HideSubPopups( hwndOwner, hsubmenu, FALSE );
 	MENU_SelectItem( hwndOwner, hsubmenu, NO_SELECTED_ITEM, sendMenuSelect, 0 );
         DestroyWindow( submenu->hWnd );
@@ -3581,7 +3652,7 @@ DWORD WINAPI CheckMenuItem( HMENU hMenu,
     DWORD ret;
 
     if (!(item = MENU_FindItem( &hMenu, &id, flags ))) return -1;
-    ret = item->fState & MF_CHECKED;
+    ret = item->fState & (MF_CHECKED | MF_UNCHECKED);
     if (flags & MF_CHECKED) item->fState |= MF_CHECKED;
     else item->fState &= ~MF_CHECKED;
     return ret;
@@ -3775,6 +3846,14 @@ BOOL WINAPI InsertMenuW( HMENU hMenu, UI
         return FALSE;
     }
 
+    /* Eterbug # 674 */
+    {
+        POPUPMENU *menu;
+        if ( (menu = MENU_GetMenu(hMenu)) && !item->rect.top && !item->rect.bottom && !item->rect.left && !item->rect.right )
+            DefWindowProcW(menu->hWnd, WM_NCPAINT, 0 ,0);
+
+    }
+
     item->hCheckBit = item->hUnCheckBit = 0;
     return TRUE;
 }
@@ -3839,6 +3918,7 @@ BOOL WINAPI RemoveMenu( HMENU hMenu, UIN
       /* Remove item */
 
     MENU_FreeItemData( item );
+    item->wMagic = 0;
 
     if (--menu->nItems == 0)
     {
@@ -3866,6 +3946,7 @@ BOOL WINAPI RemoveMenu( HMENU hMenu, UIN
 BOOL WINAPI DeleteMenu( HMENU hMenu, UINT nPos, UINT wFlags )
 {
     MENUITEM *item = MENU_FindItem( &hMenu, &nPos, wFlags );
+    TRACE("nPos=%d, item=%p\n", nPos, item);
     if (!item) return FALSE;
     if (item->fType & MF_POPUP) DestroyMenu( item->hSubMenu );
       /* nPos is now the position of the item */
@@ -3974,8 +4055,10 @@ HMENU WINAPI CreateMenu(void)
 {
     HMENU hMenu;
     LPPOPUPMENU menu;
+
     if (!(hMenu = USER_HEAP_ALLOC( sizeof(POPUPMENU) ))) return 0;
-    menu = (LPPOPUPMENU) USER_HEAP_LIN_ADDR(hMenu);
+
+    menu = ETER_GETMENU( hMenu );
 
     ZeroMemory(menu, sizeof(POPUPMENU));
     menu->wMagic = MENU_MAGIC;
@@ -3995,16 +4078,21 @@ BOOL WINAPI DestroyMenu( HMENU hMenu )
 {
     LPPOPUPMENU lppop = MENU_GetMenu(hMenu);
 
-    TRACE("(%p)\n", hMenu);
-
-
     if (!lppop) return FALSE;
+    TRACE("(%p, %x)\n", hMenu, lppop->wFlags);
+
+    if (lppop->hWnd && hMenu == GetMenu(lppop->hWnd))
+    {
+        TRACE("skip used menu destroy\n");
+        return FALSE;
+    }
 
     lppop->wMagic = 0;  /* Mark it as destroyed */
 
     /* DestroyMenu should not destroy system menu popup owner */
     if ((lppop->wFlags & (MF_POPUP | MF_SYSMENU)) == MF_POPUP && lppop->hWnd)
     {
+        //SetWindowLongPtrW( lppop->hWnd, GWLP_ID, 0xAAAA );
         DestroyWindow( lppop->hWnd );
         lppop->hWnd = 0;
     }
@@ -4017,6 +4105,7 @@ BOOL WINAPI DestroyMenu( HMENU hMenu )
         {
             if (item->fType & MF_POPUP) DestroyMenu(item->hSubMenu);
             MENU_FreeItemData( item );
+            item->wMagic = 0;
         }
         HeapFree( GetProcessHeap(), 0, lppop->items );
     }
@@ -4124,7 +4213,7 @@ BOOL MENU_SetMenu( HWND hWnd, HMENU hMen
     hWnd = WIN_GetFullHandle( hWnd );
     if (GetCapture() == hWnd) MENU_SetCapture(0);  /* release the capture */
 
-    if (hMenu != 0)
+    if (hMenu)
     {
         LPPOPUPMENU lpmenu;
 
diff -uHNrp wine-20071130/dlls/user32/message.c wine-20071130e/dlls/user32/message.c
--- wine-20071130/dlls/user32/message.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/user32/message.c	2008-02-04 18:31:20.000000000 +0300
@@ -41,6 +41,9 @@
 #include "controls.h"
 #include "wine/debug.h"
 
+
+#include "wine/etersoft.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(msg);
 WINE_DECLARE_DEBUG_CHANNEL(relay);
 WINE_DECLARE_DEBUG_CHANNEL(key);
@@ -211,6 +214,9 @@ static const unsigned int message_unicod
     SET(WM_PAINTCLIPBOARD) | SET(WM_SIZECLIPBOARD) | SET(WM_ASKCBFORMATNAME)
 };
 
+/* Last message was hardware MOUSEMOVE */
+int etersoft_mousemove;
+
 /* check whether a given message type includes pointers */
 static inline int is_pointer_message( UINT message )
 {
@@ -2074,6 +2080,8 @@ static BOOL peek_message( MSG *msg, HWND
                info.type, info.msg.message,
                (info.type == MSG_WINEVENT) ? "MSG_WINEVENT" : SPY_GetMsgName(info.msg.message, info.msg.hwnd),
                info.msg.hwnd, info.msg.wParam, info.msg.lParam );
+        
+        etersoft_mousemove = info.msg.message;
 
         switch(info.type)
         {
@@ -2173,11 +2181,11 @@ static BOOL peek_message( MSG *msg, HWND
                                    WMCHAR_MAP_RECVMESSAGE );
         reply_message( &info, result, TRUE );
         thread_info->receive_info = old_info;
-    next:
-        HeapFree( GetProcessHeap(), 0, buffer );
 
         /* if some PM_QS* flags were specified, only handle sent messages from now on */
         if (HIWORD(flags)) flags = PM_QS_SENDMESSAGE | LOWORD(flags);
+    next:
+        HeapFree( GetProcessHeap(), 0, buffer );
     }
 }
 
@@ -3427,6 +3435,10 @@ UINT_PTR WINAPI SetTimer( HWND hwnd, UIN
 
     if (proc) winproc = WINPROC_AllocProc( (WNDPROC)proc, NULL );
 
+    LOADETER_FUNC(etersoft_fixtimer);
+    if (etersoft_fixtimer)
+        etersoft_fixtimer(id, &timeout);
+
     SERVER_START_REQ( set_win_timer )
     {
         req->win    = hwnd;
@@ -3443,7 +3455,7 @@ UINT_PTR WINAPI SetTimer( HWND hwnd, UIN
     }
     SERVER_END_REQ;
 
-    TRACE("Added %p %lx %p timeout %d\n", hwnd, id, winproc, timeout );
+    TRACE("Added %p %lx %p timeout %d, returning %x\n", hwnd, id, winproc, timeout, ret );
     return ret;
 }
 
diff -uHNrp wine-20071130/dlls/user32/msgbox.c wine-20071130e/dlls/user32/msgbox.c
--- wine-20071130/dlls/user32/msgbox.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/user32/msgbox.c	2008-02-04 18:31:20.000000000 +0300
@@ -75,7 +75,7 @@ static HFONT MSGBOX_OnInit(HWND hwnd, LP
     MONITORINFO mon_info;
     LPCWSTR lpszText;
     WCHAR buf[256];
-
+ 
     nclm.cbSize = sizeof(nclm);
     SystemParametersInfoW (SPI_GETNONCLIENTMETRICS, 0, &nclm, 0);
     hFont = CreateFontIndirectW (&nclm.lfMessageFont);
@@ -128,10 +128,12 @@ static HFONT MSGBOX_OnInit(HWND hwnd, LP
 	ShowWindow(GetDlgItem(hwnd, IDCANCEL), SW_HIDE);
 	ShowWindow(GetDlgItem(hwnd, IDYES), SW_HIDE);
 	ShowWindow(GetDlgItem(hwnd, IDNO), SW_HIDE);
-	break;
+	EnableMenuItem(GetSystemMenu(hwnd,FALSE),SC_CLOSE, MF_DISABLED);
+ 	break;
     case MB_YESNO:
 	ShowWindow(GetDlgItem(hwnd, IDCANCEL), SW_HIDE);
-	/* fall through */
+	EnableMenuItem(GetSystemMenu(hwnd,FALSE),SC_CLOSE, MF_DISABLED);
+       /* fall through */
     case MB_YESNOCANCEL:
 	ShowWindow(GetDlgItem(hwnd, IDOK), SW_HIDE);
 	ShowWindow(GetDlgItem(hwnd, IDABORT), SW_HIDE);
@@ -311,8 +313,9 @@ static INT_PTR CALLBACK MSGBOX_DlgProc( 
    case WM_COMMAND:
     switch (LOWORD(wParam))
     {
-     case IDOK:
      case IDCANCEL:
+        if(EnableMenuItem(GetSystemMenu(hwnd,FALSE),SC_CLOSE, MF_DISABLED) == MF_DISABLED ) break;
+     case IDOK:
      case IDABORT:
      case IDRETRY:
      case IDIGNORE:
@@ -355,6 +358,11 @@ static INT_PTR CALLBACK MSGBOX_DlgProc( 
  */
 INT WINAPI MessageBoxA(HWND hWnd, LPCSTR text, LPCSTR title, UINT type)
 {
+    if(!strncmp(text,"[ WNetOpenEnum",sizeof(char)*13)) 
+	{
+	TRACE("fixme! %s\n",text);
+	return IDOK;
+	}
     return MessageBoxExA(hWnd, text, title, type, LANG_NEUTRAL);
 }
 
diff -uHNrp wine-20071130/dlls/user32/painting.c wine-20071130e/dlls/user32/painting.c
--- wine-20071130/dlls/user32/painting.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/user32/painting.c	2008-02-04 18:31:20.000000000 +0300
@@ -554,7 +554,7 @@ BOOL WINAPI LockWindowUpdate( HWND hwnd 
      * -mike
      */
 
-    FIXME("(%p), partial stub!\n",hwnd);
+    TRACE("(%p), partial stub!\n",hwnd);
 
     USER_Lock();
     if (lockedWnd)
diff -uHNrp wine-20071130/dlls/user32/static.c wine-20071130e/dlls/user32/static.c
--- wine-20071130/dlls/user32/static.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/user32/static.c	2008-02-04 18:31:20.000000000 +0300
@@ -871,12 +871,6 @@ static void STATIC_PaintBitmapfn(HWND hw
         SelectObject(hMemDC, oldbitmap);
         DeleteDC(hMemDC);
     }
-    else
-    {
-        RECT rcClient;
-        GetClientRect( hwnd, &rcClient );
-        FillRect( hdc, &rcClient, hbrush );
-    }
 }
 
 
diff -uHNrp wine-20071130/dlls/user32/sysparams.c wine-20071130e/dlls/user32/sysparams.c
--- wine-20071130/dlls/user32/sysparams.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/user32/sysparams.c	2008-02-04 18:31:20.000000000 +0300
@@ -264,6 +264,8 @@ static const WCHAR IconTitleFaceName[]= 
 static const WCHAR defPattern[]=                             {'0',' ','0',' ','0',' ','0',' ','0',' ','0',' ','0',' ','0',0};
 static const WCHAR CSu[]=                                    {'%','u',0};
 static const WCHAR CSd[]=                                    {'%','d',0};
+static const WCHAR registry_key[] = {'S','y','s','t','e','m','\\','C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t','\\','H','a','r','d','w','a','r','e',' ','P','r','o','f','i','l','e','s','\\','C','u','r','r','e','n','t','\\','S','o','f','t','w','a','r','e','\\','F','o','n','t','s','\0'};
+static const WCHAR log_pixels[] = { 'L','o','g','P','i','x','e','l','s','\0'};
 
 /* Indicators whether system parameter value is loaded */
 static char spi_loaded[SPI_INDEX_COUNT];
@@ -1051,6 +1053,10 @@ static void load_nonclient_metrics(void)
     HKEY hkey;
     NONCLIENTMETRICSW ncm;
     INT r;
+    DWORD size;
+    DWORD type;
+    HKEY menuhKey;
+    DWORD logpixels;
 
     ncm.cbSize = sizeof (ncm);
     if (RegOpenKeyExW (HKEY_CURRENT_USER, METRICS_REGKEY,
@@ -1086,6 +1092,13 @@ static void load_nonclient_metrics(void)
     ncm.iMenuHeight = get_reg_metric(hkey, METRICS_MENUHEIGHT_VALNAME, 18);
     ncm.iMenuWidth = get_reg_metric(hkey, METRICS_MENUWIDTH_VALNAME, ncm.iMenuHeight);
 
+    size = sizeof (DWORD);
+    RegOpenKeyExW (HKEY_LOCAL_MACHINE, registry_key,
+                       0, KEY_QUERY_VALUE, &menuhKey);
+    if (!RegQueryValueExW (menuhKey, log_pixels, NULL, &type,
+                              (LPBYTE) &logpixels, &size) == ERROR_SUCCESS)
+        logpixels = 96;
+    RegCloseKey( menuhKey );
     /* menu font metrics */
     if (!reg_get_logfont(METRICS_REGKEY, METRICS_MENULOGFONT_VALNAME, &ncm.lfMenuFont))
     {
@@ -1096,6 +1109,7 @@ static void load_nonclient_metrics(void)
         if (r)
             ncm.lfMenuFont.lfHeight = -r;
         ncm.lfMenuFont.lfWeight = FW_NORMAL;
+        ncm.lfMenuFont.lfHeight = MulDiv(ncm.lfMenuFont.lfHeight, logpixels, 96);
     }
 
     /* status bar font metrics */
@@ -1108,6 +1122,7 @@ static void load_nonclient_metrics(void)
         if (r)
             ncm.lfStatusFont.lfHeight = -r;
         ncm.lfStatusFont.lfWeight = FW_NORMAL;
+        ncm.lfStatusFont.lfHeight = MulDiv(ncm.lfStatusFont.lfHeight, logpixels, 96);
     }
 
     /* message font metrics */
@@ -1120,6 +1135,7 @@ static void load_nonclient_metrics(void)
         if (r)
             ncm.lfMessageFont.lfHeight = -r;
         ncm.lfMessageFont.lfWeight = FW_NORMAL;
+        ncm.lfMessageFont.lfHeight = MulDiv(ncm.lfMessageFont.lfHeight, logpixels, 96);
     }
 
     /* some extra fields not in the nonclient structure */
diff -uHNrp wine-20071130/dlls/user32/text.c wine-20071130e/dlls/user32/text.c
--- wine-20071130/dlls/user32/text.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/user32/text.c	2008-02-04 18:31:20.000000000 +0300
@@ -716,7 +716,8 @@ static const WCHAR *TEXT_NextLineW( HDC 
                 /* If we are here after a path ellipsification it must be
                  * because even the ellipsis itself didn't fit.
                  */
-                assert (pellip->under == 0 && pellip->after == 0);
+                if (pellip->under || pellip->after) 
+		    FIXME("pellip: the condition is not executed\n");
                 pellip->before = before;
                 pellip->len = len_ellipsis;
                 /* pellip->after remains as zero as does
diff -uHNrp wine-20071130/dlls/user32/win.c wine-20071130e/dlls/user32/win.c
--- wine-20071130/dlls/user32/win.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/user32/win.c	2008-02-04 18:31:20.000000000 +0300
@@ -1814,13 +1814,36 @@ LONG_PTR WIN_SetWindowLong( HWND hwnd, I
     case GWLP_WNDPROC:
     {
         WNDPROC proc;
+        char classname[80];
         UINT old_flags = wndPtr->flags;
-        retval = WIN_GetWindowLong( hwnd, offset, size, unicode );
-        if (unicode) proc = WINPROC_AllocProc( NULL, (WNDPROC)newval );
-        else proc = WINPROC_AllocProc( (WNDPROC)newval, NULL );
-        if (proc) wndPtr->winproc = proc;
-        if (WINPROC_IsUnicode( proc, unicode )) wndPtr->flags |= WIN_ISUNICODE;
-        else wndPtr->flags &= ~WIN_ISUNICODE;
+
+        if(GetVersion() & 0x80000000)
+        {
+            retval = WIN_GetWindowLong( hwnd, offset, size, unicode );
+            GetClassNameA(hwnd,classname,sizeof classname);
+            TRACE("classname = %s\n",classname);
+            if ( unicode && strcmp(classname,"V8Window") ) 
+                proc = WINPROC_AllocProc( NULL, (WNDPROC)newval );
+            else 
+                proc = WINPROC_AllocProc( (WNDPROC)newval, NULL );
+            if (proc) 
+                wndPtr->winproc = proc;
+            if (WINPROC_IsUnicode( proc, unicode )) 
+                wndPtr->flags |= WIN_ISUNICODE;
+            else 
+                wndPtr->flags &= ~WIN_ISUNICODE;
+        }
+        else
+        {
+            retval = (ULONG_PTR)WINPROC_GetProc( wndPtr->winproc, unicode );
+
+            if (unicode) proc = WINPROC_AllocProc( NULL, (WNDPROC)newval );
+            else proc = WINPROC_AllocProc( (WNDPROC)newval, NULL );
+            if (proc) wndPtr->winproc = proc;
+            if (WINPROC_IsUnicode( proc, unicode )) wndPtr->flags |= WIN_ISUNICODE;
+            else wndPtr->flags &= ~WIN_ISUNICODE;
+        }
+
         if (!((old_flags ^ wndPtr->flags) & WIN_ISUNICODE))
         {
             WIN_ReleasePtr( wndPtr );
@@ -2177,6 +2200,33 @@ LONG WINAPI SetWindowLongW(
     INT offset, /* [in] offset, in bytes, of location to alter */
     LONG newval /* [in] new value of location */
 ) {
+    if (GetVersion()&0x80000000 && offset == GWLP_WNDPROC)
+    {
+         /* CodeWeavers Only Hack... Needed for the Delegates tab 
+          * in Outlook XP running in win98 mode
+          */
+         char class[80];
+         GetClassNameA(hwnd, class, sizeof(class));
+         if (strcmp(class,"REListBox20W")==0)
+         {
+            char name[MAX_PATH], *p;
+            
+            GetModuleFileNameA(GetModuleHandleA(NULL),name,MAX_PATH);
+            p = strrchr(name, '\\');
+
+            if (p)
+                p++;
+            else
+                p = name;
+
+            if (!strcasecmp(p,"OUTLOOK.EXE"))
+            {
+                ERR("Outlook in WIN98 calling supposedly unimplemented function, triggering bandaid for class %s\n",debugstr_a(class));
+                SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+                return 0;
+            }
+         }
+    }
     return WIN_SetWindowLong( hwnd, offset, sizeof(LONG), newval, TRUE );
 }
 
diff -uHNrp wine-20071130/dlls/user32/winpos.c wine-20071130e/dlls/user32/winpos.c
--- wine-20071130/dlls/user32/winpos.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/user32/winpos.c	2008-02-04 18:31:20.000000000 +0300
@@ -154,6 +154,11 @@ UINT WINAPI ArrangeIconicWindows( HWND p
 
 /***********************************************************************
  *		SwitchToThisWindow (USER32.@)
+ * Restore minimized window (undocumented). See SetForegroundWindow also.
+ *
+ * PARAMS
+ *  hwnd    [ I] handle of the window
+ *  restore [ I] TRUE for restore, FALSE for minimize window
  */
 void WINAPI SwitchToThisWindow( HWND hwnd, BOOL restore )
 {
@@ -921,9 +926,24 @@ UINT WINAPI GetInternalWindowPos( HWND h
 
 /***********************************************************************
  *		GetWindowPlacement (USER32.@)
+ * Retrieves the show state and the restored, minimized,
+ * and maximized positions of the window
  *
- * Win95:
- * Fails if wndpl->length of Win95 (!) apps is invalid.
+ * PARAMS
+ *  hwnd  [ I] handle to the window
+ *  wndpl [ I] pointer to the structure that receives the info.
+ *
+ * RETURNS
+ *  TRUE if succeeds
+ *  FALSE if failed (FIXME: use GetLastError for get extended error info)
+ *
+ * NOTES
+ *  set length field in the WINDOWPLACEMENT before calling the function
+ *  Win95:
+ *  Fails if wndpl->length of Win95 (!) apps is invalid.
+ * TODO
+ *  WPF_RESTORETOMAXIMIZED only with SW_SHOWMINIMIZED?
+ *  check with WS_VISIBLE, WS_HIDE
  */
 BOOL WINAPI GetWindowPlacement( HWND hwnd, WINDOWPLACEMENT *wndpl )
 {
@@ -1148,7 +1168,7 @@ void WINPOS_ActivateOtherWindow(HWND hwn
     {
         if (SetForegroundWindow( hwndTo )) return;
     }
-    if (!SetActiveWindow( hwndTo )) SetActiveWindow(0);
+/*    if (!SetActiveWindow( hwndTo )) SetActiveWindow(0); */
 }
 
 
diff -uHNrp wine-20071130/dlls/user32/winproc.c wine-20071130e/dlls/user32/winproc.c
--- wine-20071130/dlls/user32/winproc.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/user32/winproc.c	2008-02-04 18:31:20.000000000 +0300
@@ -38,6 +38,7 @@
 #include "winternl.h"
 #include "wine/unicode.h"
 #include "wine/debug.h"
+#include "wine/etersoft.h"
 
 WINE_DECLARE_DEBUG_CHANNEL(msg);
 WINE_DECLARE_DEBUG_CHANNEL(relay);
@@ -2262,6 +2263,8 @@ LRESULT WINAPI CallWindowProc16( WNDPROC
  *
  *   ECMA-234, Win32
  */
+extern int etersoft_mousemove;
+
 LRESULT WINAPI CallWindowProcA(
     WNDPROC func,  /* [in] window procedure */
     HWND hwnd,     /* [in] target window */
@@ -2271,11 +2274,33 @@ LRESULT WINAPI CallWindowProcA(
 ) {
     WINDOWPROC *proc;
     LRESULT result;
-
+    static UINT oldmsg;
     if (!func) return 0;
+    
+    LOADETER_FUNC(etersoft_fixdefwnd);
+    if (msg ==0x363 && etersoft_fixdefwnd)
+        if (etersoft_fixdefwnd(msg, etersoft_mousemove, oldmsg)) {
+            oldmsg = msg;
+            return 0;
+        }
+    oldmsg = msg;
 
     if (!(proc = handle_to_proc( func )))
+    {
+        char lpszClass[16];
+        WNDPROC awnd = NULL;
+        if (msg==WM_NCDESTROY) {
+            GetClassNameA(hwnd, lpszClass, 16);
+            if (!strcmp(lpszClass, "ListView")) {
+                FIXME("PROCESSING LV's MESSAGE \n");
+                awnd = (WNDPROC)GetClassLongA(hwnd, GCLP_WNDPROC);
+            }
+        }
+        /* Skip recursion */
+        if (func == awnd) return 0;
+
         call_window_proc( hwnd, msg, wParam, lParam, &result, func );
+    }
     else if (proc->procA)
         call_window_proc( hwnd, msg, wParam, lParam, &result, proc->procA );
     else if (proc->procW)
diff -uHNrp wine-20071130/dlls/wined3d/context.c wine-20071130e/dlls/wined3d/context.c
--- wine-20071130/dlls/wined3d/context.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/wined3d/context.c	2008-02-04 18:31:20.000000000 +0300
@@ -856,6 +856,12 @@ void ActivateContext(IWineD3DDeviceImpl 
         context = This->activeContext;
     }
 
+    if(!context)
+    {
+        ERR("The context is nil! Return.\n");
+        return;
+    }
+
     /* Activate the opengl context */
     if(context != This->activeContext) {
         BOOL ret;
diff -uHNrp wine-20071130/dlls/wined3d/surface.c wine-20071130e/dlls/wined3d/surface.c
--- wine-20071130/dlls/wined3d/surface.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/wined3d/surface.c	2008-02-04 18:31:20.000000000 +0300
@@ -2940,7 +2940,7 @@ static HRESULT IWineD3DSurfaceImpl_BltOv
     } else if((dstSwapchain || This == (IWineD3DSurfaceImpl *) myDevice->render_targets[0]) &&
               (srcSwapchain || SrcSurface == myDevice->render_targets[0]) ) {
         ERR("Can't perform hardware blit between 2 different swapchains, falling back to software\n");
-        return WINED3DERR_INVALIDCALL;
+	return WINED3D_OK;
     }
 
     if(srcSwapchain || SrcSurface == myDevice->render_targets[0]) {
diff -uHNrp wine-20071130/dlls/wineps.drv/download.c wine-20071130e/dlls/wineps.drv/download.c
--- wine-20071130/dlls/wineps.drv/download.c	2007-12-01 21:14:14.000000000 +0300
+++ wine-20071130e/dlls/wineps.drv/download.c	2008-02-04 18:31:20.000000000 +0300
@@ -254,10 +254,13 @@ BOOL PSDRV_WriteSetDownloadFont(PSDRV_PD
 	strcpy(pdl->ps_name, ps_name);
 	pdl->next = NULL;
 
+/* Etersoft: Commented due bug in LoadTable and deeper (fix bug #53) */
+#if 0
         if(physDev->pi->ppd->TTRasterizer == RO_Type42) {
 	    pdl->typeinfo.Type42 = T42_download_header(physDev, ps_name, &bbox, emsize);
 	    pdl->type = Type42;
 	}
+#endif
 	if(pdl->typeinfo.Type42 == NULL) {
 	    pdl->typeinfo.Type1 = T1_download_header(physDev, ps_name, &bbox, emsize);
 	    pdl->type = Type1;
diff -uHNrp wine-20071130/dlls/wineps.drv/escape.c wine-20071130e/dlls/wineps.drv/escape.c
--- wine-20071130/dlls/wineps.drv/escape.c	2007-12-01 21:14:14.000000000 +0300
+++ wine-20071130e/dlls/wineps.drv/escape.c	2008-02-04 18:31:20.000000000 +0300
@@ -332,6 +332,9 @@ INT PSDRV_ExtEscape( PSDRV_PDEVICE *phys
 	    return 0;
 	}
       }
+    case 6789:
+        TRACE("Some 1C Unimplemented code 0x%x\n", nEscape);
+        return 0;
     default:
         FIXME("Unimplemented code 0x%x\n", nEscape);
 	return 0;
diff -uHNrp wine-20071130/dlls/wineps.drv/init.c wine-20071130e/dlls/wineps.drv/init.c
--- wine-20071130/dlls/wineps.drv/init.c	2007-12-01 21:14:14.000000000 +0300
+++ wine-20071130e/dlls/wineps.drv/init.c	2008-02-04 18:31:20.000000000 +0300
@@ -334,7 +334,7 @@ BOOL PSDRV_CreateDC( HDC hdc, PSDRV_PDEV
         if(!GetRasterizerCaps(&status, sizeof(status)) ||
            !(status.wFlags & TT_AVAILABLE) ||
            !(status.wFlags & TT_ENABLED)) {
-            MESSAGE("Disabling printer %s since it has no builtin fonts and there are no TrueType fonts available.\n",
+            TRACE("Disabling printer %s since it has no builtin fonts and there are no TrueType fonts available.\n",
                     debugstr_w(device));
             return FALSE;
         }
diff -uHNrp wine-20071130/dlls/wineps.drv/pen.c wine-20071130e/dlls/wineps.drv/pen.c
--- wine-20071130/dlls/wineps.drv/pen.c	2007-12-01 21:14:14.000000000 +0300
+++ wine-20071130e/dlls/wineps.drv/pen.c	2008-02-04 18:31:20.000000000 +0300
@@ -64,7 +64,7 @@ HPEN PSDRV_SelectPen( PSDRV_PDEVICE *phy
     TRACE("hpen = %p colour = %08x\n", hpen, logpen.lopnColor);
 
     physDev->pen.width = logpen.lopnWidth.x;
-    if ((logpen.lopnStyle & PS_GEOMETRIC) || (physDev->pen.width > 1))
+/* FIXME: eterbug#140    if ((logpen.lopnStyle & PS_GEOMETRIC) || (physDev->pen.width > 1)) */
     {
         physDev->pen.width = PSDRV_XWStoDS( physDev, physDev->pen.width );
         if(physDev->pen.width < 0) physDev->pen.width = -physDev->pen.width;
diff -uHNrp wine-20071130/dlls/winex11.drv/clipboard.c wine-20071130e/dlls/winex11.drv/clipboard.c
--- wine-20071130/dlls/winex11.drv/clipboard.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/winex11.drv/clipboard.c	2008-02-04 18:31:20.000000000 +0300
@@ -152,6 +152,7 @@ static HANDLE X11DRV_CLIPBOARD_ImportMet
 static HANDLE X11DRV_CLIPBOARD_ImportXAPIXMAP(Window w, Atom prop);
 static HANDLE X11DRV_CLIPBOARD_ImportXAString(Window w, Atom prop);
 static HANDLE X11DRV_CLIPBOARD_ImportUTF8(Window w, Atom prop);
+static HANDLE X11DRV_CLIPBOARD_ImportUcsString(Window w, Atom prop);
 static HANDLE X11DRV_CLIPBOARD_ImportCompoundText(Window w, Atom prop);
 static HANDLE X11DRV_CLIPBOARD_ExportClipboardData(Window requestor, Atom aTarget,
     Atom rprop, LPWINE_CLIPDATA lpData, LPDWORD lpBytes);
@@ -277,7 +278,9 @@ static WINE_CLIPFORMAT ClipFormats[]  =
         X11DRV_CLIPBOARD_ExportClipboardData, &ClipFormats[20], &ClipFormats[22]},
 
     { CF_DSPENHMETAFILE, wszCF_DSPENHMETAFILE, 0, CF_FLAG_BUILTINFMT, X11DRV_CLIPBOARD_ImportClipboardData,
-        X11DRV_CLIPBOARD_ExportClipboardData, &ClipFormats[21], NULL}
+        X11DRV_CLIPBOARD_ExportClipboardData, &ClipFormats[21], &ClipFormats[23]},
+    { CF_TEXT, wszUTF8STRING, 0, CF_FLAG_BUILTINFMT, X11DRV_CLIPBOARD_ImportUcsString,
+        X11DRV_CLIPBOARD_ExportString, &ClipFormats[22], NULL},
 };
 
 #define GET_ATOM(prop)  (((prop) < FIRST_XATOM) ? (Atom)(prop) : X11DRV_Atoms[(prop) - FIRST_XATOM])
@@ -1130,7 +1133,7 @@ HANDLE X11DRV_CLIPBOARD_ImportXAString(W
     if (!X11DRV_CLIPBOARD_ReadProperty(w, prop, &lpdata, &cbytes))
         return 0;
 
-    for (i = 0; i <= cbytes; i++)
+    for (i = 0; i < cbytes; i++)
     {
         if (lpdata[i] == '\n')
             inlcount++;
@@ -1140,14 +1143,14 @@ HANDLE X11DRV_CLIPBOARD_ImportXAString(W
     {
         lpstr = GlobalLock(hText);
 
-        for (i = 0, inlcount = 0; i <= cbytes; i++)
+        for (i = 0, inlcount = 0; i < cbytes; i++)
         {
             if (lpdata[i] == '\n')
                 lpstr[inlcount++] = '\r';
 
             lpstr[inlcount++] = lpdata[i];
         }
-
+        lpstr[inlcount] = '\0';
         GlobalUnlock(hText);
     }
 
@@ -1174,7 +1177,7 @@ HANDLE X11DRV_CLIPBOARD_ImportUTF8(Windo
     if (!X11DRV_CLIPBOARD_ReadProperty(w, prop, &lpdata, &cbytes))
         return 0;
 
-    for (i = 0; i <= cbytes; i++)
+    for (i = 0; i < cbytes; i++)
     {
         if (lpdata[i] == '\n')
             inlcount++;
@@ -1184,13 +1187,14 @@ HANDLE X11DRV_CLIPBOARD_ImportUTF8(Windo
     {
         UINT count;
 
-        for (i = 0, inlcount = 0; i <= cbytes; i++)
+        for (i = 0, inlcount = 0; i < cbytes; i++)
         {
             if (lpdata[i] == '\n')
                 lpstr[inlcount++] = '\r';
 
             lpstr[inlcount++] = lpdata[i];
         }
+        lpstr[inlcount] = '\0';
 
         count = MultiByteToWideChar(CP_UTF8, 0, lpstr, -1, NULL, 0);
         hUnicodeText = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, count * sizeof(WCHAR));
@@ -1211,6 +1215,36 @@ HANDLE X11DRV_CLIPBOARD_ImportUTF8(Windo
     return hUnicodeText;
 }
 
+/**************************************************************************
+ *      X11DRV_CLIPBOARD_ImportUcsString
+ *
+ * Import UCS string, converting the string to CF_TEXT.
+ */
+HANDLE X11DRV_CLIPBOARD_ImportUcsString(Window w, Atom prop)
+{
+      LPSTR lpstr = NULL;
+      int   len;
+      HANDLE hText;
+      LPWSTR lpstrW;
+
+      hText = X11DRV_CLIPBOARD_ImportUTF8(w, prop);
+      lpstrW = GlobalLock(hText);
+
+      if (lpstrW)
+      {
+         len = WideCharToMultiByte(CP_ACP, 0, lpstrW, -1, NULL, 0, NULL, NULL);
+         lpstr = HeapAlloc(GetProcessHeap(), 0, sizeof(char) * (len) );
+         WideCharToMultiByte(CP_ACP, 0, lpstrW, -1, lpstr, len, NULL, NULL);
+         if(strlenW(lpstrW) >= strlen(lpstr))
+            strcpy((LPSTR)lpstrW, lpstr);
+         else
+            ERR("WCHAR buffer overfloat(%p)!\n", lpstrW);
+         HeapFree(GetProcessHeap(), 0, lpstr);
+         GlobalUnlock(hText);
+      }
+
+      return hText;
+}
 
 /**************************************************************************
  *		X11DRV_CLIPBOARD_ImportCompoundText
diff -uHNrp wine-20071130/dlls/winex11.drv/event.c wine-20071130e/dlls/winex11.drv/event.c
--- wine-20071130/dlls/winex11.drv/event.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/winex11.drv/event.c	2008-02-04 18:31:20.000000000 +0300
@@ -548,7 +548,7 @@ static void EVENT_FocusOut( HWND hwnd, X
         XUnsetICFocus( xic );
         wine_tsx11_unlock();
     }
-    if (hwnd != GetForegroundWindow()) return;
+    /* if (hwnd != GetForegroundWindow()) return;*/
     SendMessageW( hwnd, WM_CANCELMODE, 0, 0 );
 
     /* don't reset the foreground window, if the window which is
@@ -574,6 +574,8 @@ static void EVENT_FocusOut( HWND hwnd, X
             TRACE( "lost focus, setting fg to desktop\n" );
             SetForegroundWindow( GetDesktopWindow() );
         }
+        else
+            SetActiveWindow( hwnd );
     }
 }
 
diff -uHNrp wine-20071130/dlls/winex11.drv/keyboard.c wine-20071130e/dlls/winex11.drv/keyboard.c
--- wine-20071130/dlls/winex11.drv/keyboard.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/winex11.drv/keyboard.c	2008-02-04 18:31:20.000000000 +0300
@@ -92,6 +92,8 @@ static int NumLockMask, AltGrMask; /* ma
 
 static char KEYBOARD_MapDeadKeysym(KeySym keysym);
 
+extern KeySym X11DRV_ucs2keysym(WCHAR wChar);
+
 /* Keyboard translation tables */
 #define MAIN_LEN 49
 static const WORD main_key_scan_qwerty[MAIN_LEN] =
@@ -1011,7 +1013,7 @@ static const WORD nonchar_key_vkey[256] 
     VK_END, VK_CLEAR, VK_INSERT, VK_DELETE,
     0, 0, 0, 0, 0, 0, 0, 0,                                     /* FFA0 */
     0, 0, VK_MULTIPLY, VK_ADD,                                  /* FFA8 */
-    VK_SEPARATOR, VK_SUBTRACT, VK_DECIMAL, VK_DIVIDE,
+    VK_DECIMAL, VK_SUBTRACT, VK_DECIMAL, VK_DIVIDE,
     VK_NUMPAD0, VK_NUMPAD1, VK_NUMPAD2, VK_NUMPAD3,             /* FFB0 */
     VK_NUMPAD4, VK_NUMPAD5, VK_NUMPAD6, VK_NUMPAD7,
     VK_NUMPAD8, VK_NUMPAD9, 0, 0, 0, VK_OEM_NEC_EQUAL,          /* FFB8 */
@@ -1931,7 +1933,7 @@ BOOL X11DRV_GetKeyboardLayoutName(LPWSTR
  */
 HKL X11DRV_LoadKeyboardLayout(LPCWSTR name, UINT flags)
 {
-    FIXME("%s, %04x: stub!\n", debugstr_w(name), flags);
+    TRACE("%s, %04x: stub!\n", debugstr_w(name), flags);
     SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
     return 0;
 }
@@ -1942,7 +1944,7 @@ HKL X11DRV_LoadKeyboardLayout(LPCWSTR na
  */
 BOOL X11DRV_UnloadKeyboardLayout(HKL hkl)
 {
-    FIXME("%p: stub!\n", hkl);
+    TRACE("%p: stub!\n", hkl);
     SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
     return FALSE;
 }
@@ -1953,7 +1955,7 @@ BOOL X11DRV_UnloadKeyboardLayout(HKL hkl
  */
 HKL X11DRV_ActivateKeyboardLayout(HKL hkl, UINT flags)
 {
-    FIXME("%p, %04x: stub!\n", hkl, flags);
+    TRACE("%p, %04x: stub!\n", hkl, flags);
     SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
     return 0;
 }
@@ -1989,23 +1991,10 @@ SHORT X11DRV_VkKeyScanEx(WCHAR wChar, HK
     KeyCode keycode;
     KeySym keysym;
     int i, index;
-    CHAR cChar;
     SHORT ret;
 
-    /* FIXME: what happens if wChar is not a Latin1 character and CP_UNIXCP
-     * is UTF-8 (multibyte encoding)?
-     */
-    if (!WideCharToMultiByte(CP_UNIXCP, 0, &wChar, 1, &cChar, 1, NULL, NULL))
-    {
-        WARN("no translation from unicode to CP_UNIXCP for 0x%02x\n", wChar);
-        return -1;
-    }
-
-    TRACE("wChar 0x%02x -> cChar '%c'\n", wChar, cChar);
-
-    /* char->keysym (same for ANSI chars) */
-    keysym = (unsigned char)cChar; /* (!) cChar is signed */
-    if (keysym <= 27) keysym += 0xFF00; /* special chars : return, backspace... */
+    /* TODO: We should find more correct way to execute this conversion. */
+    keysym = X11DRV_ucs2keysym(wChar);
 
     wine_tsx11_lock();
     keycode = XKeysymToKeycode(display, keysym);  /* keysym -> keycode */
@@ -2013,7 +2002,7 @@ SHORT X11DRV_VkKeyScanEx(WCHAR wChar, HK
     {
         if (keysym >= 0xFF00) /* Windows returns 0x0240 + cChar in this case */
         {
-            ret = 0x0240 + cChar; /* 0x0200 indicates a control character */
+            ret = 0x0240 + wChar; /* 0x0200 indicates a control character */
             TRACE(" ... returning ctrl char %#.2x\n", ret);
             wine_tsx11_unlock();
             return ret;
@@ -2024,15 +2013,15 @@ SHORT X11DRV_VkKeyScanEx(WCHAR wChar, HK
     }
     wine_tsx11_unlock();
 
-    TRACE("'%c'(%#lx, %lu): got keycode %#.2x (%d)\n",
-            cChar, keysym, keysym, keycode, keycode);
+    TRACE("'0x%02x'(%#lx, %lu): got keycode %#.2x (%d)\n",
+            wChar, keysym, keysym, keycode, keycode);
 
     /* keycode -> (keyc2vkey) vkey */
     ret = keyc2vkey[keycode];
 
     if (!keycode || !ret)
     {
-        TRACE("keycode for '%c' not found, returning -1\n", cChar);
+        TRACE("keycode for '0x%02x' not found, returning -1\n", wChar);
         return -1;
     }
 
@@ -2515,6 +2504,15 @@ INT X11DRV_ToUnicodeEx(UINT virtKey, UIN
             goto found;
         }
 #endif
+        /* An ugly hack for NumeroSign: X can't translate it to a character
+           for koi8-r locale. */
+        if (keysym == XK_numerosign )
+        {
+            bufW[0] = 0x2116;
+            ret = 1;
+            goto found;
+        }
+
         /* Special case: X turns shift-tab into ISO_Left_Tab. */
         /* Here we change it back. */
         if (keysym == XK_ISO_Left_Tab)
diff -uHNrp wine-20071130/dlls/winex11.drv/Makefile.in wine-20071130e/dlls/winex11.drv/Makefile.in
--- wine-20071130/dlls/winex11.drv/Makefile.in	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/winex11.drv/Makefile.in	2008-02-04 18:31:20.000000000 +0300
@@ -42,7 +42,8 @@ C_SRCS = \
 	xinerama.c \
 	xrandr.c \
 	xrender.c \
-	xvidmode.c
+	xvidmode.c \
+	ucs2keysym.c 
 
 RC_SRCS = version.rc
 
diff -uHNrp wine-20071130/dlls/winex11.drv/opengl.c wine-20071130e/dlls/winex11.drv/opengl.c
--- wine-20071130/dlls/winex11.drv/opengl.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/winex11.drv/opengl.c	2008-02-04 18:31:20.000000000 +0300
@@ -281,7 +281,8 @@ MAKE_FUNCPTR(glFlush)
 static BOOL X11DRV_WineGL_InitOpenglInfo(void)
 {
     static BOOL infoInitialized = FALSE;
-
+    int opcode, event, error;
+    int attr_rgba[] = { GLX_RGBA, None };
     int screen = DefaultScreen(gdi_display);
     Window win = RootWindow(gdi_display, screen);
     Visual *visual;
@@ -296,6 +297,22 @@ static BOOL X11DRV_WineGL_InitOpenglInfo
 
     wine_tsx11_lock();
 
+    /* Check if GLX extension missed on our X server */
+    if (!XQueryExtension(gdi_display, "GLX", &opcode, &event, &error)) {
+        TRACE(" GLX extension is missed\n");
+        wine_tsx11_unlock();
+        return FALSE;
+    }
+
+    /* Precheck due segfault in glXCreateContext with Xfvb as X server */
+    vis = pglXChooseVisual( gdi_display, screen, attr_rgba );
+    if (!vis) {
+        ERR(" couldn't get an RGB visual, expect problems\n");
+        wine_tsx11_unlock();
+        return FALSE;
+    } else
+        XFree(vis);
+
     visual = DefaultVisual(gdi_display, screen);
     template.visualid = XVisualIDFromVisual(visual);
     vis = XGetVisualInfo(gdi_display, VisualIDMask, &template, &num);
@@ -1653,7 +1670,7 @@ PROC X11DRV_wglGetProcAddress(LPCSTR lps
         padding = 0;
 
     if (!has_opengl()) {
-        ERR("No libGL on this box - disabling OpenGL support !\n");
+        TRACE("No libGL on this box - disabling OpenGL support !\n");
         return 0;
     }
 
diff -uHNrp wine-20071130/dlls/winex11.drv/ucs2keysym.c wine-20071130e/dlls/winex11.drv/ucs2keysym.c
--- wine-20071130/dlls/winex11.drv/ucs2keysym.c	1970-01-01 03:00:00.000000000 +0300
+++ wine-20071130e/dlls/winex11.drv/ucs2keysym.c	2008-02-04 18:31:20.000000000 +0300
@@ -0,0 +1,830 @@
+/*
+ * This module converts the corresponding ISO 10646 (UCS, Unicode) values
+ * into keysym values.
+ * 
+ * The array keysymtab[] contains pairs of Unicode value values for graphical
+ * characters and the corresponding X11 keysym. The function
+ * ucs2keysym() maps Unicode a  onto a keysym value using a binary search,
+ * therefore keysymtab[] must remain SORTED by Unicode value.
+ *
+ * Author of keysymtab[]: Markus G. Kuhn <mkuhn@acm.org>, University of Cambridge, April 2001
+ * 
+ * Special thanks to Richard Verhoeven <river@win.tue.nl> for preparing
+ * an initial draft of the mapping table.
+ *
+ * This software is in the public domain. Share and enjoy!
+ *
+ */
+
+#include <X11/Xutil.h>
+#include "wine/winuser16.h"
+
+static const struct codepair {
+unsigned short keysym;
+  unsigned short ucs;
+} keysymtab[] = {
+
+  { 0x0ba3, 0x003c }, /*                   leftcaret < LESS-THAN SIGN */
+  { 0x0ba6, 0x003e }, /*                  rightcaret > GREATER-THAN SIGN */
+  { 0x0bc6, 0x005f }, /*                    underbar _ LOW LINE */
+  { 0x0bc0, 0x00af }, /*                     overbar ? MACRON */
+  { 0x03c0, 0x0100 }, /*                     Amacron ? LATIN CAPITAL LETTER A WITH MACRON */
+  { 0x03e0, 0x0101 }, /*                     amacron ? LATIN SMALL LETTER A WITH MACRON */
+  { 0x01c3, 0x0102 }, /*                      Abreve ? LATIN CAPITAL LETTER A WITH BREVE */
+  { 0x01e3, 0x0103 }, /*                      abreve ? LATIN SMALL LETTER A WITH BREVE */
+  { 0x01a1, 0x0104 }, /*                     Aogonek ? LATIN CAPITAL LETTER A WITH OGONEK */
+  { 0x01b1, 0x0105 }, /*                     aogonek ? LATIN SMALL LETTER A WITH OGONEK */
+  { 0x01c6, 0x0106 }, /*                      Cacute ? LATIN CAPITAL LETTER C WITH ACUTE */
+  { 0x01e6, 0x0107 }, /*                      cacute ? LATIN SMALL LETTER C WITH ACUTE */
+  { 0x02c6, 0x0108 }, /*                 Ccircumflex ? LATIN CAPITAL LETTER C WITH CIRCUMFLEX */
+  { 0x02e6, 0x0109 }, /*                 ccircumflex ? LATIN SMALL LETTER C WITH CIRCUMFLEX */
+  { 0x02c5, 0x010a }, /*                   Cabovedot ? LATIN CAPITAL LETTER C WITH DOT ABOVE */
+  { 0x02e5, 0x010b }, /*                   cabovedot ? LATIN SMALL LETTER C WITH DOT ABOVE */
+  { 0x01c8, 0x010c }, /*                      Ccaron ? LATIN CAPITAL LETTER C WITH CARON */
+  { 0x01e8, 0x010d }, /*                      ccaron ? LATIN SMALL LETTER C WITH CARON */
+  { 0x01cf, 0x010e }, /*                      Dcaron ? LATIN CAPITAL LETTER D WITH CARON */
+  { 0x01ef, 0x010f }, /*                      dcaron ? LATIN SMALL LETTER D WITH CARON */
+  { 0x01d0, 0x0110 }, /*                     Dstroke ? LATIN CAPITAL LETTER D WITH STROKE */
+  { 0x01f0, 0x0111 }, /*                     dstroke ? LATIN SMALL LETTER D WITH STROKE */
+  { 0x03aa, 0x0112 }, /*                     Emacron ? LATIN CAPITAL LETTER E WITH MACRON */
+  { 0x03ba, 0x0113 }, /*                     emacron ? LATIN SMALL LETTER E WITH MACRON */
+  { 0x03cc, 0x0116 }, /*                   Eabovedot ? LATIN CAPITAL LETTER E WITH DOT ABOVE */
+  { 0x03ec, 0x0117 }, /*                   eabovedot ? LATIN SMALL LETTER E WITH DOT ABOVE */
+  { 0x01ca, 0x0118 }, /*                     Eogonek ? LATIN CAPITAL LETTER E WITH OGONEK */
+  { 0x01ea, 0x0119 }, /*                     eogonek ? LATIN SMALL LETTER E WITH OGONEK */
+  { 0x01cc, 0x011a }, /*                      Ecaron ? LATIN CAPITAL LETTER E WITH CARON */
+  { 0x01ec, 0x011b }, /*                      ecaron ? LATIN SMALL LETTER E WITH CARON */
+  { 0x02d8, 0x011c }, /*                 Gcircumflex ? LATIN CAPITAL LETTER G WITH CIRCUMFLEX */
+  { 0x02f8, 0x011d }, /*                 gcircumflex ? LATIN SMALL LETTER G WITH CIRCUMFLEX */
+  { 0x02ab, 0x011e }, /*                      Gbreve ? LATIN CAPITAL LETTER G WITH BREVE */
+  { 0x02bb, 0x011f }, /*                      gbreve ? LATIN SMALL LETTER G WITH BREVE */
+  { 0x02d5, 0x0120 }, /*                   Gabovedot ? LATIN CAPITAL LETTER G WITH DOT ABOVE */
+  { 0x02f5, 0x0121 }, /*                   gabovedot ? LATIN SMALL LETTER G WITH DOT ABOVE */
+  { 0x03ab, 0x0122 }, /*                    Gcedilla ? LATIN CAPITAL LETTER G WITH CEDILLA */
+  { 0x03bb, 0x0123 }, /*                    gcedilla ? LATIN SMALL LETTER G WITH CEDILLA */
+  { 0x02a6, 0x0124 }, /*                 Hcircumflex ? LATIN CAPITAL LETTER H WITH CIRCUMFLEX */
+  { 0x02b6, 0x0125 }, /*                 hcircumflex ? LATIN SMALL LETTER H WITH CIRCUMFLEX */
+  { 0x02a1, 0x0126 }, /*                     Hstroke ? LATIN CAPITAL LETTER H WITH STROKE */
+  { 0x02b1, 0x0127 }, /*                     hstroke ? LATIN SMALL LETTER H WITH STROKE */
+  { 0x03a5, 0x0128 }, /*                      Itilde ? LATIN CAPITAL LETTER I WITH TILDE */
+  { 0x03b5, 0x0129 }, /*                      itilde ? LATIN SMALL LETTER I WITH TILDE */
+  { 0x03cf, 0x012a }, /*                     Imacron ? LATIN CAPITAL LETTER I WITH MACRON */
+  { 0x03ef, 0x012b }, /*                     imacron ? LATIN SMALL LETTER I WITH MACRON */
+  { 0x03c7, 0x012e }, /*                     Iogonek ? LATIN CAPITAL LETTER I WITH OGONEK */
+  { 0x03e7, 0x012f }, /*                     iogonek ? LATIN SMALL LETTER I WITH OGONEK */
+  { 0x02a9, 0x0130 }, /*                   Iabovedot ? LATIN CAPITAL LETTER I WITH DOT ABOVE */
+  { 0x02b9, 0x0131 }, /*                    idotless ? LATIN SMALL LETTER DOTLESS I */
+  { 0x02ac, 0x0134 }, /*                 Jcircumflex ? LATIN CAPITAL LETTER J WITH CIRCUMFLEX */
+  { 0x02bc, 0x0135 }, /*                 jcircumflex ? LATIN SMALL LETTER J WITH CIRCUMFLEX */
+  { 0x03d3, 0x0136 }, /*                    Kcedilla ? LATIN CAPITAL LETTER K WITH CEDILLA */
+  { 0x03f3, 0x0137 }, /*                    kcedilla ? LATIN SMALL LETTER K WITH CEDILLA */
+  { 0x03a2, 0x0138 }, /*                         kra ? LATIN SMALL LETTER KRA */
+  { 0x01c5, 0x0139 }, /*                      Lacute ? LATIN CAPITAL LETTER L WITH ACUTE */
+  { 0x01e5, 0x013a }, /*                      lacute ? LATIN SMALL LETTER L WITH ACUTE */
+  { 0x03a6, 0x013b }, /*                    Lcedilla ? LATIN CAPITAL LETTER L WITH CEDILLA */
+  { 0x03b6, 0x013c }, /*                    lcedilla ? LATIN SMALL LETTER L WITH CEDILLA */
+  { 0x01a5, 0x013d }, /*                      Lcaron ? LATIN CAPITAL LETTER L WITH CARON */
+  { 0x01b5, 0x013e }, /*                      lcaron ? LATIN SMALL LETTER L WITH CARON */
+  { 0x01a3, 0x0141 }, /*                     Lstroke ? LATIN CAPITAL LETTER L WITH STROKE */
+  { 0x01b3, 0x0142 }, /*                     lstroke ? LATIN SMALL LETTER L WITH STROKE */
+  { 0x01d1, 0x0143 }, /*                      Nacute ? LATIN CAPITAL LETTER N WITH ACUTE */
+  { 0x01f1, 0x0144 }, /*                      nacute ? LATIN SMALL LETTER N WITH ACUTE */
+  { 0x03d1, 0x0145 }, /*                    Ncedilla ? LATIN CAPITAL LETTER N WITH CEDILLA */
+  { 0x03f1, 0x0146 }, /*                    ncedilla ? LATIN SMALL LETTER N WITH CEDILLA */
+  { 0x01d2, 0x0147 }, /*                      Ncaron ? LATIN CAPITAL LETTER N WITH CARON */
+  { 0x01f2, 0x0148 }, /*                      ncaron ? LATIN SMALL LETTER N WITH CARON */
+  { 0x03bd, 0x014a }, /*                         ENG ? LATIN CAPITAL LETTER ENG */
+  { 0x03bf, 0x014b }, /*                         eng ? LATIN SMALL LETTER ENG */
+  { 0x03d2, 0x014c }, /*                     Omacron ? LATIN CAPITAL LETTER O WITH MACRON */
+  { 0x03f2, 0x014d }, /*                     omacron ? LATIN SMALL LETTER O WITH MACRON */
+  { 0x01d5, 0x0150 }, /*                Odoubleacute ? LATIN CAPITAL LETTER O WITH DOUBLE ACUTE */
+  { 0x01f5, 0x0151 }, /*                odoubleacute ? LATIN SMALL LETTER O WITH DOUBLE ACUTE */
+  { 0x13bc, 0x0152 }, /*                          OE ? LATIN CAPITAL LIGATURE OE */
+  { 0x13bd, 0x0153 }, /*                          oe ? LATIN SMALL LIGATURE OE */
+  { 0x01c0, 0x0154 }, /*                      Racute ? LATIN CAPITAL LETTER R WITH ACUTE */
+  { 0x01e0, 0x0155 }, /*                      racute ? LATIN SMALL LETTER R WITH ACUTE */
+  { 0x03a3, 0x0156 }, /*                    Rcedilla ? LATIN CAPITAL LETTER R WITH CEDILLA */
+  { 0x03b3, 0x0157 }, /*                    rcedilla ? LATIN SMALL LETTER R WITH CEDILLA */
+  { 0x01d8, 0x0158 }, /*                      Rcaron ? LATIN CAPITAL LETTER R WITH CARON */
+  { 0x01f8, 0x0159 }, /*                      rcaron ? LATIN SMALL LETTER R WITH CARON */
+  { 0x01a6, 0x015a }, /*                      Sacute ? LATIN CAPITAL LETTER S WITH ACUTE */
+  { 0x01b6, 0x015b }, /*                      sacute ? LATIN SMALL LETTER S WITH ACUTE */
+  { 0x02de, 0x015c }, /*                 Scircumflex ? LATIN CAPITAL LETTER S WITH CIRCUMFLEX */
+  { 0x02fe, 0x015d }, /*                 scircumflex ? LATIN SMALL LETTER S WITH CIRCUMFLEX */
+  { 0x01aa, 0x015e }, /*                    Scedilla ? LATIN CAPITAL LETTER S WITH CEDILLA */
+  { 0x01ba, 0x015f }, /*                    scedilla ? LATIN SMALL LETTER S WITH CEDILLA */
+  { 0x01a9, 0x0160 }, /*                      Scaron ? LATIN CAPITAL LETTER S WITH CARON */
+  { 0x01b9, 0x0161 }, /*                      scaron ? LATIN SMALL LETTER S WITH CARON */
+  { 0x01de, 0x0162 }, /*                    Tcedilla ? LATIN CAPITAL LETTER T WITH CEDILLA */
+  { 0x01fe, 0x0163 }, /*                    tcedilla ? LATIN SMALL LETTER T WITH CEDILLA */
+  { 0x01ab, 0x0164 }, /*                      Tcaron ? LATIN CAPITAL LETTER T WITH CARON */
+  { 0x01bb, 0x0165 }, /*                      tcaron ? LATIN SMALL LETTER T WITH CARON */
+  { 0x03ac, 0x0166 }, /*                      Tslash ? LATIN CAPITAL LETTER T WITH STROKE */
+  { 0x03bc, 0x0167 }, /*                      tslash ? LATIN SMALL LETTER T WITH STROKE */
+  { 0x03dd, 0x0168 }, /*                      Utilde ? LATIN CAPITAL LETTER U WITH TILDE */
+  { 0x03fd, 0x0169 }, /*                      utilde ? LATIN SMALL LETTER U WITH TILDE */
+  { 0x03de, 0x016a }, /*                     Umacron ? LATIN CAPITAL LETTER U WITH MACRON */
+  { 0x03fe, 0x016b }, /*                     umacron ? LATIN SMALL LETTER U WITH MACRON */
+  { 0x02dd, 0x016c }, /*                      Ubreve ? LATIN CAPITAL LETTER U WITH BREVE */
+  { 0x02fd, 0x016d }, /*                      ubreve ? LATIN SMALL LETTER U WITH BREVE */
+  { 0x01d9, 0x016e }, /*                       Uring ? LATIN CAPITAL LETTER U WITH RING ABOVE */
+  { 0x01f9, 0x016f }, /*                       uring ? LATIN SMALL LETTER U WITH RING ABOVE */
+  { 0x01db, 0x0170 }, /*                Udoubleacute ? LATIN CAPITAL LETTER U WITH DOUBLE ACUTE */
+  { 0x01fb, 0x0171 }, /*                udoubleacute ? LATIN SMALL LETTER U WITH DOUBLE ACUTE */
+  { 0x03d9, 0x0172 }, /*                     Uogonek ? LATIN CAPITAL LETTER U WITH OGONEK */
+  { 0x03f9, 0x0173 }, /*                     uogonek ? LATIN SMALL LETTER U WITH OGONEK */
+  { 0x13be, 0x0178 }, /*                  Ydiaeresis ? LATIN CAPITAL LETTER Y WITH DIAERESIS */
+  { 0x01ac, 0x0179 }, /*                      Zacute ? LATIN CAPITAL LETTER Z WITH ACUTE */
+  { 0x01bc, 0x017a }, /*                      zacute ? LATIN SMALL LETTER Z WITH ACUTE */
+  { 0x01af, 0x017b }, /*                   Zabovedot ? LATIN CAPITAL LETTER Z WITH DOT ABOVE */
+  { 0x01bf, 0x017c }, /*                   zabovedot ? LATIN SMALL LETTER Z WITH DOT ABOVE */
+  { 0x01ae, 0x017d }, /*                      Zcaron ? LATIN CAPITAL LETTER Z WITH CARON */
+  { 0x01be, 0x017e }, /*                      zcaron ? LATIN SMALL LETTER Z WITH CARON */
+  { 0x08f6, 0x0192 }, /*                    function ? LATIN SMALL LETTER F WITH HOOK */
+  { 0x01b7, 0x02c7 }, /*                       caron ? CARON */
+  { 0x01a2, 0x02d8 }, /*                       breve ? BREVE */
+  { 0x01ff, 0x02d9 }, /*                    abovedot ? DOT ABOVE */
+  { 0x01b2, 0x02db }, /*                      ogonek ? OGONEK */
+  { 0x01bd, 0x02dd }, /*                 doubleacute ? DOUBLE ACUTE ACCENT */
+  { 0x07ae, 0x0385 }, /*        Greek_accentdieresis ? GREEK DIALYTIKA TONOS */
+  { 0x07a1, 0x0386 }, /*           Greek_ALPHAaccent ? GREEK CAPITAL LETTER ALPHA WITH TONOS */
+  { 0x07a2, 0x0388 }, /*         Greek_EPSILONaccent ? GREEK CAPITAL LETTER EPSILON WITH TONOS */
+  { 0x07a3, 0x0389 }, /*             Greek_ETAaccent ? GREEK CAPITAL LETTER ETA WITH TONOS */
+  { 0x07a4, 0x038a }, /*            Greek_IOTAaccent ? GREEK CAPITAL LETTER IOTA WITH TONOS */
+  { 0x07a7, 0x038c }, /*         Greek_OMICRONaccent ? GREEK CAPITAL LETTER OMICRON WITH TONOS */
+  { 0x07a8, 0x038e }, /*         Greek_UPSILONaccent ? GREEK CAPITAL LETTER UPSILON WITH TONOS */
+  { 0x07ab, 0x038f }, /*           Greek_OMEGAaccent ? GREEK CAPITAL LETTER OMEGA WITH TONOS */
+  { 0x07b6, 0x0390 }, /*    Greek_iotaaccentdieresis ? GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */
+  { 0x07c1, 0x0391 }, /*                 Greek_ALPHA ? GREEK CAPITAL LETTER ALPHA */
+  { 0x07c2, 0x0392 }, /*                  Greek_BETA ? GREEK CAPITAL LETTER BETA */
+  { 0x07c3, 0x0393 }, /*                 Greek_GAMMA ? GREEK CAPITAL LETTER GAMMA */
+  { 0x07c4, 0x0394 }, /*                 Greek_DELTA ? GREEK CAPITAL LETTER DELTA */
+  { 0x07c5, 0x0395 }, /*               Greek_EPSILON ? GREEK CAPITAL LETTER EPSILON */
+  { 0x07c6, 0x0396 }, /*                  Greek_ZETA ? GREEK CAPITAL LETTER ZETA */
+  { 0x07c7, 0x0397 }, /*                   Greek_ETA ? GREEK CAPITAL LETTER ETA */
+  { 0x07c8, 0x0398 }, /*                 Greek_THETA ? GREEK CAPITAL LETTER THETA */
+  { 0x07c9, 0x0399 }, /*                  Greek_IOTA ? GREEK CAPITAL LETTER IOTA */
+  { 0x07ca, 0x039a }, /*                 Greek_KAPPA ? GREEK CAPITAL LETTER KAPPA */
+  { 0x07cb, 0x039b }, /*                Greek_LAMBDA ? GREEK CAPITAL LETTER LAMDA */
+  { 0x07cc, 0x039c }, /*                    Greek_MU ? GREEK CAPITAL LETTER MU */
+  { 0x07cd, 0x039d }, /*                    Greek_NU ? GREEK CAPITAL LETTER NU */
+  { 0x07ce, 0x039e }, /*                    Greek_XI ? GREEK CAPITAL LETTER XI */
+  { 0x07cf, 0x039f }, /*               Greek_OMICRON ? GREEK CAPITAL LETTER OMICRON */
+  { 0x07d0, 0x03a0 }, /*                    Greek_PI ? GREEK CAPITAL LETTER PI */
+  { 0x07d1, 0x03a1 }, /*                   Greek_RHO ? GREEK CAPITAL LETTER RHO */
+  { 0x07d2, 0x03a3 }, /*                 Greek_SIGMA ? GREEK CAPITAL LETTER SIGMA */
+  { 0x07d4, 0x03a4 }, /*                   Greek_TAU ? GREEK CAPITAL LETTER TAU */
+  { 0x07d5, 0x03a5 }, /*               Greek_UPSILON ? GREEK CAPITAL LETTER UPSILON */
+  { 0x07d6, 0x03a6 }, /*                   Greek_PHI ? GREEK CAPITAL LETTER PHI */
+  { 0x07d7, 0x03a7 }, /*                   Greek_CHI ? GREEK CAPITAL LETTER CHI */
+  { 0x07d8, 0x03a8 }, /*                   Greek_PSI ? GREEK CAPITAL LETTER PSI */
+  { 0x07d9, 0x03a9 }, /*                 Greek_OMEGA ? GREEK CAPITAL LETTER OMEGA */
+  { 0x07a5, 0x03aa }, /*         Greek_IOTAdiaeresis ? GREEK CAPITAL LETTER IOTA WITH DIALYTIKA */
+  { 0x07a9, 0x03ab }, /*       Greek_UPSILONdieresis ? GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA */
+  { 0x07b1, 0x03ac }, /*           Greek_alphaaccent ? GREEK SMALL LETTER ALPHA WITH TONOS */
+  { 0x07b2, 0x03ad }, /*         Greek_epsilonaccent ? GREEK SMALL LETTER EPSILON WITH TONOS */
+  { 0x07b3, 0x03ae }, /*             Greek_etaaccent ? GREEK SMALL LETTER ETA WITH TONOS */
+  { 0x07b4, 0x03af }, /*            Greek_iotaaccent ? GREEK SMALL LETTER IOTA WITH TONOS */
+  { 0x07ba, 0x03b0 }, /* Greek_upsilonaccentdieresis ? GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS */
+  { 0x07e1, 0x03b1 }, /*                 Greek_alpha ? GREEK SMALL LETTER ALPHA */
+  { 0x07e2, 0x03b2 }, /*                  Greek_beta ? GREEK SMALL LETTER BETA */
+  { 0x07e3, 0x03b3 }, /*                 Greek_gamma ? GREEK SMALL LETTER GAMMA */
+  { 0x07e4, 0x03b4 }, /*                 Greek_delta ? GREEK SMALL LETTER DELTA */
+  { 0x07e5, 0x03b5 }, /*               Greek_epsilon ? GREEK SMALL LETTER EPSILON */
+  { 0x07e6, 0x03b6 }, /*                  Greek_zeta ? GREEK SMALL LETTER ZETA */
+  { 0x07e7, 0x03b7 }, /*                   Greek_eta ? GREEK SMALL LETTER ETA */
+  { 0x07e8, 0x03b8 }, /*                 Greek_theta ? GREEK SMALL LETTER THETA */
+  { 0x07e9, 0x03b9 }, /*                  Greek_iota ? GREEK SMALL LETTER IOTA */
+  { 0x07ea, 0x03ba }, /*                 Greek_kappa ? GREEK SMALL LETTER KAPPA */
+  { 0x07eb, 0x03bb }, /*                Greek_lambda ? GREEK SMALL LETTER LAMDA */
+  { 0x07ec, 0x03bc }, /*                    Greek_mu ? GREEK SMALL LETTER MU */
+  { 0x07ed, 0x03bd }, /*                    Greek_nu ? GREEK SMALL LETTER NU */
+  { 0x07ee, 0x03be }, /*                    Greek_xi ? GREEK SMALL LETTER XI */
+  { 0x07ef, 0x03bf }, /*               Greek_omicron ? GREEK SMALL LETTER OMICRON */
+  { 0x07f0, 0x03c0 }, /*                    Greek_pi ? GREEK SMALL LETTER PI */
+  { 0x07f1, 0x03c1 }, /*                   Greek_rho ? GREEK SMALL LETTER RHO */
+  { 0x07f3, 0x03c2 }, /*       Greek_finalsmallsigma ? GREEK SMALL LETTER FINAL SIGMA */
+  { 0x07f2, 0x03c3 }, /*                 Greek_sigma ? GREEK SMALL LETTER SIGMA */
+  { 0x07f4, 0x03c4 }, /*                   Greek_tau ? GREEK SMALL LETTER TAU */
+  { 0x07f5, 0x03c5 }, /*               Greek_upsilon ? GREEK SMALL LETTER UPSILON */
+  { 0x07f6, 0x03c6 }, /*                   Greek_phi ? GREEK SMALL LETTER PHI */
+  { 0x07f7, 0x03c7 }, /*                   Greek_chi ? GREEK SMALL LETTER CHI */
+  { 0x07f8, 0x03c8 }, /*                   Greek_psi ? GREEK SMALL LETTER PSI */
+  { 0x07f9, 0x03c9 }, /*                 Greek_omega ? GREEK SMALL LETTER OMEGA */
+  { 0x07b5, 0x03ca }, /*          Greek_iotadieresis ? GREEK SMALL LETTER IOTA WITH DIALYTIKA */
+  { 0x07b9, 0x03cb }, /*       Greek_upsilondieresis ? GREEK SMALL LETTER UPSILON WITH DIALYTIKA */
+  { 0x07b7, 0x03cc }, /*         Greek_omicronaccent ? GREEK SMALL LETTER OMICRON WITH TONOS */
+  { 0x07b8, 0x03cd }, /*         Greek_upsilonaccent ? GREEK SMALL LETTER UPSILON WITH TONOS */
+  { 0x07bb, 0x03ce }, /*           Greek_omegaaccent ? GREEK SMALL LETTER OMEGA WITH TONOS */
+  { 0x06b3, 0x0401 }, /*                 Cyrillic_IO  CYRILLIC CAPITAL LETTER IO */
+  { 0x06b1, 0x0402 }, /*                 Serbian_DJE ? CYRILLIC CAPITAL LETTER DJE */
+  { 0x06b2, 0x0403 }, /*               Macedonia_GJE ? CYRILLIC CAPITAL LETTER GJE */
+  { 0x06b4, 0x0404 }, /*                Ukrainian_IE ? CYRILLIC CAPITAL LETTER UKRAINIAN IE */
+  { 0x06b5, 0x0405 }, /*               Macedonia_DSE ? CYRILLIC CAPITAL LETTER DZE */
+  { 0x06b6, 0x0406 }, /*                 Ukrainian_I ? CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I */
+  { 0x06b7, 0x0407 }, /*                Ukrainian_YI ? CYRILLIC CAPITAL LETTER YI */
+  { 0x06b8, 0x0408 }, /*                 Cyrillic_JE ? CYRILLIC CAPITAL LETTER JE */
+  { 0x06b9, 0x0409 }, /*                Cyrillic_LJE ? CYRILLIC CAPITAL LETTER LJE */
+  { 0x06ba, 0x040a }, /*                Cyrillic_NJE ? CYRILLIC CAPITAL LETTER NJE */
+  { 0x06bb, 0x040b }, /*                Serbian_TSHE ? CYRILLIC CAPITAL LETTER TSHE */
+  { 0x06bc, 0x040c }, /*               Macedonia_KJE ? CYRILLIC CAPITAL LETTER KJE */
+  { 0x06be, 0x040e }, /*         Byelorussian_SHORTU ? CYRILLIC CAPITAL LETTER SHORT U */
+  { 0x06bf, 0x040f }, /*               Cyrillic_DZHE ? CYRILLIC CAPITAL LETTER DZHE */
+  { 0x06e1, 0x0410 }, /*                  Cyrillic_A CYRILLIC CAPITAL LETTER A */
+  { 0x06e2, 0x0411 }, /*                 Cyrillic_BE CYRILLIC CAPITAL LETTER BE */
+  { 0x06f7, 0x0412 }, /*                 Cyrillic_VE CYRILLIC CAPITAL LETTER VE */
+  { 0x06e7, 0x0413 }, /*                Cyrillic_GHE CYRILLIC CAPITAL LETTER GHE */
+  { 0x06e4, 0x0414 }, /*                 Cyrillic_DE CYRILLIC CAPITAL LETTER DE */
+  { 0x06e5, 0x0415 }, /*                 Cyrillic_IE CYRILLIC CAPITAL LETTER IE */
+  { 0x06f6, 0x0416 }, /*                Cyrillic_ZHE CYRILLIC CAPITAL LETTER ZHE */
+  { 0x06fa, 0x0417 }, /*                 Cyrillic_ZE  CYRILLIC CAPITAL LETTER ZE */
+  { 0x06e9, 0x0418 }, /*                  Cyrillic_I CYRILLIC CAPITAL LETTER I */
+  { 0x06ea, 0x0419 }, /*             Cyrillic_SHORTI CYRILLIC CAPITAL LETTER SHORT I */
+  { 0x06eb, 0x041a }, /*                 Cyrillic_KA CYRILLIC CAPITAL LETTER KA */
+  { 0x06ec, 0x041b }, /*                 Cyrillic_EL CYRILLIC CAPITAL LETTER EL */
+  { 0x06ed, 0x041c }, /*                 Cyrillic_EM CYRILLIC CAPITAL LETTER EM */
+  { 0x06ee, 0x041d }, /*                 Cyrillic_EN CYRILLIC CAPITAL LETTER EN */
+  { 0x06ef, 0x041e }, /*                  Cyrillic_O CYRILLIC CAPITAL LETTER O */
+  { 0x06f0, 0x041f }, /*                 Cyrillic_PE CYRILLIC CAPITAL LETTER PE */
+  { 0x06f2, 0x0420 }, /*                 Cyrillic_ER CYRILLIC CAPITAL LETTER ER */
+  { 0x06f3, 0x0421 }, /*                 Cyrillic_ES CYRILLIC CAPITAL LETTER ES */
+  { 0x06f4, 0x0422 }, /*                 Cyrillic_TE CYRILLIC CAPITAL LETTER TE */
+  { 0x06f5, 0x0423 }, /*                  Cyrillic_U CYRILLIC CAPITAL LETTER U */
+  { 0x06e6, 0x0424 }, /*                 Cyrillic_EF CYRILLIC CAPITAL LETTER EF */
+  { 0x06e8, 0x0425 }, /*                 Cyrillic_HA CYRILLIC CAPITAL LETTER HA */
+  { 0x06e3, 0x0426 }, /*                Cyrillic_TSE CYRILLIC CAPITAL LETTER TSE */
+  { 0x06fe, 0x0427 }, /*                Cyrillic_CHE  CYRILLIC CAPITAL LETTER CHE */
+  { 0x06fb, 0x0428 }, /*                Cyrillic_SHA  CYRILLIC CAPITAL LETTER SHA */
+  { 0x06fd, 0x0429 }, /*              Cyrillic_SHCHA  CYRILLIC CAPITAL LETTER SHCHA */
+  { 0x06ff, 0x042a }, /*           Cyrillic_HARDSIGN  CYRILLIC CAPITAL LETTER HARD SIGN */
+  { 0x06f9, 0x042b }, /*               Cyrillic_YERU  CYRILLIC CAPITAL LETTER YERU */
+  { 0x06f8, 0x042c }, /*           Cyrillic_SOFTSIGN  CYRILLIC CAPITAL LETTER SOFT SIGN */
+  { 0x06fc, 0x042d }, /*                  Cyrillic_E  CYRILLIC CAPITAL LETTER E */
+  { 0x06e0, 0x042e }, /*                 Cyrillic_YU CYRILLIC CAPITAL LETTER YU */
+  { 0x06f1, 0x042f }, /*                 Cyrillic_YA CYRILLIC CAPITAL LETTER YA */
+  { 0x06c1, 0x0430 }, /*                  Cyrillic_a CYRILLIC SMALL LETTER A */
+  { 0x06c2, 0x0431 }, /*                 Cyrillic_be CYRILLIC SMALL LETTER BE */
+  { 0x06d7, 0x0432 }, /*                 Cyrillic_ve CYRILLIC SMALL LETTER VE */
+  { 0x06c7, 0x0433 }, /*                Cyrillic_ghe CYRILLIC SMALL LETTER GHE */
+  { 0x06c4, 0x0434 }, /*                 Cyrillic_de CYRILLIC SMALL LETTER DE */
+  { 0x06c5, 0x0435 }, /*                 Cyrillic_ie CYRILLIC SMALL LETTER IE */
+  { 0x06d6, 0x0436 }, /*                Cyrillic_zhe CYRILLIC SMALL LETTER ZHE */
+  { 0x06da, 0x0437 }, /*                 Cyrillic_ze CYRILLIC SMALL LETTER ZE */
+  { 0x06c9, 0x0438 }, /*                  Cyrillic_i CYRILLIC SMALL LETTER I */
+  { 0x06ca, 0x0439 }, /*             Cyrillic_shorti CYRILLIC SMALL LETTER SHORT I */
+  { 0x06cb, 0x043a }, /*                 Cyrillic_ka CYRILLIC SMALL LETTER KA */
+  { 0x06cc, 0x043b }, /*                 Cyrillic_el CYRILLIC SMALL LETTER EL */
+  { 0x06cd, 0x043c }, /*                 Cyrillic_em CYRILLIC SMALL LETTER EM */
+  { 0x06ce, 0x043d }, /*                 Cyrillic_en CYRILLIC SMALL LETTER EN */
+  { 0x06cf, 0x043e }, /*                  Cyrillic_o CYRILLIC SMALL LETTER O */
+  { 0x06d0, 0x043f }, /*                 Cyrillic_pe CYRILLIC SMALL LETTER PE */
+  { 0x06d2, 0x0440 }, /*                 Cyrillic_er CYRILLIC SMALL LETTER ER */
+  { 0x06d3, 0x0441 }, /*                 Cyrillic_es CYRILLIC SMALL LETTER ES */
+  { 0x06d4, 0x0442 }, /*                 Cyrillic_te CYRILLIC SMALL LETTER TE */
+  { 0x06d5, 0x0443 }, /*                  Cyrillic_u CYRILLIC SMALL LETTER U */
+  { 0x06c6, 0x0444 }, /*                 Cyrillic_ef CYRILLIC SMALL LETTER EF */
+  { 0x06c8, 0x0445 }, /*                 Cyrillic_ha CYRILLIC SMALL LETTER HA */
+  { 0x06c3, 0x0446 }, /*                Cyrillic_tse CYRILLIC SMALL LETTER TSE */
+  { 0x06de, 0x0447 }, /*                Cyrillic_che CYRILLIC SMALL LETTER CHE */
+  { 0x06db, 0x0448 }, /*                Cyrillic_sha CYRILLIC SMALL LETTER SHA */
+  { 0x06dd, 0x0449 }, /*              Cyrillic_shcha CYRILLIC SMALL LETTER SHCHA */
+  { 0x06df, 0x044a }, /*           Cyrillic_hardsign CYRILLIC SMALL LETTER HARD SIGN */
+  { 0x06d9, 0x044b }, /*               Cyrillic_yeru CYRILLIC SMALL LETTER YERU */
+  { 0x06d8, 0x044c }, /*           Cyrillic_softsign CYRILLIC SMALL LETTER SOFT SIGN */
+  { 0x06dc, 0x044d }, /*                  Cyrillic_e CYRILLIC SMALL LETTER E */
+  { 0x06c0, 0x044e }, /*                 Cyrillic_yu CYRILLIC SMALL LETTER YU */
+  { 0x06d1, 0x044f }, /*                 Cyrillic_ya CYRILLIC SMALL LETTER YA */
+  { 0x06a3, 0x0451 }, /*                 Cyrillic_io  CYRILLIC SMALL LETTER IO */
+  { 0x06a1, 0x0452 }, /*                 Serbian_dje ? CYRILLIC SMALL LETTER DJE */
+  { 0x06a2, 0x0453 }, /*               Macedonia_gje ? CYRILLIC SMALL LETTER GJE */
+  { 0x06a4, 0x0454 }, /*                Ukrainian_ie ? CYRILLIC SMALL LETTER UKRAINIAN IE */
+  { 0x06a5, 0x0455 }, /*               Macedonia_dse ? CYRILLIC SMALL LETTER DZE */
+  { 0x06a6, 0x0456 }, /*                 Ukrainian_i ? CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I */
+  { 0x06a7, 0x0457 }, /*                Ukrainian_yi ? CYRILLIC SMALL LETTER YI */
+  { 0x06a8, 0x0458 }, /*                 Cyrillic_je ? CYRILLIC SMALL LETTER JE */
+  { 0x06a9, 0x0459 }, /*                Cyrillic_lje ? CYRILLIC SMALL LETTER LJE */
+  { 0x06aa, 0x045a }, /*                Cyrillic_nje ? CYRILLIC SMALL LETTER NJE */
+  { 0x06ab, 0x045b }, /*                Serbian_tshe ? CYRILLIC SMALL LETTER TSHE */
+  { 0x06ac, 0x045c }, /*               Macedonia_kje ? CYRILLIC SMALL LETTER KJE */
+  { 0x06ae, 0x045e }, /*         Byelorussian_shortu ? CYRILLIC SMALL LETTER SHORT U */
+  { 0x06af, 0x045f }, /*               Cyrillic_dzhe ? CYRILLIC SMALL LETTER DZHE */
+  { 0x0ce0, 0x05d0 }, /*                hebrew_aleph ? HEBREW LETTER ALEF */
+  { 0x0ce1, 0x05d1 }, /*                  hebrew_bet ? HEBREW LETTER BET */
+  { 0x0ce2, 0x05d2 }, /*                hebrew_gimel ? HEBREW LETTER GIMEL */
+  { 0x0ce3, 0x05d3 }, /*                hebrew_dalet ? HEBREW LETTER DALET */
+  { 0x0ce4, 0x05d4 }, /*                   hebrew_he ? HEBREW LETTER HE */
+  { 0x0ce5, 0x05d5 }, /*                  hebrew_waw ? HEBREW LETTER VAV */
+  { 0x0ce6, 0x05d6 }, /*                 hebrew_zain ? HEBREW LETTER ZAYIN */
+  { 0x0ce7, 0x05d7 }, /*                 hebrew_chet ? HEBREW LETTER HET */
+  { 0x0ce8, 0x05d8 }, /*                  hebrew_tet ? HEBREW LETTER TET */
+  { 0x0ce9, 0x05d9 }, /*                  hebrew_yod ? HEBREW LETTER YOD */
+  { 0x0cea, 0x05da }, /*            hebrew_finalkaph ? HEBREW LETTER FINAL KAF */
+  { 0x0ceb, 0x05db }, /*                 hebrew_kaph ? HEBREW LETTER KAF */
+  { 0x0cec, 0x05dc }, /*                hebrew_lamed ? HEBREW LETTER LAMED */
+  { 0x0ced, 0x05dd }, /*             hebrew_finalmem ? HEBREW LETTER FINAL MEM */
+  { 0x0cee, 0x05de }, /*                  hebrew_mem ? HEBREW LETTER MEM */
+  { 0x0cef, 0x05df }, /*             hebrew_finalnun ? HEBREW LETTER FINAL NUN */
+  { 0x0cf0, 0x05e0 }, /*                  hebrew_nun ? HEBREW LETTER NUN */
+  { 0x0cf1, 0x05e1 }, /*               hebrew_samech ? HEBREW LETTER SAMEKH */
+  { 0x0cf2, 0x05e2 }, /*                 hebrew_ayin ? HEBREW LETTER AYIN */
+  { 0x0cf3, 0x05e3 }, /*              hebrew_finalpe ? HEBREW LETTER FINAL PE */
+  { 0x0cf4, 0x05e4 }, /*                   hebrew_pe ? HEBREW LETTER PE */
+  { 0x0cf5, 0x05e5 }, /*            hebrew_finalzade ? HEBREW LETTER FINAL TSADI */
+  { 0x0cf6, 0x05e6 }, /*                 hebrew_zade ? HEBREW LETTER TSADI */
+  { 0x0cf7, 0x05e7 }, /*                 hebrew_qoph ? HEBREW LETTER QOF */
+  { 0x0cf8, 0x05e8 }, /*                 hebrew_resh ? HEBREW LETTER RESH */
+  { 0x0cf9, 0x05e9 }, /*                 hebrew_shin ? HEBREW LETTER SHIN */
+  { 0x0cfa, 0x05ea }, /*                  hebrew_taw ? HEBREW LETTER TAV */
+  { 0x05ac, 0x060c }, /*                Arabic_comma ? ARABIC COMMA */
+  { 0x05bb, 0x061b }, /*            Arabic_semicolon ? ARABIC SEMICOLON */
+  { 0x05bf, 0x061f }, /*        Arabic_question_mark ? ARABIC QUESTION MARK */
+  { 0x05c1, 0x0621 }, /*                Arabic_hamza ? ARABIC LETTER HAMZA */
+  { 0x05c2, 0x0622 }, /*          Arabic_maddaonalef ? ARABIC LETTER ALEF WITH MADDA ABOVE */
+  { 0x05c3, 0x0623 }, /*          Arabic_hamzaonalef ? ARABIC LETTER ALEF WITH HAMZA ABOVE */
+  { 0x05c4, 0x0624 }, /*           Arabic_hamzaonwaw ? ARABIC LETTER WAW WITH HAMZA ABOVE */
+  { 0x05c5, 0x0625 }, /*       Arabic_hamzaunderalef ? ARABIC LETTER ALEF WITH HAMZA BELOW */
+  { 0x05c6, 0x0626 }, /*           Arabic_hamzaonyeh ? ARABIC LETTER YEH WITH HAMZA ABOVE */
+  { 0x05c7, 0x0627 }, /*                 Arabic_alef ? ARABIC LETTER ALEF */
+  { 0x05c8, 0x0628 }, /*                  Arabic_beh ? ARABIC LETTER BEH */
+  { 0x05c9, 0x0629 }, /*           Arabic_tehmarbuta ? ARABIC LETTER TEH MARBUTA */
+  { 0x05ca, 0x062a }, /*                  Arabic_teh ? ARABIC LETTER TEH */
+  { 0x05cb, 0x062b }, /*                 Arabic_theh ? ARABIC LETTER THEH */
+  { 0x05cc, 0x062c }, /*                 Arabic_jeem ? ARABIC LETTER JEEM */
+  { 0x05cd, 0x062d }, /*                  Arabic_hah ? ARABIC LETTER HAH */
+  { 0x05ce, 0x062e }, /*                 Arabic_khah ? ARABIC LETTER KHAH */
+  { 0x05cf, 0x062f }, /*                  Arabic_dal ? ARABIC LETTER DAL */
+  { 0x05d0, 0x0630 }, /*                 Arabic_thal ? ARABIC LETTER THAL */
+  { 0x05d1, 0x0631 }, /*                   Arabic_ra ? ARABIC LETTER REH */
+  { 0x05d2, 0x0632 }, /*                 Arabic_zain ? ARABIC LETTER ZAIN */
+  { 0x05d3, 0x0633 }, /*                 Arabic_seen ? ARABIC LETTER SEEN */
+  { 0x05d4, 0x0634 }, /*                Arabic_sheen ? ARABIC LETTER SHEEN */
+  { 0x05d5, 0x0635 }, /*                  Arabic_sad ? ARABIC LETTER SAD */
+  { 0x05d6, 0x0636 }, /*                  Arabic_dad ? ARABIC LETTER DAD */
+  { 0x05d7, 0x0637 }, /*                  Arabic_tah ? ARABIC LETTER TAH */
+  { 0x05d8, 0x0638 }, /*                  Arabic_zah ? ARABIC LETTER ZAH */
+  { 0x05d9, 0x0639 }, /*                  Arabic_ain ? ARABIC LETTER AIN */
+  { 0x05da, 0x063a }, /*                Arabic_ghain ? ARABIC LETTER GHAIN */
+  { 0x05e0, 0x0640 }, /*              Arabic_tatweel ? ARABIC TATWEEL */
+  { 0x05e1, 0x0641 }, /*                  Arabic_feh ? ARABIC LETTER FEH */
+  { 0x05e2, 0x0642 }, /*                  Arabic_qaf ? ARABIC LETTER QAF */
+  { 0x05e3, 0x0643 }, /*                  Arabic_kaf ? ARABIC LETTER KAF */
+  { 0x05e4, 0x0644 }, /*                  Arabic_lam ? ARABIC LETTER LAM */
+  { 0x05e5, 0x0645 }, /*                 Arabic_meem ? ARABIC LETTER MEEM */
+  { 0x05e6, 0x0646 }, /*                 Arabic_noon ? ARABIC LETTER NOON */
+  { 0x05e7, 0x0647 }, /*                   Arabic_ha ? ARABIC LETTER HEH */
+  { 0x05e8, 0x0648 }, /*                  Arabic_waw ? ARABIC LETTER WAW */
+  { 0x05e9, 0x0649 }, /*          Arabic_alefmaksura ? ARABIC LETTER ALEF MAKSURA */
+  { 0x05ea, 0x064a }, /*                  Arabic_yeh ? ARABIC LETTER YEH */
+  { 0x05eb, 0x064b }, /*             Arabic_fathatan ? ARABIC FATHATAN */
+  { 0x05ec, 0x064c }, /*             Arabic_dammatan ? ARABIC DAMMATAN */
+  { 0x05ed, 0x064d }, /*             Arabic_kasratan ? ARABIC KASRATAN */
+  { 0x05ee, 0x064e }, /*                Arabic_fatha ? ARABIC FATHA */
+  { 0x05ef, 0x064f }, /*                Arabic_damma ? ARABIC DAMMA */
+  { 0x05f0, 0x0650 }, /*                Arabic_kasra ? ARABIC KASRA */
+  { 0x05f1, 0x0651 }, /*               Arabic_shadda ? ARABIC SHADDA */
+  { 0x05f2, 0x0652 }, /*                Arabic_sukun ? ARABIC SUKUN */
+  { 0x0da1, 0x0e01 }, /*                  Thai_kokai ? THAI CHARACTER KO KAI */
+  { 0x0da2, 0x0e02 }, /*                Thai_khokhai ? THAI CHARACTER KHO KHAI */
+  { 0x0da3, 0x0e03 }, /*               Thai_khokhuat ? THAI CHARACTER KHO KHUAT */
+  { 0x0da4, 0x0e04 }, /*               Thai_khokhwai ? THAI CHARACTER KHO KHWAI */
+  { 0x0da5, 0x0e05 }, /*                Thai_khokhon ? THAI CHARACTER KHO KHON */
+  { 0x0da6, 0x0e06 }, /*             Thai_khorakhang ? THAI CHARACTER KHO RAKHANG */
+  { 0x0da7, 0x0e07 }, /*                 Thai_ngongu ? THAI CHARACTER NGO NGU */
+  { 0x0da8, 0x0e08 }, /*                Thai_chochan ? THAI CHARACTER CHO CHAN */
+  { 0x0da9, 0x0e09 }, /*               Thai_choching ? THAI CHARACTER CHO CHING */
+  { 0x0daa, 0x0e0a }, /*               Thai_chochang ? THAI CHARACTER CHO CHANG */
+  { 0x0dab, 0x0e0b }, /*                   Thai_soso ? THAI CHARACTER SO SO */
+  { 0x0dac, 0x0e0c }, /*                Thai_chochoe ? THAI CHARACTER CHO CHOE */
+  { 0x0dad, 0x0e0d }, /*                 Thai_yoying ? THAI CHARACTER YO YING */
+  { 0x0dae, 0x0e0e }, /*                Thai_dochada ? THAI CHARACTER DO CHADA */
+  { 0x0daf, 0x0e0f }, /*                Thai_topatak ? THAI CHARACTER TO PATAK */
+  { 0x0db0, 0x0e10 }, /*                Thai_thothan ? THAI CHARACTER THO THAN */
+  { 0x0db1, 0x0e11 }, /*          Thai_thonangmontho ? THAI CHARACTER THO NANGMONTHO */
+  { 0x0db2, 0x0e12 }, /*             Thai_thophuthao ? THAI CHARACTER THO PHUTHAO */
+  { 0x0db3, 0x0e13 }, /*                  Thai_nonen ? THAI CHARACTER NO NEN */
+  { 0x0db4, 0x0e14 }, /*                  Thai_dodek ? THAI CHARACTER DO DEK */
+  { 0x0db5, 0x0e15 }, /*                  Thai_totao ? THAI CHARACTER TO TAO */
+  { 0x0db6, 0x0e16 }, /*               Thai_thothung ? THAI CHARACTER THO THUNG */
+  { 0x0db7, 0x0e17 }, /*              Thai_thothahan ? THAI CHARACTER THO THAHAN */
+  { 0x0db8, 0x0e18 }, /*               Thai_thothong ? THAI CHARACTER THO THONG */
+  { 0x0db9, 0x0e19 }, /*                   Thai_nonu ? THAI CHARACTER NO NU */
+  { 0x0dba, 0x0e1a }, /*               Thai_bobaimai ? THAI CHARACTER BO BAIMAI */
+  { 0x0dbb, 0x0e1b }, /*                  Thai_popla ? THAI CHARACTER PO PLA */
+  { 0x0dbc, 0x0e1c }, /*               Thai_phophung ? THAI CHARACTER PHO PHUNG */
+  { 0x0dbd, 0x0e1d }, /*                   Thai_fofa ? THAI CHARACTER FO FA */
+  { 0x0dbe, 0x0e1e }, /*                Thai_phophan ? THAI CHARACTER PHO PHAN */
+  { 0x0dbf, 0x0e1f }, /*                  Thai_fofan ? THAI CHARACTER FO FAN */
+  { 0x0dc0, 0x0e20 }, /*             Thai_phosamphao ? THAI CHARACTER PHO SAMPHAO */
+  { 0x0dc1, 0x0e21 }, /*                   Thai_moma ? THAI CHARACTER MO MA */
+  { 0x0dc2, 0x0e22 }, /*                  Thai_yoyak ? THAI CHARACTER YO YAK */
+  { 0x0dc3, 0x0e23 }, /*                  Thai_rorua ? THAI CHARACTER RO RUA */
+  { 0x0dc4, 0x0e24 }, /*                     Thai_ru ? THAI CHARACTER RU */
+  { 0x0dc5, 0x0e25 }, /*                 Thai_loling ? THAI CHARACTER LO LING */
+  { 0x0dc6, 0x0e26 }, /*                     Thai_lu ? THAI CHARACTER LU */
+  { 0x0dc7, 0x0e27 }, /*                 Thai_wowaen ? THAI CHARACTER WO WAEN */
+  { 0x0dc8, 0x0e28 }, /*                 Thai_sosala ? THAI CHARACTER SO SALA */
+  { 0x0dc9, 0x0e29 }, /*                 Thai_sorusi ? THAI CHARACTER SO RUSI */
+  { 0x0dca, 0x0e2a }, /*                  Thai_sosua ? THAI CHARACTER SO SUA */
+  { 0x0dcb, 0x0e2b }, /*                  Thai_hohip ? THAI CHARACTER HO HIP */
+  { 0x0dcc, 0x0e2c }, /*                Thai_lochula ? THAI CHARACTER LO CHULA */
+  { 0x0dcd, 0x0e2d }, /*                   Thai_oang ? THAI CHARACTER O ANG */
+  { 0x0dce, 0x0e2e }, /*               Thai_honokhuk ? THAI CHARACTER HO NOKHUK */
+  { 0x0dcf, 0x0e2f }, /*              Thai_paiyannoi ? THAI CHARACTER PAIYANNOI */
+  { 0x0dd0, 0x0e30 }, /*                  Thai_saraa ? THAI CHARACTER SARA A */
+  { 0x0dd1, 0x0e31 }, /*             Thai_maihanakat ? THAI CHARACTER MAI HAN-AKAT */
+  { 0x0dd2, 0x0e32 }, /*                 Thai_saraaa ? THAI CHARACTER SARA AA */
+  { 0x0dd3, 0x0e33 }, /*                 Thai_saraam ? THAI CHARACTER SARA AM */
+  { 0x0dd4, 0x0e34 }, /*                  Thai_sarai ? THAI CHARACTER SARA I */
+  { 0x0dd5, 0x0e35 }, /*                 Thai_saraii ? THAI CHARACTER SARA II */
+  { 0x0dd6, 0x0e36 }, /*                 Thai_saraue ? THAI CHARACTER SARA UE */
+  { 0x0dd7, 0x0e37 }, /*                Thai_sarauee ? THAI CHARACTER SARA UEE */
+  { 0x0dd8, 0x0e38 }, /*                  Thai_sarau ? THAI CHARACTER SARA U */
+  { 0x0dd9, 0x0e39 }, /*                 Thai_sarauu ? THAI CHARACTER SARA UU */
+  { 0x0dda, 0x0e3a }, /*                Thai_phinthu ? THAI CHARACTER PHINTHU */
+  { 0x0ddf, 0x0e3f }, /*                   Thai_baht ? THAI CURRENCY SYMBOL BAHT */
+  { 0x0de0, 0x0e40 }, /*                  Thai_sarae ? THAI CHARACTER SARA E */
+  { 0x0de1, 0x0e41 }, /*                 Thai_saraae ? THAI CHARACTER SARA AE */
+  { 0x0de2, 0x0e42 }, /*                  Thai_sarao ? THAI CHARACTER SARA O */
+  { 0x0de3, 0x0e43 }, /*          Thai_saraaimaimuan ? THAI CHARACTER SARA AI MAIMUAN */
+  { 0x0de4, 0x0e44 }, /*         Thai_saraaimaimalai ? THAI CHARACTER SARA AI MAIMALAI */
+  { 0x0de5, 0x0e45 }, /*            Thai_lakkhangyao ? THAI CHARACTER LAKKHANGYAO */
+  { 0x0de6, 0x0e46 }, /*               Thai_maiyamok ? THAI CHARACTER MAIYAMOK */
+  { 0x0de7, 0x0e47 }, /*              Thai_maitaikhu ? THAI CHARACTER MAITAIKHU */
+  { 0x0de8, 0x0e48 }, /*                  Thai_maiek ? THAI CHARACTER MAI EK */
+  { 0x0de9, 0x0e49 }, /*                 Thai_maitho ? THAI CHARACTER MAI THO */
+  { 0x0dea, 0x0e4a }, /*                 Thai_maitri ? THAI CHARACTER MAI TRI */
+  { 0x0deb, 0x0e4b }, /*            Thai_maichattawa ? THAI CHARACTER MAI CHATTAWA */
+  { 0x0dec, 0x0e4c }, /*            Thai_thanthakhat ? THAI CHARACTER THANTHAKHAT */
+  { 0x0ded, 0x0e4d }, /*               Thai_nikhahit ? THAI CHARACTER NIKHAHIT */
+  { 0x0df0, 0x0e50 }, /*                 Thai_leksun ? THAI DIGIT ZERO */
+  { 0x0df1, 0x0e51 }, /*                Thai_leknung ? THAI DIGIT ONE */
+  { 0x0df2, 0x0e52 }, /*                Thai_leksong ? THAI DIGIT TWO */
+  { 0x0df3, 0x0e53 }, /*                 Thai_leksam ? THAI DIGIT THREE */
+  { 0x0df4, 0x0e54 }, /*                  Thai_leksi ? THAI DIGIT FOUR */
+  { 0x0df5, 0x0e55 }, /*                  Thai_lekha ? THAI DIGIT FIVE */
+  { 0x0df6, 0x0e56 }, /*                 Thai_lekhok ? THAI DIGIT SIX */
+  { 0x0df7, 0x0e57 }, /*                Thai_lekchet ? THAI DIGIT SEVEN */
+  { 0x0df8, 0x0e58 }, /*                Thai_lekpaet ? THAI DIGIT EIGHT */
+  { 0x0df9, 0x0e59 }, /*                 Thai_lekkao ? THAI DIGIT NINE */
+  { 0x0ed4, 0x11a8 }, /*             Hangul_J_Kiyeog ? HANGUL JONGSEONG KIYEOK */
+  { 0x0ed5, 0x11a9 }, /*        Hangul_J_SsangKiyeog ? HANGUL JONGSEONG SSANGKIYEOK */
+  { 0x0ed6, 0x11aa }, /*         Hangul_J_KiyeogSios ? HANGUL JONGSEONG KIYEOK-SIOS */
+  { 0x0ed7, 0x11ab }, /*              Hangul_J_Nieun ? HANGUL JONGSEONG NIEUN */
+  { 0x0ed8, 0x11ac }, /*         Hangul_J_NieunJieuj ? HANGUL JONGSEONG NIEUN-CIEUC */
+  { 0x0ed9, 0x11ad }, /*         Hangul_J_NieunHieuh ? HANGUL JONGSEONG NIEUN-HIEUH */
+  { 0x0eda, 0x11ae }, /*             Hangul_J_Dikeud ? HANGUL JONGSEONG TIKEUT */
+  { 0x0edb, 0x11af }, /*              Hangul_J_Rieul ? HANGUL JONGSEONG RIEUL */
+  { 0x0edc, 0x11b0 }, /*        Hangul_J_RieulKiyeog ? HANGUL JONGSEONG RIEUL-KIYEOK */
+  { 0x0edd, 0x11b1 }, /*         Hangul_J_RieulMieum ? HANGUL JONGSEONG RIEUL-MIEUM */
+  { 0x0ede, 0x11b2 }, /*         Hangul_J_RieulPieub ? HANGUL JONGSEONG RIEUL-PIEUP */
+  { 0x0edf, 0x11b3 }, /*          Hangul_J_RieulSios ? HANGUL JONGSEONG RIEUL-SIOS */
+  { 0x0ee0, 0x11b4 }, /*         Hangul_J_RieulTieut ? HANGUL JONGSEONG RIEUL-THIEUTH */
+  { 0x0ee1, 0x11b5 }, /*        Hangul_J_RieulPhieuf ? HANGUL JONGSEONG RIEUL-PHIEUPH */
+  { 0x0ee2, 0x11b6 }, /*         Hangul_J_RieulHieuh ? HANGUL JONGSEONG RIEUL-HIEUH */
+  { 0x0ee3, 0x11b7 }, /*              Hangul_J_Mieum ? HANGUL JONGSEONG MIEUM */
+  { 0x0ee4, 0x11b8 }, /*              Hangul_J_Pieub ? HANGUL JONGSEONG PIEUP */
+  { 0x0ee5, 0x11b9 }, /*          Hangul_J_PieubSios ? HANGUL JONGSEONG PIEUP-SIOS */
+  { 0x0ee6, 0x11ba }, /*               Hangul_J_Sios ? HANGUL JONGSEONG SIOS */
+  { 0x0ee7, 0x11bb }, /*          Hangul_J_SsangSios ? HANGUL JONGSEONG SSANGSIOS */
+  { 0x0ee8, 0x11bc }, /*              Hangul_J_Ieung ? HANGUL JONGSEONG IEUNG */
+  { 0x0ee9, 0x11bd }, /*              Hangul_J_Jieuj ? HANGUL JONGSEONG CIEUC */
+  { 0x0eea, 0x11be }, /*              Hangul_J_Cieuc ? HANGUL JONGSEONG CHIEUCH */
+  { 0x0eeb, 0x11bf }, /*             Hangul_J_Khieuq ? HANGUL JONGSEONG KHIEUKH */
+  { 0x0eec, 0x11c0 }, /*              Hangul_J_Tieut ? HANGUL JONGSEONG THIEUTH */
+  { 0x0eed, 0x11c1 }, /*             Hangul_J_Phieuf ? HANGUL JONGSEONG PHIEUPH */
+  { 0x0eee, 0x11c2 }, /*              Hangul_J_Hieuh ? HANGUL JONGSEONG HIEUH */
+  { 0x0ef8, 0x11eb }, /*            Hangul_J_PanSios ? HANGUL JONGSEONG PANSIOS */
+  { 0x0ef9, 0x11f0 }, /*  Hangul_J_KkogjiDalrinIeung ? HANGUL JONGSEONG YESIEUNG */
+  { 0x0efa, 0x11f9 }, /*        Hangul_J_YeorinHieuh ? HANGUL JONGSEONG YEORINHIEUH */
+  { 0x0aa2, 0x2002 }, /*                     enspace ? EN SPACE */
+  { 0x0aa1, 0x2003 }, /*                     emspace ? EM SPACE */
+  { 0x0aa3, 0x2004 }, /*                    em3space ? THREE-PER-EM SPACE */
+  { 0x0aa4, 0x2005 }, /*                    em4space ? FOUR-PER-EM SPACE */
+  { 0x0aa5, 0x2007 }, /*                  digitspace ? FIGURE SPACE */
+  { 0x0aa6, 0x2008 }, /*                  punctspace ? PUNCTUATION SPACE */
+  { 0x0aa7, 0x2009 }, /*                   thinspace ? THIN SPACE */
+  { 0x0aa8, 0x200a }, /*                   hairspace ? HAIR SPACE */
+  { 0x0abb, 0x2012 }, /*                     figdash ? FIGURE DASH */
+  { 0x0aaa, 0x2013 }, /*                      endash ? EN DASH */
+  { 0x0aa9, 0x2014 }, /*                      emdash ? EM DASH */
+  { 0x07af, 0x2015 }, /*              Greek_horizbar ? HORIZONTAL BAR */
+  { 0x0cdf, 0x2017 }, /*        hebrew_doublelowline ? DOUBLE LOW LINE */
+  { 0x0ad0, 0x2018 }, /*         leftsinglequotemark ? LEFT SINGLE QUOTATION MARK */
+  { 0x0ad1, 0x2019 }, /*        rightsinglequotemark ? RIGHT SINGLE QUOTATION MARK */
+  { 0x0afd, 0x201a }, /*          singlelowquotemark ? SINGLE LOW-9 QUOTATION MARK */
+  { 0x0ad2, 0x201c }, /*         leftdoublequotemark ? LEFT DOUBLE QUOTATION MARK */
+  { 0x0ad3, 0x201d }, /*        rightdoublequotemark ? RIGHT DOUBLE QUOTATION MARK */
+  { 0x0afe, 0x201e }, /*          doublelowquotemark ? DOUBLE LOW-9 QUOTATION MARK */
+  { 0x0af1, 0x2020 }, /*                      dagger ? DAGGER */
+  { 0x0af2, 0x2021 }, /*                doubledagger ? DOUBLE DAGGER */
+  { 0x0ae6, 0x2022 }, /*          enfilledcircbullet ? BULLET */
+  { 0x0aaf, 0x2025 }, /*             doubbaselinedot ? TWO DOT LEADER */
+  { 0x0aae, 0x2026 }, /*                    ellipsis ? HORIZONTAL ELLIPSIS */
+  { 0x0ad6, 0x2032 }, /*                     minutes ? PRIME */
+  { 0x0ad7, 0x2033 }, /*                     seconds ? DOUBLE PRIME */
+  { 0x0afc, 0x2038 }, /*                       caret ? CARET */
+  { 0x047e, 0x203e }, /*                    overline ? OVERLINE */
+  { 0x0eff, 0x20a9 }, /*                  Korean_Won ? WON SIGN */
+  { 0x13a4, 0x20ac }, /*                        Euro ? EURO SIGN */
+  { 0x20ac, 0x20ac }, /*                    EuroSign ? EURO SIGN */ 
+  { 0x0ab8, 0x2105 }, /*                      careof ? CARE OF */
+  { 0x06b0, 0x2116 }, /*                  numerosign ? NUMERO SIGN */
+  { 0x0afb, 0x2117 }, /*         phonographcopyright ? SOUND RECORDING COPYRIGHT */
+  { 0x0ad4, 0x211e }, /*                prescription ? PRESCRIPTION TAKE */
+  { 0x0ac9, 0x2122 }, /*                   trademark ? TRADE MARK SIGN */
+  { 0x0ab0, 0x2153 }, /*                    onethird ? VULGAR FRACTION ONE THIRD */
+  { 0x0ab1, 0x2154 }, /*                   twothirds ? VULGAR FRACTION TWO THIRDS */
+  { 0x0ab2, 0x2155 }, /*                    onefifth ? VULGAR FRACTION ONE FIFTH */
+  { 0x0ab3, 0x2156 }, /*                   twofifths ? VULGAR FRACTION TWO FIFTHS */
+  { 0x0ab4, 0x2157 }, /*                 threefifths ? VULGAR FRACTION THREE FIFTHS */
+  { 0x0ab5, 0x2158 }, /*                  fourfifths ? VULGAR FRACTION FOUR FIFTHS */
+  { 0x0ab6, 0x2159 }, /*                    onesixth ? VULGAR FRACTION ONE SIXTH */
+  { 0x0ab7, 0x215a }, /*                  fivesixths ? VULGAR FRACTION FIVE SIXTHS */
+  { 0x0ac3, 0x215b }, /*                   oneeighth ? VULGAR FRACTION ONE EIGHTH */
+  { 0x0ac4, 0x215c }, /*                threeeighths ? VULGAR FRACTION THREE EIGHTHS */
+  { 0x0ac5, 0x215d }, /*                 fiveeighths ? VULGAR FRACTION FIVE EIGHTHS */
+  { 0x0ac6, 0x215e }, /*                seveneighths ? VULGAR FRACTION SEVEN EIGHTHS */
+  { 0x08fb, 0x2190 }, /*                   leftarrow ? LEFTWARDS ARROW */
+  { 0x08fc, 0x2191 }, /*                     uparrow ? UPWARDS ARROW */
+  { 0x08fd, 0x2192 }, /*                  rightarrow ? RIGHTWARDS ARROW */
+  { 0x08fe, 0x2193 }, /*                   downarrow ? DOWNWARDS ARROW */
+  { 0x08ce, 0x21d2 }, /*                     implies ? RIGHTWARDS DOUBLE ARROW */
+  { 0x08cd, 0x21d4 }, /*                    ifonlyif ? LEFT RIGHT DOUBLE ARROW */
+  { 0x08ef, 0x2202 }, /*           partialderivative ? PARTIAL DIFFERENTIAL */
+  { 0x08c5, 0x2207 }, /*                       nabla ? NABLA */
+  { 0x0bca, 0x2218 }, /*                         jot ? RING OPERATOR */
+  { 0x08d6, 0x221a }, /*                     radical  SQUARE ROOT */
+  { 0x08c1, 0x221d }, /*                   variation ? PROPORTIONAL TO */
+  { 0x08c2, 0x221e }, /*                    infinity ? INFINITY */
+  { 0x08de, 0x2227 }, /*                  logicaland ? LOGICAL AND */
+  { 0x0ba9, 0x2227 }, /*                     upcaret ? LOGICAL AND */
+  { 0x0ba8, 0x2228 }, /*                   downcaret ? LOGICAL OR */
+  { 0x08df, 0x2228 }, /*                   logicalor ? LOGICAL OR */
+  { 0x08dc, 0x2229 }, /*                intersection ? INTERSECTION */
+  { 0x0bc3, 0x2229 }, /*                      upshoe ? INTERSECTION */
+  { 0x0bd6, 0x222a }, /*                    downshoe ? UNION */
+  { 0x08dd, 0x222a }, /*                       union ? UNION */
+  { 0x08bf, 0x222b }, /*                    integral ? INTEGRAL */
+  { 0x08c0, 0x2234 }, /*                   therefore ? THEREFORE */
+  { 0x08c8, 0x223c }, /*                 approximate ? TILDE OPERATOR */
+  { 0x08c9, 0x2243 }, /*                similarequal ? ASYMPTOTICALLY EQUAL TO */
+  { 0x08bd, 0x2260 }, /*                    notequal ? NOT EQUAL TO */
+  { 0x08cf, 0x2261 }, /*                   identical ? IDENTICAL TO */
+  { 0x08bc, 0x2264 }, /*               lessthanequal  LESS-THAN OR EQUAL TO */
+  { 0x08be, 0x2265 }, /*            greaterthanequal  GREATER-THAN OR EQUAL TO */
+  { 0x08da, 0x2282 }, /*                  includedin ? SUBSET OF */
+  { 0x0bda, 0x2282 }, /*                    leftshoe ? SUBSET OF */
+  { 0x08db, 0x2283 }, /*                    includes ? SUPERSET OF */
+  { 0x0bd8, 0x2283 }, /*                   rightshoe ? SUPERSET OF */
+  { 0x0bdc, 0x22a2 }, /*                    lefttack ? RIGHT TACK */
+  { 0x0bfc, 0x22a3 }, /*                   righttack ? LEFT TACK */
+  { 0x0bce, 0x22a4 }, /*                      uptack ? DOWN TACK */
+  { 0x0bc2, 0x22a5 }, /*                    downtack ? UP TACK */
+  { 0x0bd3, 0x2308 }, /*                     upstile ? LEFT CEILING */
+  { 0x0bc4, 0x230a }, /*                   downstile ? LEFT FLOOR */
+  { 0x0afa, 0x2315 }, /*           telephonerecorder ? TELEPHONE RECORDER */
+  { 0x08a4, 0x2320 }, /*                 topintegral  TOP HALF INTEGRAL */
+  { 0x08a5, 0x2321 }, /*                 botintegral  BOTTOM HALF INTEGRAL */
+  { 0x0abc, 0x2329 }, /*            leftanglebracket ? LEFT-POINTING ANGLE BRACKET */
+  { 0x0abe, 0x232a }, /*           rightanglebracket ? RIGHT-POINTING ANGLE BRACKET */
+  { 0x0bcc, 0x2395 }, /*                        quad ? APL FUNCTIONAL SYMBOL QUAD */
+  { 0x08ab, 0x239b }, /*               topleftparens ? ??? */
+  { 0x08ac, 0x239d }, /*               botleftparens ? ??? */
+  { 0x08ad, 0x239e }, /*              toprightparens ? ??? */
+  { 0x08ae, 0x23a0 }, /*              botrightparens ? ??? */
+  { 0x08a7, 0x23a1 }, /*            topleftsqbracket ? ??? */
+  { 0x08a8, 0x23a3 }, /*            botleftsqbracket ? ??? */
+  { 0x08a9, 0x23a4 }, /*           toprightsqbracket ? ??? */
+  { 0x08aa, 0x23a6 }, /*           botrightsqbracket ? ??? */
+  { 0x08af, 0x23a8 }, /*        leftmiddlecurlybrace ? ??? */
+  { 0x08b0, 0x23ac }, /*       rightmiddlecurlybrace ? ??? */
+  { 0x08a1, 0x23b7 }, /*                 leftradical ? ??? */
+  { 0x09ef, 0x23ba }, /*              horizlinescan1 ? HORIZONTAL SCAN LINE-1 (Unicode 3.2 draft) */
+  { 0x09f0, 0x23bb }, /*              horizlinescan3 ? HORIZONTAL SCAN LINE-3 (Unicode 3.2 draft) */
+  { 0x09f2, 0x23bc }, /*              horizlinescan7 ? HORIZONTAL SCAN LINE-7 (Unicode 3.2 draft) */
+  { 0x09f3, 0x23bd }, /*              horizlinescan9 ? HORIZONTAL SCAN LINE-9 (Unicode 3.2 draft) */
+  { 0x09e2, 0x2409 }, /*                          ht ? SYMBOL FOR HORIZONTAL TABULATION */
+  { 0x09e5, 0x240a }, /*                          lf ? SYMBOL FOR LINE FEED */
+  { 0x09e9, 0x240b }, /*                          vt ? SYMBOL FOR VERTICAL TABULATION */
+  { 0x09e3, 0x240c }, /*                          ff ? SYMBOL FOR FORM FEED */
+  { 0x09e4, 0x240d }, /*                          cr ? SYMBOL FOR CARRIAGE RETURN */
+  { 0x09e8, 0x2424 }, /*                          nl ? SYMBOL FOR NEWLINE */
+  { 0x08a3, 0x2500 }, /*              horizconnector  BOX DRAWINGS LIGHT HORIZONTAL */
+  { 0x09f1, 0x2500 }, /*              horizlinescan5  BOX DRAWINGS LIGHT HORIZONTAL */
+  { 0x09f8, 0x2502 }, /*                     vertbar  BOX DRAWINGS LIGHT VERTICAL */
+  { 0x08a6, 0x2502 }, /*               vertconnector  BOX DRAWINGS LIGHT VERTICAL */
+  { 0x08a2, 0x250c }, /*              topleftradical  BOX DRAWINGS LIGHT DOWN AND RIGHT */
+  { 0x09ec, 0x250c }, /*                upleftcorner  BOX DRAWINGS LIGHT DOWN AND RIGHT */
+  { 0x09eb, 0x2510 }, /*               uprightcorner  BOX DRAWINGS LIGHT DOWN AND LEFT */
+  { 0x09ed, 0x2514 }, /*               lowleftcorner  BOX DRAWINGS LIGHT UP AND RIGHT */
+  { 0x09ea, 0x2518 }, /*              lowrightcorner  BOX DRAWINGS LIGHT UP AND LEFT */
+  { 0x09f4, 0x251c }, /*                       leftt  BOX DRAWINGS LIGHT VERTICAL AND RIGHT */
+  { 0x09f5, 0x2524 }, /*                      rightt  BOX DRAWINGS LIGHT VERTICAL AND LEFT */
+  { 0x09f7, 0x252c }, /*                        topt  BOX DRAWINGS LIGHT DOWN AND HORIZONTAL */
+  { 0x09f6, 0x2534 }, /*                        bott  BOX DRAWINGS LIGHT UP AND HORIZONTAL */
+  { 0x09ee, 0x253c }, /*               crossinglines  BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL */
+  { 0x09e1, 0x2592 }, /*                checkerboard  MEDIUM SHADE */
+  { 0x0ae7, 0x25aa }, /*            enfilledsqbullet ? BLACK SMALL SQUARE */
+  { 0x0ae1, 0x25ab }, /*          enopensquarebullet ? WHITE SMALL SQUARE */
+  { 0x0adb, 0x25ac }, /*            filledrectbullet ? BLACK RECTANGLE */
+  { 0x0ae2, 0x25ad }, /*              openrectbullet ? WHITE RECTANGLE */
+  { 0x0adf, 0x25ae }, /*                emfilledrect ? BLACK VERTICAL RECTANGLE */
+  { 0x0acf, 0x25af }, /*             emopenrectangle ? WHITE VERTICAL RECTANGLE */
+  { 0x0ae8, 0x25b2 }, /*           filledtribulletup ? BLACK UP-POINTING TRIANGLE */
+  { 0x0ae3, 0x25b3 }, /*             opentribulletup ? WHITE UP-POINTING TRIANGLE */
+  { 0x0add, 0x25b6 }, /*        filledrighttribullet ? BLACK RIGHT-POINTING TRIANGLE */
+  { 0x0acd, 0x25b7 }, /*           rightopentriangle ? WHITE RIGHT-POINTING TRIANGLE */
+  { 0x0ae9, 0x25bc }, /*         filledtribulletdown ? BLACK DOWN-POINTING TRIANGLE */
+  { 0x0ae4, 0x25bd }, /*           opentribulletdown ? WHITE DOWN-POINTING TRIANGLE */
+  { 0x0adc, 0x25c0 }, /*         filledlefttribullet ? BLACK LEFT-POINTING TRIANGLE */
+  { 0x0acc, 0x25c1 }, /*            leftopentriangle ? WHITE LEFT-POINTING TRIANGLE */
+  { 0x09e0, 0x25c6 }, /*                soliddiamond ? BLACK DIAMOND */
+  { 0x0bcf, 0x25cb }, /*                      circle ? WHITE CIRCLE */
+  { 0x0ace, 0x25cb }, /*                emopencircle ? WHITE CIRCLE */
+  { 0x0ade, 0x25cf }, /*              emfilledcircle ? BLACK CIRCLE */
+  { 0x0ae0, 0x25e6 }, /*            enopencircbullet ? WHITE BULLET */
+  { 0x0ae5, 0x2606 }, /*                    openstar ? WHITE STAR */
+  { 0x0af9, 0x260e }, /*                   telephone ? BLACK TELEPHONE */
+  { 0x0aca, 0x2613 }, /*               signaturemark ? SALTIRE */
+  { 0x0aea, 0x261c }, /*                 leftpointer ? WHITE LEFT POINTING INDEX */
+  { 0x0aeb, 0x261e }, /*                rightpointer ? WHITE RIGHT POINTING INDEX */
+  { 0x0af8, 0x2640 }, /*                femalesymbol ? FEMALE SIGN */
+  { 0x0af7, 0x2642 }, /*                  malesymbol ? MALE SIGN */
+  { 0x0aec, 0x2663 }, /*                        club ? BLACK CLUB SUIT */
+  { 0x0aee, 0x2665 }, /*                       heart ? BLACK HEART SUIT */
+  { 0x0aed, 0x2666 }, /*                     diamond ? BLACK DIAMOND SUIT */
+  { 0x0af6, 0x266d }, /*                 musicalflat ? MUSIC FLAT SIGN */
+  { 0x0af5, 0x266f }, /*                musicalsharp ? MUSIC SHARP SIGN */
+  { 0x0af3, 0x2713 }, /*                   checkmark ? CHECK MARK */
+  { 0x0af4, 0x2717 }, /*                 ballotcross ? BALLOT X */
+  { 0x0ad9, 0x271d }, /*                  latincross ? LATIN CROSS */
+  { 0x0af0, 0x2720 }, /*                maltesecross ? MALTESE CROSS */
+  { 0x04a4, 0x3001 }, /*                  kana_comma ? IDEOGRAPHIC COMMA */
+  { 0x04a1, 0x3002 }, /*               kana_fullstop ? IDEOGRAPHIC FULL STOP */
+  { 0x04a2, 0x300c }, /*         kana_openingbracket ? LEFT CORNER BRACKET */
+  { 0x04a3, 0x300d }, /*         kana_closingbracket ? RIGHT CORNER BRACKET */
+  { 0x04de, 0x309b }, /*                 voicedsound ? KATAKANA-HIRAGANA VOICED SOUND MARK */
+  { 0x04df, 0x309c }, /*             semivoicedsound ? KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK */
+  { 0x04a7, 0x30a1 }, /*                      kana_a ? KATAKANA LETTER SMALL A */
+  { 0x04b1, 0x30a2 }, /*                      kana_A ? KATAKANA LETTER A */
+  { 0x04a8, 0x30a3 }, /*                      kana_i ? KATAKANA LETTER SMALL I */
+  { 0x04b2, 0x30a4 }, /*                      kana_I ? KATAKANA LETTER I */
+  { 0x04a9, 0x30a5 }, /*                      kana_u ? KATAKANA LETTER SMALL U */
+  { 0x04b3, 0x30a6 }, /*                      kana_U ? KATAKANA LETTER U */
+  { 0x04aa, 0x30a7 }, /*                      kana_e ? KATAKANA LETTER SMALL E */
+  { 0x04b4, 0x30a8 }, /*                      kana_E ? KATAKANA LETTER E */
+  { 0x04ab, 0x30a9 }, /*                      kana_o ? KATAKANA LETTER SMALL O */
+  { 0x04b5, 0x30aa }, /*                      kana_O ? KATAKANA LETTER O */
+  { 0x04b6, 0x30ab }, /*                     kana_KA ? KATAKANA LETTER KA */
+  { 0x04b7, 0x30ad }, /*                     kana_KI ? KATAKANA LETTER KI */
+  { 0x04b8, 0x30af }, /*                     kana_KU ? KATAKANA LETTER KU */
+  { 0x04b9, 0x30b1 }, /*                     kana_KE ? KATAKANA LETTER KE */
+  { 0x04ba, 0x30b3 }, /*                     kana_KO ? KATAKANA LETTER KO */
+  { 0x04bb, 0x30b5 }, /*                     kana_SA ? KATAKANA LETTER SA */
+  { 0x04bc, 0x30b7 }, /*                    kana_SHI ? KATAKANA LETTER SI */
+  { 0x04bd, 0x30b9 }, /*                     kana_SU ? KATAKANA LETTER SU */
+  { 0x04be, 0x30bb }, /*                     kana_SE ? KATAKANA LETTER SE */
+  { 0x04bf, 0x30bd }, /*                     kana_SO ? KATAKANA LETTER SO */
+  { 0x04c0, 0x30bf }, /*                     kana_TA ? KATAKANA LETTER TA */
+  { 0x04c1, 0x30c1 }, /*                    kana_CHI ? KATAKANA LETTER TI */
+  { 0x04af, 0x30c3 }, /*                    kana_tsu ? KATAKANA LETTER SMALL TU */
+  { 0x04c2, 0x30c4 }, /*                    kana_TSU ? KATAKANA LETTER TU */
+  { 0x04c3, 0x30c6 }, /*                     kana_TE ? KATAKANA LETTER TE */
+  { 0x04c4, 0x30c8 }, /*                     kana_TO ? KATAKANA LETTER TO */
+  { 0x04c5, 0x30ca }, /*                     kana_NA ? KATAKANA LETTER NA */
+  { 0x04c6, 0x30cb }, /*                     kana_NI ? KATAKANA LETTER NI */
+  { 0x04c7, 0x30cc }, /*                     kana_NU ? KATAKANA LETTER NU */
+  { 0x04c8, 0x30cd }, /*                     kana_NE ? KATAKANA LETTER NE */
+  { 0x04c9, 0x30ce }, /*                     kana_NO ? KATAKANA LETTER NO */
+  { 0x04ca, 0x30cf }, /*                     kana_HA ? KATAKANA LETTER HA */
+  { 0x04cb, 0x30d2 }, /*                     kana_HI ? KATAKANA LETTER HI */
+  { 0x04cc, 0x30d5 }, /*                     kana_FU ? KATAKANA LETTER HU */
+  { 0x04cd, 0x30d8 }, /*                     kana_HE ? KATAKANA LETTER HE */
+  { 0x04ce, 0x30db }, /*                     kana_HO ? KATAKANA LETTER HO */
+  { 0x04cf, 0x30de }, /*                     kana_MA ? KATAKANA LETTER MA */
+  { 0x04d0, 0x30df }, /*                     kana_MI ? KATAKANA LETTER MI */
+  { 0x04d1, 0x30e0 }, /*                     kana_MU ? KATAKANA LETTER MU */
+  { 0x04d2, 0x30e1 }, /*                     kana_ME ? KATAKANA LETTER ME */
+  { 0x04d3, 0x30e2 }, /*                     kana_MO ? KATAKANA LETTER MO */
+  { 0x04ac, 0x30e3 }, /*                     kana_ya ? KATAKANA LETTER SMALL YA */
+  { 0x04d4, 0x30e4 }, /*                     kana_YA ? KATAKANA LETTER YA */
+  { 0x04ad, 0x30e5 }, /*                     kana_yu ? KATAKANA LETTER SMALL YU */
+  { 0x04d5, 0x30e6 }, /*                     kana_YU ? KATAKANA LETTER YU */
+  { 0x04ae, 0x30e7 }, /*                     kana_yo ? KATAKANA LETTER SMALL YO */
+  { 0x04d6, 0x30e8 }, /*                     kana_YO ? KATAKANA LETTER YO */
+  { 0x04d7, 0x30e9 }, /*                     kana_RA ? KATAKANA LETTER RA */
+  { 0x04d8, 0x30ea }, /*                     kana_RI ? KATAKANA LETTER RI */
+  { 0x04d9, 0x30eb }, /*                     kana_RU ? KATAKANA LETTER RU */
+  { 0x04da, 0x30ec }, /*                     kana_RE ? KATAKANA LETTER RE */
+  { 0x04db, 0x30ed }, /*                     kana_RO ? KATAKANA LETTER RO */
+  { 0x04dc, 0x30ef }, /*                     kana_WA ? KATAKANA LETTER WA */
+  { 0x04a6, 0x30f2 }, /*                     kana_WO ? KATAKANA LETTER WO */
+  { 0x04dd, 0x30f3 }, /*                      kana_N ? KATAKANA LETTER N */
+  { 0x04a5, 0x30fb }, /*            kana_conjunctive ? KATAKANA MIDDLE DOT */
+  { 0x04b0, 0x30fc }, /*              prolongedsound ? KATAKANA-HIRAGANA PROLONGED SOUND MARK */
+  { 0x0ea1, 0x3131 }, /*               Hangul_Kiyeog ? HANGUL LETTER KIYEOK */
+  { 0x0ea2, 0x3132 }, /*          Hangul_SsangKiyeog ? HANGUL LETTER SSANGKIYEOK */
+  { 0x0ea3, 0x3133 }, /*           Hangul_KiyeogSios ? HANGUL LETTER KIYEOK-SIOS */
+  { 0x0ea4, 0x3134 }, /*                Hangul_Nieun ? HANGUL LETTER NIEUN */
+  { 0x0ea5, 0x3135 }, /*           Hangul_NieunJieuj ? HANGUL LETTER NIEUN-CIEUC */
+  { 0x0ea6, 0x3136 }, /*           Hangul_NieunHieuh ? HANGUL LETTER NIEUN-HIEUH */
+  { 0x0ea7, 0x3137 }, /*               Hangul_Dikeud ? HANGUL LETTER TIKEUT */
+  { 0x0ea8, 0x3138 }, /*          Hangul_SsangDikeud ? HANGUL LETTER SSANGTIKEUT */
+  { 0x0ea9, 0x3139 }, /*                Hangul_Rieul ? HANGUL LETTER RIEUL */
+  { 0x0eaa, 0x313a }, /*          Hangul_RieulKiyeog ? HANGUL LETTER RIEUL-KIYEOK */
+  { 0x0eab, 0x313b }, /*           Hangul_RieulMieum ? HANGUL LETTER RIEUL-MIEUM */
+  { 0x0eac, 0x313c }, /*           Hangul_RieulPieub ? HANGUL LETTER RIEUL-PIEUP */
+  { 0x0ead, 0x313d }, /*            Hangul_RieulSios ? HANGUL LETTER RIEUL-SIOS */
+  { 0x0eae, 0x313e }, /*           Hangul_RieulTieut ? HANGUL LETTER RIEUL-THIEUTH */
+  { 0x0eaf, 0x313f }, /*          Hangul_RieulPhieuf ? HANGUL LETTER RIEUL-PHIEUPH */
+  { 0x0eb0, 0x3140 }, /*           Hangul_RieulHieuh ? HANGUL LETTER RIEUL-HIEUH */
+  { 0x0eb1, 0x3141 }, /*                Hangul_Mieum ? HANGUL LETTER MIEUM */
+  { 0x0eb2, 0x3142 }, /*                Hangul_Pieub ? HANGUL LETTER PIEUP */
+  { 0x0eb3, 0x3143 }, /*           Hangul_SsangPieub ? HANGUL LETTER SSANGPIEUP */
+  { 0x0eb4, 0x3144 }, /*            Hangul_PieubSios ? HANGUL LETTER PIEUP-SIOS */
+  { 0x0eb5, 0x3145 }, /*                 Hangul_Sios ? HANGUL LETTER SIOS */
+  { 0x0eb6, 0x3146 }, /*            Hangul_SsangSios ? HANGUL LETTER SSANGSIOS */
+  { 0x0eb7, 0x3147 }, /*                Hangul_Ieung ? HANGUL LETTER IEUNG */
+  { 0x0eb8, 0x3148 }, /*                Hangul_Jieuj ? HANGUL LETTER CIEUC */
+  { 0x0eb9, 0x3149 }, /*           Hangul_SsangJieuj ? HANGUL LETTER SSANGCIEUC */
+  { 0x0eba, 0x314a }, /*                Hangul_Cieuc ? HANGUL LETTER CHIEUCH */
+  { 0x0ebb, 0x314b }, /*               Hangul_Khieuq ? HANGUL LETTER KHIEUKH */
+  { 0x0ebc, 0x314c }, /*                Hangul_Tieut ? HANGUL LETTER THIEUTH */
+  { 0x0ebd, 0x314d }, /*               Hangul_Phieuf ? HANGUL LETTER PHIEUPH */
+  { 0x0ebe, 0x314e }, /*                Hangul_Hieuh ? HANGUL LETTER HIEUH */
+  { 0x0ebf, 0x314f }, /*                    Hangul_A ? HANGUL LETTER A */
+  { 0x0ec0, 0x3150 }, /*                   Hangul_AE ? HANGUL LETTER AE */
+  { 0x0ec1, 0x3151 }, /*                   Hangul_YA ? HANGUL LETTER YA */
+  { 0x0ec2, 0x3152 }, /*                  Hangul_YAE ? HANGUL LETTER YAE */
+  { 0x0ec3, 0x3153 }, /*                   Hangul_EO ? HANGUL LETTER EO */
+  { 0x0ec4, 0x3154 }, /*                    Hangul_E ? HANGUL LETTER E */
+  { 0x0ec5, 0x3155 }, /*                  Hangul_YEO ? HANGUL LETTER YEO */
+  { 0x0ec6, 0x3156 }, /*                   Hangul_YE ? HANGUL LETTER YE */
+  { 0x0ec7, 0x3157 }, /*                    Hangul_O ? HANGUL LETTER O */
+  { 0x0ec8, 0x3158 }, /*                   Hangul_WA ? HANGUL LETTER WA */
+  { 0x0ec9, 0x3159 }, /*                  Hangul_WAE ? HANGUL LETTER WAE */
+  { 0x0eca, 0x315a }, /*                   Hangul_OE ? HANGUL LETTER OE */
+  { 0x0ecb, 0x315b }, /*                   Hangul_YO ? HANGUL LETTER YO */
+  { 0x0ecc, 0x315c }, /*                    Hangul_U ? HANGUL LETTER U */
+  { 0x0ecd, 0x315d }, /*                  Hangul_WEO ? HANGUL LETTER WEO */
+  { 0x0ece, 0x315e }, /*                   Hangul_WE ? HANGUL LETTER WE */
+  { 0x0ecf, 0x315f }, /*                   Hangul_WI ? HANGUL LETTER WI */
+  { 0x0ed0, 0x3160 }, /*                   Hangul_YU ? HANGUL LETTER YU */
+  { 0x0ed1, 0x3161 }, /*                   Hangul_EU ? HANGUL LETTER EU */
+  { 0x0ed2, 0x3162 }, /*                   Hangul_YI ? HANGUL LETTER YI */
+  { 0x0ed3, 0x3163 }, /*                    Hangul_I ? HANGUL LETTER I */
+  { 0x0eef, 0x316d }, /*     Hangul_RieulYeorinHieuh ? HANGUL LETTER RIEUL-YEORINHIEUH */
+  { 0x0ef0, 0x3171 }, /*    Hangul_SunkyeongeumMieum ? HANGUL LETTER KAPYEOUNMIEUM */
+  { 0x0ef1, 0x3178 }, /*    Hangul_SunkyeongeumPieub ? HANGUL LETTER KAPYEOUNPIEUP */
+  { 0x0ef2, 0x317f }, /*              Hangul_PanSios ? HANGUL LETTER PANSIOS */
+  { 0x0ef3, 0x3181 }, /*    Hangul_KkogjiDalrinIeung ? HANGUL LETTER YESIEUNG */
+  { 0x0ef4, 0x3184 }, /*   Hangul_SunkyeongeumPhieuf ? HANGUL LETTER KAPYEOUNPHIEUPH */
+  { 0x0ef5, 0x3186 }, /*          Hangul_YeorinHieuh ? HANGUL LETTER YEORINHIEUH */
+  { 0x0ef6, 0x318d }, /*                Hangul_AraeA ? HANGUL LETTER ARAEA */
+  { 0x0ef7, 0x318e } /*               Hangul_AraeAE ? HANGUL LETTER ARAEAE */
+/*  0x09df                                     blank ? ??? */
+/*  0x08b2                          botleftsummation ? ??? */
+/*  0x08b6                         botrightsummation ? ??? */
+/*  0x08b4                 botvertsummationconnector ? ??? */
+/*  0x0aff                                    cursor ? ??? */
+/*  0x0abd                              decimalpoint ? ??? */
+/*  0x0ada                                  hexagram ? ??? */
+/*  0x0abf                                    marker ? ??? */
+/*  0x08b7                      rightmiddlesummation ? ??? */
+/*  0x0aac                               signifblank ? ??? */
+/*  0x0dde                    Thai_maihanakat_maitho ? ??? */
+/*  0x08b1                          topleftsummation ? ??? */
+/*  0x08b5                         toprightsummation ? ??? */
+/*  0x08b3                 topvertsummationconnector ? ??? */
+/*  0x0acb                         trademarkincircle ? ??? */
+};
+
+KeySym X11DRV_ucs2keysym(WCHAR wChar)
+{
+  int min = 0;
+  int max = sizeof(keysymtab) / sizeof(struct codepair) - 1;
+  int mid;
+  char cChar[4];
+
+  /* binary search in table */
+   if(wChar <= 0x07f)
+   {
+        WideCharToMultiByte(CP_ACP, 0, &wChar, 1, &cChar[0], 4, NULL, NULL);
+        return  (unsigned char)cChar[0];
+   }
+
+   while (max >= min)
+   {
+    mid = (min + max) / 2 ;
+    if (keysymtab[mid].ucs <  wChar)
+      min = mid + 1;
+    else if (keysymtab[mid].ucs > wChar)
+      max = mid - 1;
+    else       /* found it */
+    return keysymtab[mid].keysym;
+   }
+
+  /* no matching keysym value found */
+  return -1;
+}
+
diff -uHNrp wine-20071130/dlls/winex11.drv/window.c wine-20071130e/dlls/winex11.drv/window.c
--- wine-20071130/dlls/winex11.drv/window.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/winex11.drv/window.c	2008-02-04 18:31:20.000000000 +0300
@@ -45,6 +45,7 @@
 #include "wine/server.h"
 #include "win.h"
 #include "mwm.h"
+#include "wine/etersoft.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);
 
@@ -78,21 +79,147 @@ BOOL is_window_managed( HWND hwnd, UINT 
 
     /* tray window is always managed */
     ex_style = GetWindowLongW( hwnd, GWL_EXSTYLE );
+
+    /* EterBug 945 */
+    {
+        char class[80];
+        GetClassNameA(hwnd,class,sizeof class);
+
+        /* Window 'User property' (Konfigurator) for Gnome Manage */
+        LOADETER_FUNC(etersoft_1version);
+        if ( etersoft_1version && (etersoft_1version() == 7) )
+            if (!strcmp(class, "#32770") && (ex_style & WS_EX_TOOLWINDOW) )
+                return FALSE;
+    }
+
     if (ex_style & WS_EX_TRAYWINDOW) return TRUE;
     /* child windows are not managed */
     style = GetWindowLongW( hwnd, GWL_STYLE );
+
+    /* EterBug 1087 */
+    {
+        char class[80];
+        GetClassNameA(hwnd, class, sizeof class);
+        char ParentClass[80];
+        GetClassNameA(GetParent(hwnd), ParentClass, sizeof ParentClass);
+
+        LOADETER_FUNC(etersoft_1version);
+        if ( etersoft_1version && (etersoft_1version() == 7) )
+        {
+            if (!strcmp(class, "#32770") && (ex_style & (WS_EX_DLGMODALFRAME|WS_EX_WINDOWEDGE) ) && (style & ( 0x084c800c0 )) && !strcmp(ParentClass, "#32770") && !(is_window_managed(GetParent(hwnd), 0, NULL)) )
+                return FALSE;
+
+        }
+    }
+
+
     if ((style & (WS_CHILD|WS_POPUP)) == WS_CHILD) return FALSE;
     /* activated windows are managed */
     if (!(swp_flags & (SWP_NOACTIVATE|SWP_HIDEWINDOW))) return TRUE;
     if (hwnd == GetActiveWindow()) return TRUE;
     /* windows with caption are managed */
-    if ((style & WS_CAPTION) == WS_CAPTION) return TRUE;
+    if ((style & WS_CAPTION) == WS_CAPTION)
+    {
+        /* IE Tooltips shouldn't be managed, even if they have a caption.
+         * So check that this isn't a tooltip.
+         *
+         * This fixes a focus-grabbing tooltip on the Google search page.
+         */
+        char class[80];
+        GetClassNameA(hwnd,class,sizeof class);
+        TRACE("CAPTION class=%s\n",class);
+        if (strcmp(class, "tooltips_class32") == 0)
+            return FALSE;
+        LOADETER_FUNC(etersoft_fixtab);
+        if (etersoft_fixtab) {
+            DWORD data = 32770;
+            etersoft_fixtab(&data, sizeof(DWORD*));
+            if (!data && !strcmp(class, "#32770") )
+                return FALSE;
+        }
+        return TRUE;
+    }
     /* tool windows are not managed  */
-    if (ex_style & WS_EX_TOOLWINDOW) return FALSE;
+    if (ex_style & WS_EX_TOOLWINDOW)
+    {
+        char class[80];
+        GetClassNameA(hwnd,class,sizeof class);
+        TRACE("TOOLWINDOW class=%s\n",class);
+        if ( (style & WS_POPUP) && ((strcmp(class,"PSFloatC")==0) ||
+              (strcmp(class,"Internet Explorer_Server")==0)) )
+            return TRUE;
+        /* Dreamweaver MX 2004 floating toolbars */
+        if( !strcmp( class, "Afx:00400000:8:000010DE:00000000:00000000" ) )
+            return TRUE;
+        return !strcmp(class,"MsoSplash") || 
+               !strcmp(class,"ibw:0") || 
+               !strcmp(class,"ibw:1") ||
+               !strcmp(class,"#32770") ||
+               !strcmp(class,"KodeksWin") ||
+               !strcmp(class,"icoCTactTrilly"); /* Trillian buddy window */
+    }
+
     /* windows with thick frame are managed */
     if (style & WS_THICKFRAME) return TRUE;
     /* application windows are managed */
     if (ex_style & WS_EX_APPWINDOW) return TRUE;
+    /*
+     * CODEWEAVERS HACK
+     * Hack to pervent the Quicken splash screen from obscuring 
+     * the password dialog when it is displayed.
+     *
+     * also includes an ugly hack for photoshop 5. This keeps the windows from
+     * being alwayse on top and following the desktop. Just returning TRUE
+     * caused the PS5 windows to become decorated by the windowmanager. and
+     * closing the window with the WM close button caused VERY bad things to
+     * happen inside photoshop.
+     */
+    if (1) 
+    {
+        char class[80];
+        GetClassNameA(hwnd,class,sizeof class);
+        TRACE("FOREVE class=%s\n",class);
+        /*
+         * In Scientific Word, the startup dialog should be managed.
+         * In SAP Netweaver, the tooltips should not (WS_EX_TOPMOST).
+         */
+        if ( (strcmp(class,"#32770")==0) &&
+            !(ex_style & WS_EX_TOPMOST) )
+            return TRUE;
+        if (strcmp(class,"SplashWnd")==0)
+            return TRUE;
+        if (strcmp(class,"iTunes")==0)
+            return TRUE;
+        if (strcmp(class,"PSFloatC")==0)
+        {
+            ex_style |= WS_EX_TOOLWINDOW;
+            return TRUE;
+        }
+        /* the office 97 splash screen is not a toolbar */
+        if (strcmp(class,"MsoSplash") == 0)
+            return TRUE;
+        if ((strcmp(class,"IEFrame") == 0) && (style & WS_SYSMENU))
+            return TRUE;
+        /* for CRPSClient for WorldVistA */
+        if (strcmp(class,"TfrmSplash") == 0)
+            return TRUE;
+        /* Halo setup window */
+        if (strcmp(class,"EBUSetupWnd") == 0)
+            return TRUE;
+        /* Steam window */
+        if (strcmp(class,"Surface")==0)
+            return TRUE;
+        /* Some TApplication */
+        if (strcmp(class,"TSplashForm")==0)
+            return TRUE;
+        if (strcmp(class,"TfmAbout")==0)
+            return TRUE;
+        /* for VentaFax */
+        if (strcmp(class,"TTitleBox")==0)
+            return TRUE;
+    }
+
+
     if (style & WS_POPUP)
     {
         /* popup with sysmenu == caption are managed */
@@ -511,6 +638,48 @@ static void destroy_icon_window( Display
     RemovePropA( data->hwnd, icon_window_prop );
 }
 
+/***********************************************************************
+ *              X11DRV_is_maximize_window
+ *
+ * Verify if the window is maximize
+ */
+BOOL X11DRV_is_maximize_window( HWND hwnd )
+{
+    Display *display = thread_display();
+    struct x11drv_win_data *data;
+    BOOL ret = FALSE;
+
+    Atom ret_atom;
+    int actual_type;
+    unsigned long num_prop;
+    unsigned long readbytes;
+    unsigned char *buff = NULL;
+
+    if (!(data = X11DRV_get_win_data( hwnd ))) return FALSE;
+    if (!data->whole_window || data->whole_window == DefaultRootWindow(display)) return FALSE;
+
+    wine_tsx11_lock();
+
+    ret = XGetWindowProperty (display, data->whole_window, x11drv_atom(_NET_WM_STATE),
+                       0, 65538, False, XA_ATOM, &ret_atom, 
+                       &actual_type, &num_prop, &readbytes, &buff);
+    if (ret == Success && buff)
+    {
+       int i;
+       Atom maxhorz = x11drv_atom(_NET_WM_STATE_MAXIMIZED_HORZ);
+       Atom maxvert = x11drv_atom(_NET_WM_STATE_MAXIMIZED_VERT);
+       Atom *atoms = (Atom *)buff;
+       BOOL mh = FALSE, mv = FALSE;
+       for (i = 0;  i < num_prop ; i++) {
+           if ( maxhorz == atoms[i] ) mh = TRUE;
+           if ( maxvert == atoms[i] ) mv = TRUE;
+       }
+       if (mh && mv) ret = TRUE; else ret = FALSE;
+    }
+    wine_tsx11_unlock();
+
+    return ret;
+}
 
 /***********************************************************************
  *              set_icon_hints
@@ -741,6 +910,7 @@ static void set_initial_wm_hints( Displa
     Atom dndVersion = 4;
     XClassHint *class_hints;
     char *process_name = get_process_name();
+    char wclass[80];
 
     wine_tsx11_lock();
 
@@ -748,7 +918,12 @@ static void set_initial_wm_hints( Displa
     i = 0;
     protocols[i++] = x11drv_atom(WM_DELETE_WINDOW);
     protocols[i++] = x11drv_atom(_NET_WM_PING);
-    if (use_take_focus) protocols[i++] = x11drv_atom(WM_TAKE_FOCUS);
+
+    /* Eterbug`s 729 */
+    GetClassNameA(data -> hwnd, wclass,sizeof wclass);
+    if (strcmp(wclass, "V8PopupBar") != 0)
+        if (use_take_focus) protocols[i++] = x11drv_atom(WM_TAKE_FOCUS); 
+    
     XChangeProperty( display, data->whole_window, x11drv_atom(WM_PROTOCOLS),
                      XA_ATOM, 32, PropModeReplace, (unsigned char *)protocols, i );
 
@@ -1163,6 +1338,19 @@ void X11DRV_DestroyWindow( HWND hwnd )
     Display *display = thread_data->display;
     struct x11drv_win_data *data;
 
+    LOADETER_FUNC(etersoft_1version);
+    if ( etersoft_1version && !etersoft_1version() )
+    {
+        if( (GetWindowLongW(hwnd, GWL_STYLE) & WS_CAPTION))
+        {
+            wine_tsx11_lock();
+            XSetInputFocus( display, PointerRoot, RevertToPointerRoot, 0 );
+            wine_tsx11_unlock();
+            EnableWindow( GetParent( hwnd ), TRUE );
+        }
+    }
+
+
     if (!(data = X11DRV_get_win_data( hwnd ))) return;
 
     if (data->pixmap)
diff -uHNrp wine-20071130/dlls/winex11.drv/winpos.c wine-20071130e/dlls/winex11.drv/winpos.c
--- wine-20071130/dlls/winex11.drv/winpos.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/winex11.drv/winpos.c	2008-02-04 18:31:20.000000000 +0300
@@ -415,7 +415,11 @@ BOOL X11DRV_SetWindowPos( HWND hwnd, HWN
 
                 if (mapped)
                 {
-                    X11DRV_sync_window_style( display, data );
+                     /* Eterbug 729 */
+                    char class[80];
+                    GetClassNameA(hwnd,class,sizeof class);
+                    if (strcmp(class, "V8PopupBar") != 0)
+                        X11DRV_sync_window_style( display, data );
                     wine_tsx11_lock();
                     XMapWindow( display, data->whole_window );
                     XFlush( display );
@@ -571,15 +575,12 @@ UINT WINPOS_MinMaximize( HWND hwnd, UINT
         old_style = WIN_SetStyle( hwnd, 0, WS_MINIMIZE | WS_MAXIMIZE );
         if (old_style & WS_MINIMIZE)
         {
-            BOOL restore_max;
-
             WINPOS_ShowIconTitle( hwnd, FALSE );
             X11DRV_set_iconic_state( hwnd );
 
             if (!(wndPtr = WIN_GetPtr( hwnd )) || wndPtr == WND_OTHER_PROCESS) return 0;
-            restore_max = (wndPtr->flags & WIN_RESTORE_MAX) != 0;
             WIN_ReleasePtr( wndPtr );
-            if (restore_max)
+            if (wndPtr->flags & WIN_RESTORE_MAX)
             {
                 /* Restore to maximized position */
                 WINPOS_GetMinMaxInfo( hwnd, &size, &wpl.ptMaxPosition, NULL, NULL);
@@ -613,6 +614,7 @@ BOOL X11DRV_ShowWindow( HWND hwnd, INT c
 {
     WND *wndPtr;
     HWND parent;
+    struct x11drv_win_data *data;
     LONG style = GetWindowLongW( hwnd, GWL_STYLE );
     BOOL wasVisible = (style & WS_VISIBLE) != 0;
     BOOL showFlag = TRUE;
@@ -640,8 +642,11 @@ BOOL X11DRV_ShowWindow( HWND hwnd, INT c
             /* fall through */
 	case SW_SHOWMINIMIZED:
             swp |= SWP_SHOWWINDOW | SWP_FRAMECHANGED;
+            data = X11DRV_get_win_data( hwnd );
+            if (!wasVisible && data && data->managed)
+                X11DRV_ShowWindow(hwnd, SW_SHOW);
             swp |= WINPOS_MinMaximize( hwnd, cmd, &newPos );
-            if ((style & WS_MINIMIZE) && wasVisible) return TRUE;
+            if (((style & WS_MINIMIZE) || (data && data->managed)) && wasVisible) return TRUE;
 	    break;
 
 	case SW_SHOWMAXIMIZED: /* same as SW_MAXIMIZE */
@@ -911,6 +916,7 @@ void X11DRV_ConfigureNotify( HWND hwnd, 
     struct x11drv_win_data *data;
     RECT rect;
     UINT flags;
+    WND *win;
     int cx, cy, x = event->x, y = event->y;
 
     if (!hwnd) return;
@@ -942,6 +948,19 @@ void X11DRV_ConfigureNotify( HWND hwnd, 
     cy    = rect.bottom - rect.top;
     flags = SWP_NOACTIVATE | SWP_NOZORDER;
 
+    if ((win = WIN_GetPtr( hwnd )))
+    {
+        if (X11DRV_is_window_rect_mapped( &data->window_rect))
+        {
+            BOOL bmax = X11DRV_is_maximize_window(hwnd);
+            if (bmax && !(win->dwStyle & WS_MAXIMIZE))
+                WIN_SetStyle( hwnd, WS_MAXIMIZE, WS_MINIMIZE );
+            else if (!bmax && (win->dwStyle & WS_MAXIMIZE))
+                WIN_SetStyle( hwnd, 0, WS_MAXIMIZE );
+        }
+        WIN_ReleasePtr( win );
+    }
+
     /* Compare what has changed */
 
     GetWindowRect( hwnd, &rect );
@@ -954,7 +973,8 @@ void X11DRV_ConfigureNotify( HWND hwnd, 
         IsIconic(hwnd) ||
         (IsRectEmpty( &rect ) && event->width == 1 && event->height == 1))
     {
-        if (flags & SWP_NOMOVE) return;  /* if nothing changed, don't do anything */
+        
+        if (flags & SWP_NOMOVE){ SendMessageA(hwnd,WM_PAINT, 0 ,0);  return;}  /* if nothing changed, don't do anything */
         flags |= SWP_NOSIZE;
     }
     else
diff -uHNrp wine-20071130/dlls/winex11.drv/x11drv.h wine-20071130e/dlls/winex11.drv/x11drv.h
--- wine-20071130/dlls/winex11.drv/x11drv.h	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/winex11.drv/x11drv.h	2008-02-04 18:31:20.000000000 +0300
@@ -580,6 +580,8 @@ enum x11drv_atoms
     XATOM__NET_WM_STATE,
     XATOM__NET_WM_STATE_ABOVE,
     XATOM__NET_WM_STATE_FULLSCREEN,
+    XATOM__NET_WM_STATE_MAXIMIZED_HORZ,
+    XATOM__NET_WM_STATE_MAXIMIZED_VERT,
     XATOM__NET_WM_STATE_SKIP_PAGER,
     XATOM__NET_WM_STATE_SKIP_TASKBAR,
     XATOM__NET_WM_WINDOW_TYPE,
@@ -720,6 +722,7 @@ extern void X11DRV_expect_error( Display
 extern int X11DRV_check_error(void);
 extern BOOL is_window_managed( HWND hwnd, UINT swp_flags, const RECT *window_rect );
 extern void X11DRV_set_iconic_state( HWND hwnd );
+extern BOOL X11DRV_is_maximize_window( HWND hwnd );
 extern void X11DRV_window_to_X_rect( struct x11drv_win_data *data, RECT *rect );
 extern void X11DRV_X_to_window_rect( struct x11drv_win_data *data, RECT *rect );
 extern void X11DRV_sync_window_style( Display *display, struct x11drv_win_data *data );
diff -uHNrp wine-20071130/dlls/winex11.drv/x11drv_main.c wine-20071130e/dlls/winex11.drv/x11drv_main.c
--- wine-20071130/dlls/winex11.drv/x11drv_main.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/winex11.drv/x11drv_main.c	2008-02-04 18:31:20.000000000 +0300
@@ -137,6 +137,8 @@ static const char * const atom_names[NB_
     "_NET_WM_STATE",
     "_NET_WM_STATE_ABOVE",
     "_NET_WM_STATE_FULLSCREEN",
+    "_NET_WM_STATE_MAXIMIZED_HORZ",
+    "_NET_WM_STATE_MAXIMIZED_VERT",
     "_NET_WM_STATE_SKIP_PAGER",
     "_NET_WM_STATE_SKIP_TASKBAR",
     "_NET_WM_WINDOW_TYPE",
diff -uHNrp wine-20071130/dlls/winex11.drv/xfont.c wine-20071130e/dlls/winex11.drv/xfont.c
--- wine-20071130/dlls/winex11.drv/xfont.c	2007-12-01 21:14:17.000000000 +0300
+++ wine-20071130e/dlls/winex11.drv/xfont.c	2008-02-04 18:31:20.000000000 +0300
@@ -3219,11 +3219,15 @@ HFONT X11DRV_SelectFont( X11DRV_PDEVICE 
     if(gdiFont && using_client_side_fonts) {
         X11DRV_XRender_SelectFont(physDev, hfont);
         physDev->has_gdi_font = TRUE;
-	return FALSE;
+        return FALSE;
     }
 
     EnterCriticalSection( &crtsc_fonts_X11 );
 
+    if(fontList == NULL) {
+        ERR("Etersoft notes: Broken wine build or ttf fonts missed in system. Check libXrender-devel package presence during build\n");
+        exit(1);
+    }
     if(fontList == NULL) X11DRV_FONT_InitX11Metrics();
 
     if( CHECK_PFONT(physDev->font) )
diff -uHNrp wine-20071130/dlls/wininet/http.c wine-20071130e/dlls/wininet/http.c
--- wine-20071130/dlls/wininet/http.c	2007-12-01 21:14:21.000000000 +0300
+++ wine-20071130e/dlls/wininet/http.c	2008-02-04 18:31:20.000000000 +0300
@@ -3564,8 +3564,8 @@ static BOOL HTTP_VerifyValidHeader(LPWIN
     BOOL rc = TRUE;
 
     /* Accept-Encoding is stripped from HTTP/1.0 requests. It is invalid */
-    if (strcmpiW(field,szAccept_Encoding)==0)
-        return FALSE;
+  /*  if (strcmpiW(field,szAccept_Encoding)==0)
+        return FALSE;*/
 
     return rc;
 }
diff -uHNrp wine-20071130/dlls/winspool.drv/info.c wine-20071130e/dlls/winspool.drv/info.c
--- wine-20071130/dlls/winspool.drv/info.c	2007-12-01 21:14:16.000000000 +0300
+++ wine-20071130e/dlls/winspool.drv/info.c	2008-02-04 18:31:20.000000000 +0300
@@ -38,6 +38,8 @@
 #include <signal.h>
 #ifdef HAVE_CUPS_CUPS_H
 # include <cups/cups.h>
+#else
+# warning "Etersoft strictly recommended build with CUPS"
 #endif
 
 #define NONAMELESSUNION
@@ -1626,7 +1628,7 @@ void WINSPOOL_LoadSystemPrinters(void)
         if(RegQueryInfoKeyA(hkeyPrinters, NULL, NULL, NULL, &num, NULL, NULL,
                             NULL, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
             for(i = 0; i < num; i++) {
-                if(RegEnumKeyW(hkeyPrinters, i, PrinterName, sizeof(PrinterName)) == ERROR_SUCCESS) {
+                if(RegEnumKeyW(hkeyPrinters, i, PrinterName, sizeof(PrinterName)/sizeof(PrinterName[0])) == ERROR_SUCCESS) {
                     if(RegOpenKeyW(hkeyPrinters, PrinterName, &hkey) == ERROR_SUCCESS) {
                         if(RegQueryValueExW(hkey, NameW, 0, 0, 0, &needed) == ERROR_FILE_NOT_FOUND) {
                             set_reg_szW(hkey, NameW, PrinterName);
@@ -4276,7 +4278,7 @@ static BOOL WINSPOOL_EnumPrinters(DWORD 
     pi = (used <= cbBuf) ? lpbPrinters : NULL;
 
     for(i = 0; i < number; i++) {
-        if(RegEnumKeyW(hkeyPrinters, i, PrinterName, sizeof(PrinterName)) !=
+        if(RegEnumKeyW(hkeyPrinters, i, PrinterName, sizeof(PrinterName)/sizeof(PrinterName[0])) !=
 	   ERROR_SUCCESS) {
 	    ERR("Can't enum key number %d\n", i);
 	    RegCloseKey(hkeyPrinters);
@@ -4506,7 +4508,7 @@ static BOOL WINSPOOL_GetDriverInfoFromRe
              WideCharToMultiByte(CP_ACP, 0, driverdir, -1, NULL, 0, NULL, NULL) -1;
 
     if (!DriverName[0] || RegOpenKeyW(hkeyDrivers, DriverName, &hkeyDriver) != ERROR_SUCCESS) {
-        ERR("Can't find driver %s in registry\n", debugstr_w(DriverName));
+        TRACE("Can't find driver %s in registry\n", debugstr_w(DriverName));
         SetLastError(ERROR_UNKNOWN_PRINTER_DRIVER); /* ? */
         return FALSE;
     }
@@ -4794,8 +4796,19 @@ BOOL WINAPI GetPrinterDriverA(HANDLE hPr
     PWSTR pwstrEnvW;
     
     pwstrEnvW = asciitounicode(&pEnvW, pEnvironment);
+
     ret = WINSPOOL_GetPrinterDriver(hPrinter, pwstrEnvW, Level, pDriverInfo,
 				    cbBuf, pcbNeeded, FALSE);
+
+    /* Etersoft: try to get driver entry from two places, if pEnvironment failed */
+    if (!ret) {
+        ret = WINSPOOL_GetPrinterDriver(hPrinter, envname_x86W, Level, pDriverInfo,
+				    cbBuf, pcbNeeded, FALSE);
+	if (!ret)
+            ret = WINSPOOL_GetPrinterDriver(hPrinter, envname_win40W, Level, pDriverInfo,
+				    cbBuf, pcbNeeded, FALSE);
+    }
+
     RtlFreeUnicodeString(&pEnvW);
     return ret;
 }
@@ -4806,8 +4819,19 @@ BOOL WINAPI GetPrinterDriverW(HANDLE hPr
                                   DWORD Level, LPBYTE pDriverInfo,
                                   DWORD cbBuf, LPDWORD pcbNeeded)
 {
-    return WINSPOOL_GetPrinterDriver(hPrinter, pEnvironment, Level,
-				     pDriverInfo, cbBuf, pcbNeeded, TRUE);
+    BOOL ret;
+    ret = WINSPOOL_GetPrinterDriver(hPrinter, pEnvironment, Level, pDriverInfo,
+				    cbBuf, pcbNeeded, TRUE);
+
+    /* Etersoft: try to get driver entry from two places, if pEnvironment failed */
+    if (!ret) {
+        ret = WINSPOOL_GetPrinterDriver(hPrinter, envname_x86W, Level, pDriverInfo,
+				    cbBuf, pcbNeeded, TRUE);
+	if (!ret)
+            ret = WINSPOOL_GetPrinterDriver(hPrinter, envname_win40W, Level, pDriverInfo,
+				    cbBuf, pcbNeeded, TRUE);
+    }
+    return ret;
 }
 
 /*****************************************************************************
@@ -5177,7 +5201,7 @@ static BOOL WINSPOOL_EnumPrinterDrivers(
     for( i = 0,  ptr = (pDriverInfo && (cbBuf >= size)) ? pDriverInfo : NULL ;
          i < number;
          i++, ptr = (ptr && (cbBuf >= size * i)) ? ptr + size : NULL) {
-        if(RegEnumKeyW(hkeyDrivers, i, DriverNameW, sizeof(DriverNameW))
+        if(RegEnumKeyW(hkeyDrivers, i, DriverNameW, sizeof(DriverNameW)/sizeof(DriverNameW[0]))
                        != ERROR_SUCCESS) {
             ERR("Can't enum key number %d\n", i);
             RegCloseKey(hkeyDrivers);
@@ -5214,8 +5238,20 @@ BOOL WINAPI EnumPrinterDriversW(LPWSTR p
                                 LPBYTE pDriverInfo, DWORD cbBuf,
                                 LPDWORD pcbNeeded, LPDWORD pcReturned)
 {
-    return WINSPOOL_EnumPrinterDrivers(pName, pEnvironment, Level, pDriverInfo,
+    BOOL ret;
+    ret = WINSPOOL_EnumPrinterDrivers(pName, pEnvironment, Level, pDriverInfo,
                                        cbBuf, pcbNeeded, pcReturned, TRUE);
+    /* Etersoft: try to get driver entry from two places, ignore pEnvironment */
+    if (!ret) {
+        ret = WINSPOOL_EnumPrinterDrivers(pName, envname_x86W,
+                                      Level, pDriverInfo, cbBuf, pcbNeeded,
+                                      pcReturned, TRUE);
+        if (!ret)
+            ret = WINSPOOL_EnumPrinterDrivers(pName, envname_win40W,
+                                      Level, pDriverInfo, cbBuf, pcbNeeded,
+                                      pcReturned, TRUE);
+    }
+    return ret;
 }
 
 /*****************************************************************************
@@ -5236,6 +5272,18 @@ BOOL WINAPI EnumPrinterDriversA(LPSTR pN
     ret = WINSPOOL_EnumPrinterDrivers(pwstrNameW, pwstrEnvironmentW,
                                       Level, pDriverInfo, cbBuf, pcbNeeded,
                                       pcReturned, FALSE);
+
+    /* Etersoft: try to get driver entry from two places, ignore pEnvironment */
+    if (!ret) {
+        ret = WINSPOOL_EnumPrinterDrivers(pwstrNameW, envname_x86W,
+                                      Level, pDriverInfo, cbBuf, pcbNeeded,
+                                      pcReturned, FALSE);
+        if (!ret)
+            ret = WINSPOOL_EnumPrinterDrivers(pwstrNameW, envname_win40W,
+                                      Level, pDriverInfo, cbBuf, pcbNeeded,
+                                      pcReturned, FALSE);
+    }
+
     RtlFreeUnicodeString(&pNameW);
     RtlFreeUnicodeString(&pEnvironmentW);
 
@@ -5464,15 +5512,35 @@ emP_cleanup:
 /******************************************************************************
  *		GetDefaultPrinterW   (WINSPOOL.@)
  *
- * FIXME
- *	This function must read the value from data 'device' of key
- *	HCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows
+ * Return the name of the default printer.
+ *
+ * PARAMS
+ *  name        [I]     Pointer to a buffer, containing the printer name.
+ *  namesize    [I|O]   size of the buffer, in characters. If name is NULL,
+ *                      then namesize returns required buffer size.
+ * 
+ * RETURNS
+ *  Success: a nonzero value
+ *  Failure: 0. Call GetLastError() to get extended error information.
+ *   ERROR_INSUFFICIENT_BUFFER - the buffer too small, namesize contains 
+ *                               required size.
+ *   ERROR_FILE_NOT_FOUND - there is not default printer.
+ *   ERROR_INVALID_NAME - the information about device has a bad format.
+ * 
+ * NOTES
+ *	This function reads the value from data 'device' of key
+ *	HCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows.
+ *  If the value is not found, then it gets from GetProfileStringW() function.
  */
 BOOL WINAPI GetDefaultPrinterW(LPWSTR name, LPDWORD namesize)
 {
     BOOL  retval = TRUE;
     DWORD insize, len;
     WCHAR *buffer, *ptr;
+    HKEY hKey;
+    DWORD type;
+    DWORD bufsize;
+    WCHAR keyname[] = {'D','e','v','i','c','e',0};
 
     if (!namesize)
     {
@@ -5486,14 +5554,24 @@ BOOL WINAPI GetDefaultPrinterW(LPWSTR na
      * (20 for ,driver,port) */
     insize = *namesize;
     len = max(100, (insize + 20));
-    buffer = HeapAlloc( GetProcessHeap(), 0, len * sizeof(WCHAR));
+    bufsize = len * sizeof(WCHAR);
+    buffer = HeapAlloc( GetProcessHeap(), 0, bufsize);
 
-    if (!GetProfileStringW(windowsW, deviceW, emptyStringW, buffer, len))
+    if(!RegOpenKeyW(HKEY_CURRENT_USER, user_default_reg_key, &hKey) 
+            && !RegQueryValueExW(hKey, keyname, NULL, &type, (LPBYTE)buffer, &bufsize))
+    {
+        TRACE("Get value from registry\n");
+        RegCloseKey( hKey );
+    }
+    else if (!GetProfileStringW(windowsW, deviceW, emptyStringW, buffer, len))
     {
         SetLastError (ERROR_FILE_NOT_FOUND);
         retval = FALSE;
         goto end;
     }
+    else
+        TRACE("Get value from profile\n");
+
     TRACE("%s\n", debugstr_w(buffer));
 
     if ((ptr = strchrW(buffer, ',')) == NULL)
@@ -6451,7 +6529,7 @@ BOOL WINAPI AddPrinterDriverExW( LPWSTR 
     }
 
     if ((dwFileCopyFlags & ~APD_COPY_FROM_DIRECTORY) != APD_COPY_ALL_FILES) {
-        FIXME("Flags 0x%x ignored (Fallback to APD_COPY_ALL_FILES)\n", dwFileCopyFlags & ~APD_COPY_FROM_DIRECTORY);
+        TRACE("Flags 0x%x ignored (Fallback to APD_COPY_ALL_FILES)\n", dwFileCopyFlags & ~APD_COPY_FROM_DIRECTORY);
     }
 
     ptr = get_servername_from_name(pName);
@@ -6579,7 +6657,7 @@ BOOL WINAPI AddPrinterDriverExW( LPWSTR 
 
 
     RegCloseKey(hdrv);
-    FIXME("### DrvDriverEvent(...,DRIVEREVENT_INITIALIZE) not implemented yet\n");
+    TRACE("### DrvDriverEvent(...,DRIVEREVENT_INITIALIZE) not implemented yet\n");
 
 
     TRACE("=> TRUE with %u\n", GetLastError());
diff -uHNrp wine-20071130/dlls/ws2_32/socket.c wine-20071130e/dlls/ws2_32/socket.c
--- wine-20071130/dlls/ws2_32/socket.c	2007-12-01 21:14:19.000000000 +0300
+++ wine-20071130e/dlls/ws2_32/socket.c	2008-02-04 18:31:20.000000000 +0300
@@ -244,6 +244,8 @@ int WSAIOCTL_GetInterfaceName(int intNum
 UINT wsaErrno(void);
 UINT wsaHerrno(int errnr);
 
+static DWORD dwBlockedThreadId;
+
 #define MAP_OPTION(opt) { WS_##opt, opt }
 
 static const int ws_sock_map[][2] =
@@ -1355,7 +1357,9 @@ SOCKET WINAPI WS_accept(SOCKET s, struct
             int fd = get_sock_fd( s, FILE_READ_DATA, NULL );
             if (fd == -1) return INVALID_SOCKET;
             /* block here */
+            dwBlockedThreadId = GetCurrentThreadId();
             do_block(fd, POLLIN, -1);
+            dwBlockedThreadId = 0;
             _sync_sock_state(s); /* let wineserver notice connection */
             release_sock_fd( s, fd );
             /* retrieve any error codes from it */
@@ -1455,7 +1459,28 @@ int WINAPI WS_bind(SOCKET s, const struc
 int WINAPI WS_closesocket(SOCKET s)
 {
     TRACE("socket %04lx\n", s);
-    if (CloseHandle(SOCKET2HANDLE(s))) return 0;
+
+    if (CloseHandle(SOCKET2HANDLE(s)))
+    {
+        /* CODEWEAVERS HACK:
+         * This is used to emulate Windows behaviour in that when you close a
+         * handle that is being used in a blocking operation it returns with
+         * EINVAL. Without this hack Wine will just hang forever. This hack
+         * interrupts the poll system call in do_block with a signal which will
+         * result in another call to poll and if the handle has been closed it
+         * will return EINVAL exactly as Windows does.
+         * NOTE: this relies on the fact that Suspend/ResumeThread are
+         * implemented using UNIX signals */
+        if (dwBlockedThreadId)
+        {
+            HANDLE hThread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, dwBlockedThreadId);
+            SuspendThread(hThread);
+            ResumeThread(hThread);
+            CloseHandle(hThread);
+        }
+        /* END CODEWEAVERS HACK */
+        return 0;
+    }
     return SOCKET_ERROR;
 }
 
diff -uHNrp wine-20071130/include/ras.h wine-20071130e/include/ras.h
--- wine-20071130/include/ras.h	2007-12-01 21:14:22.000000000 +0300
+++ wine-20071130e/include/ras.h	2008-02-04 18:31:20.000000000 +0300
@@ -55,9 +55,164 @@ extern "C" {
 #define RASDT_Parallel   "PARALLEL"
 #define RASDT_PPPoE      "PPPoE"
 
-#define RASBASE				600
-#define ERROR_BUFFER_TOO_SMALL		(RASBASE+3)
-#define ERROR_INVALID_SIZE		(RASBASE+32)
+/* RAS errors */
+#define RASBASE                                 600
+#define PENDING                                 (RASBASE+0)
+#define ERROR_INVALID_PORT_HANDLE               (RASBASE+1)
+#define ERROR_PORT_ALREADY_OPEN                 (RASBASE+2)
+#define ERROR_BUFFER_TOO_SMALL                  (RASBASE+3)
+#define ERROR_WRONG_INFO_SPECIFIED              (RASBASE+4)
+#define ERROR_CANNOT_SET_PORT_INFO              (RASBASE+5)
+#define ERROR_PORT_NOT_CONNECTED                (RASBASE+6)
+#define ERROR_EVENT_INVALID                     (RASBASE+7)
+#define ERROR_DEVICE_DOES_NOT_EXIST             (RASBASE+8)
+#define ERROR_DEVICETYPE_DOES_NOT_EXIST         (RASBASE+9)
+#define ERROR_BUFFER_INVALID    		(RASBASE+10)
+#define ERROR_ROUTE_NOT_AVAILABLE 		(RASBASE+11)
+#define ERROR_ROUTE_NOT_ALLOCATED 		(RASBASE+12)
+#define ERROR_INVALID_COMPRESSION_SPECIFIED     (RASBASE+13)
+#define ERROR_OUT_OF_BUFFERS    		(RASBASE+14)
+#define ERROR_PORT_NOT_FOUND    		(RASBASE+15)
+#define ERROR_ASYNC_REQUEST_PENDING 		(RASBASE+16)
+#define ERROR_ALREADY_DISCONNECTING 		(RASBASE+17)
+#define ERROR_PORT_NOT_OPEN     		(RASBASE+18)
+#define ERROR_PORT_DISCONNECTED 		(RASBASE+19)
+#define ERROR_NO_ENDPOINTS      		(RASBASE+20)
+#define ERROR_CANNOT_OPEN_PHONEBOOK 		(RASBASE+21)
+#define ERROR_CANNOT_LOAD_PHONEBOOK 		(RASBASE+22)
+#define ERROR_CANNOT_FIND_PHONEBOOK_ENTRY       (RASBASE+23)
+#define ERROR_CANNOT_WRITE_PHONEBOOK            (RASBASE+24)
+#define ERROR_CORRUPT_PHONEBOOK 		(RASBASE+25)
+#define ERROR_CANNOT_LOAD_STRING        	(RASBASE+26)
+#define ERROR_KEY_NOT_FOUND     		(RASBASE+27)
+#define ERROR_DISCONNECTION     		(RASBASE+28)
+#define ERROR_REMOTE_DISCONNECTION      	(RASBASE+29)
+#define ERROR_HARDWARE_FAILURE          	(RASBASE+30)
+#define ERROR_USER_DISCONNECTION        	(RASBASE+31)
+#define ERROR_INVALID_SIZE      		(RASBASE+32)
+#define ERROR_PORT_NOT_AVAILABLE 		(RASBASE+33)
+#define ERROR_CANNOT_PROJECT_CLIEN      	(RASBASE+34)
+#define ERROR_UNKNOWN 				(RASBASE+35)
+#define ERROR_WRONG_DEVICE_ATTACHED 		(RASBASE+36)
+#define ERROR_BAD_STRING 			(RASBASE+37)
+#define ERROR_REQUEST_TIMEOUT 			(RASBASE+38)
+#define ERROR_CANNOT_GET_LANA 			(RASBASE+39)
+#define ERROR_NETBIOS_ERROR 			(RASBASE+40)
+#define ERROR_SERVER_OUT_OF_RESOURCES 		(RASBASE+41)
+#define ERROR_NAME_EXISTS_ON_NET 		(RASBASE+42)
+#define WARNING_MSG_ALIAS_NOT_ADDED 		(RASBASE+44)
+#define ERROR_AUTH_INTERNAL 			(RASBASE+45)
+#define ERROR_RESTRICTED_LOGON_HOURS 		(RASBASE+46)
+#define ERROR_ACCT_DISABLED 			(RASBASE+47)
+#define ERROR_PASSWD_EXPIRED 			(RASBASE+48)
+#define ERROR_NO_DIALIN_PERMISSION 		(RASBASE+49)
+#define ERROR_SERVER_NOT_RESPONDING 		(RASBASE+50)
+#define ERROR_FROM_DEVICE 			(RASBASE+51)
+#define ERROR_UNRECOGNIZED_RESPONSE 		(RASBASE+52)
+#define ERROR_MACRO_NOT_FOUND 			(RASBASE+53)
+#define ERROR_MACRO_NOT_DEFINED 		(RASBASE+54)
+#define ERROR_MESSAGE_MACRO_NOT_FOUND 		(RASBASE+55)
+#define ERROR_DEFAULTOFF_MACRO_NOT_FOUND 	(RASBASE+56)
+#define ERROR_FILE_COULD_NOT_BE_OPENED 		(RASBASE+57)
+#define ERROR_DEVICENAME_TOO_LONG 		(RASBASE+58)
+#define ERROR_DEVICENAME_NOT_FOUND 		(RASBASE+59)
+#define ERROR_NO_RESPONSES 			(RASBASE+60)
+#define ERROR_NO_COMMAND_FOUND 			(RASBASE+61)
+#define ERROR_WRONG_KEY_SPECIFIED 		(RASBASE+62)
+#define ERROR_UNKNOWN_DEVICE_TYPE 		(RASBASE+63)
+#define ERROR_ALLOCATING_MEMORY 		(RASBASE+64)
+#define ERROR_PORT_NOT_CONFIGURED 		(RASBASE+65)
+#define ERROR_DEVICE_NOT_READY 			(RASBASE+66)
+#define ERROR_READING_INI_FILE 			(RASBASE+67)
+#define ERROR_NO_CONNECTION 			(RASBASE+68)
+#define ERROR_BAD_USAGE_IN_INI_FILE 		(RASBASE+69)
+#define ERROR_READING_SECTIONNAME 		(RASBASE+70)
+#define ERROR_READING_DEVICETYPE 		(RASBASE+71)
+#define ERROR_READING_DEVICENAME 		(RASBASE+72)
+#define ERROR_READING_USAGE 			(RASBASE+73)
+#define ERROR_READING_MAXCONNECTBPS 		(RASBASE+74)
+#define ERROR_READING_MAXCARRIERBPS 		(RASBASE+75)
+#define ERROR_LINE_BUSY 			(RASBASE+76)
+#define ERROR_VOICE_ANSWER 			(RASBASE+77)
+#define ERROR_NO_ANSWER 			(RASBASE+78)
+#define ERROR_NO_CARRIER 			(RASBASE+79)
+#define ERROR_NO_DIALTONE 			(RASBASE+80)
+#define ERROR_IN_COMMAND 			(RASBASE+81)
+#define ERROR_WRITING_SECTIONNAME 		(RASBASE+82)
+#define ERROR_WRITING_DEVICETYPE 		(RASBASE+83)
+#define ERROR_WRITING_DEVICENAME 		(RASBASE+84)
+#define ERROR_WRITING_MAXCONNECTBPS 		(RASBASE+85)
+#define ERROR_WRITING_MAXCARRIERBPS 		(RASBASE+86)
+#define ERROR_WRITING_USAGE 			(RASBASE+87)
+#define ERROR_WRITING_DEFAULTOFF 		(RASBASE+88)
+#define ERROR_READING_DEFAULTOFF 		(RASBASE+89)
+#define ERROR_EMPTY_INI_FILE 			(RASBASE+90)
+#define ERROR_AUTHENTICATION_FAILURE 		(RASBASE+91)
+#define ERROR_PORT_OR_DEVICE 			(RASBASE+92)
+#define ERROR_NOT_BINARY_MACRO 			(RASBASE+93)
+#define ERROR_DCB_NOT_FOUND 			(RASBASE+94)
+#define ERROR_STATE_MACHINES_NOT_STARTED 	(RASBASE+95)
+#define ERROR_STATE_MACHINES_ALREADY_STARTED 	(RASBASE+96)
+#define ERROR_PARTIAL_RESPONSE_LOOPING 		(RASBASE+97)
+#define ERROR_UNKNOWN_RESPONSE_KEY 		(RASBASE+98)
+#define ERROR_RECV_BUF_FULL 			(RASBASE+99)
+#define ERROR_CMD_TOO_LONG 			(RASBASE+100)
+#define ERROR_UNSUPPORTED_BPS 			(RASBASE+101)
+#define ERROR_UNEXPECTED_RESPONSE 		(RASBASE+102)
+#define ERROR_INTERACTIVE_MODE 			(RASBASE+103)
+#define ERROR_BAD_CALLBACK_NUMBER 		(RASBASE+104)
+#define ERROR_INVALID_AUTH_STATE 		(RASBASE+105)
+#define ERROR_WRITING_INITBPS 			(RASBASE+106)
+#define ERROR_X25_DIAGNOSTIC 			(RASBASE+107)
+#define ERROR_ACCT_EXPIRED 			(RASBASE+108)
+#define ERROR_CHANGING_PASSWORD 		(RASBASE+109)
+#define ERROR_OVERRUN 				(RASBASE+110)
+#define ERROR_RASMAN_CANNOT_INITIALIZE 		(RASBASE+111)
+#define ERROR_BIPLEX_PORT_NOT_AVAILABLE		(RASBASE+112)
+#define ERROR_NO_ACTIVE_ISDN_LINES 		(RASBASE+113)
+#define ERROR_NO_ISDN_CHANNELS_AVAILABLE	(RASBASE+114)
+#define ERROR_TOO_MANY_LINE_ERRORS 		(RASBASE+115)
+#define ERROR_IP_CONFIGURATION 			(RASBASE+116)
+#define ERROR_NO_IP_ADDRESSES 			(RASBASE+117)
+#define ERROR_PPP_TIMEOUT 			(RASBASE+118)
+#define ERROR_PPP_REMOTE_TERMINATED 		(RASBASE+119)
+#define ERROR_PPP_NO_PROTOCOLS_CONFIGURED 	(RASBASE+120)
+#define ERROR_PPP_NO_RESPONSE 			(RASBASE+121)
+#define ERROR_PPP_INVALID_PACKET		(RASBASE+122)
+#define ERROR_PHONE_NUMBER_TOO_LONG 		(RASBASE+123)
+#define ERROR_IPXCP_NO_DIALOUT_CONFIGURED 	(RASBASE+124)
+#define ERROR_IPXCP_NO_DIALIN_CONFIGURED 	(RASBASE+125)
+#define ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE 	(RASBASE+126)
+#define ERROR_ACCESSING_TCPCFGDLL 		(RASBASE+127)
+#define ERROR_NO_IP_RAS_ADAPTER 		(RASBASE+128)
+#define ERROR_SLIP_REQUIRES_IP 			(RASBASE+129)
+#define ERROR_PROJECTION_NOT_COMPLETE 		(RASBASE+130)
+#define ERROR_PROTOCOL_NOT_CONFIGURED 		(RASBASE+131)
+#define ERROR_PPP_NOT_CONVERGING 		(RASBASE+132)
+#define ERROR_PPP_CP_REJECTED 			(RASBASE+133)
+#define ERROR_PPP_LCP_TERMINATED 		(RASBASE+134)
+#define ERROR_PPP_REQUIRED_ADDRESS_REJECTED 	(RASBASE+135)
+#define ERROR_PPP_NCP_TERMINATED 		(RASBASE+136)
+#define ERROR_PPP_LOOPBACK_DETECTED 		(RASBASE+137)
+#define ERROR_PPP_NO_ADDRESS_ASSIGNED 		(RASBASE+138)
+#define ERROR_CANNOT_USE_LOGON_CREDENTIALS 	(RASBASE+139)
+#define ERROR_TAPI_CONFIGURATION 		(RASBASE+140)
+#define ERROR_NO_LOCAL_ENCRYPTION 		(RASBASE+141)
+#define ERROR_NO_REMOTE_ENCRYPTION 		(RASBASE+142)
+#define ERROR_REMOTE_REQUIRES_ENCRYPTION 	(RASBASE+143)
+#define ERROR_IPXCP_NET_NUMBER_CONFLICT 	(RASBASE+144)
+#define ERROR_INVALID_SMM 			(RASBASE+145)
+#define ERROR_SMM_UNINITIALIZED 		(RASBASE+146)
+#define ERROR_NO_MAC_FOR_PORT 			(RASBASE+147)
+#define ERROR_SMM_TIMEOUT 			(RASBASE+148)
+#define ERROR_BAD_PHONE_NUMBER 			(RASBASE+149)
+#define ERROR_WRONG_MODULE 			(RASBASE+150)
+#define ERROR_PPP_MAC 				(RASBASE+151)
+#define ERROR_PPP_LCP 				(RASBASE+152)
+#define ERROR_PPP_AUTH 				(RASBASE+153)
+#define ERROR_PPP_NCP 				(RASBASE+154)
+#define ERROR_POWER_OFF 			(RASBASE+155)
+#define ERROR_POWER_OFF_CD 			(RASBASE+156)
 
 typedef struct tagRASDEVINFOA {
     DWORD    dwSize;
diff -uHNrp wine-20071130/include/wine/etersoft.h wine-20071130e/include/wine/etersoft.h
--- wine-20071130/include/wine/etersoft.h	1970-01-01 03:00:00.000000000 +0300
+++ wine-20071130e/include/wine/etersoft.h	2008-02-04 18:31:20.000000000 +0300
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2006, 2007 Etersoft
+ * Copyright (C) 2006, 2007 Vitaly Lipatov
+ * It is licensed as WINE under LGPL license.
+ * If you have any questions, please mail to wine@etersoft.ru
+ */
+
+#ifndef __WINE_ETERSOFT_H
+#define __WINE_ETERSOFT_H
+
+/* It is forbidden by makedep to include config.h in headers */
+/* #include "config.h" */
+#include "wine/library.h"
+
+#ifndef WIN32_NO_STATUS
+#include "wine/debug.h"
+#endif
+
+#define LIBWINEETERSOFT_SONAME "libwine-etersoft.so.1"
+
+/* WARN is not present in server/ */
+#ifndef WARN
+#define WARN(n,n1) TRACE(stderr,n,n1)
+#endif
+
+/* WARN is not present in loader*/
+#ifndef TRACE
+#define TRACE(n...) do { } while(0)
+#endif
+
+/* Now we don't need #include "wine/port.h" here */
+#ifndef RTLD_NOW
+#define RTLD_NOW     0x002
+#endif
+
+#define LOAD_FUNCPTR(f) if((f = wine_dlsym(et_handle, #f, NULL, 0)) == NULL){WARN("Can't find symbol %s\n", #f); }
+#define ETERUNI ((void*)1)
+
+static void *et_handle = ETERUNI;
+
+#define LOADETER_FUNC(n) \
+    if (!n) { \
+        if (et_handle == ETERUNI) \
+            et_handle = wine_dlopen(LIBWINEETERSOFT_SONAME, RTLD_NOW, NULL, 0); \
+        if (et_handle != NULL) \
+            LOAD_FUNCPTR(n); \
+    }
+
+/* Proprietary Etersoft's functions */
+static int (*etersoft_init)(int dword_size, int file_flags, const char *text);
+static char * (*etersoft_version)();
+static void (*etersoft_fixtab)(void *data, int pointer_size);
+
+static int (*etersoft_sharing_open)(const char *name, int flags, int shared, mode_t mode );
+
+static int (*etersoft_sharing_close)(int unix_fd );
+
+static int (*etersoft_sharing_pre)(int unix_fd, DWORD access, DWORD sharing, unsigned int * existing_access,
+                          unsigned int * existing_sharing);
+static void (*etersoft_sharing_post)(int unix_fd, DWORD access, unsigned int existing_access,
+                           unsigned int existing_sharing);
+
+static int   (*etersoft_force_compare_string)(DWORD lcid, DWORD style,
+                          const char* str1, int len1, const char* str2, int len2);
+
+static void (*etersoft_fixsplash)(DWORD *style, DWORD f1, DWORD f2);
+
+static int (*etersoft_is_initialize)(void);
+
+static int (*etersoft_1version)(void);
+
+static int (*etersoft_fixdefwnd)(UINT msg, UINT mousemove, UINT oldmsg);
+
+static int (*etersoft_fixtimer)(UINT_PTR id, UINT *timer);
+
+static int (*etersoft_protect)(const unsigned char *buf, const char *name);
+
+#endif
diff -uHNrp wine-20071130/include/winnls.h wine-20071130e/include/winnls.h
--- wine-20071130/include/winnls.h	2007-12-01 21:14:23.000000000 +0300
+++ wine-20071130e/include/winnls.h	2008-02-04 18:31:20.000000000 +0300
@@ -487,6 +487,7 @@ extern "C" {
 #define CSTR_LESS_THAN    1
 #define CSTR_EQUAL        2
 #define CSTR_GREATER_THAN 3
+#define CSTR_NONFORCE     4
 
 /*
  * Language Group IDs.
diff -uHNrp wine-20071130/include/winternl.h wine-20071130e/include/winternl.h
--- wine-20071130/include/winternl.h	2007-12-01 21:14:22.000000000 +0300
+++ wine-20071130e/include/winternl.h	2008-02-04 18:31:20.000000000 +0300
@@ -22,6 +22,7 @@
 #define __WINE_WINTERNL_H
 
 #include <windef.h>
+#include <stdarg.h>
 
 #ifdef __cplusplus
 extern "C" {
diff -uHNrp wine-20071130/libs/wine/c_1251.c wine-20071130e/libs/wine/c_1251.c
--- wine-20071130/libs/wine/c_1251.c	2007-12-01 21:14:23.000000000 +0300
+++ wine-20071130e/libs/wine/c_1251.c	2008-02-04 18:31:20.000000000 +0300
@@ -376,7 +376,8 @@ static const unsigned char uni2cp_low[48
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x4f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x2d, 0xb1, 0x3f, 0x2f, 0x5c, 0x2a,
-    0xb0, 0x95, 0x56, 0x3f, 0x3f, 0x3f, 0x3f, 0x4c,
+    /*0xb0, 0x95, 0x56, 0x3f, 0x3f, 0x3f, 0x3f, 0x4c,*/
+    0xb0, 0x95, 0x76, 0x3f, 0x3f, 0x3f, 0x3f, 0x4c,
     0x3f, 0x3f, 0x3f, 0x7c, 0x7c, 0x3f, 0x3f, 0x3f,
     0x3f, 0x6e, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3a, 0x3f,
@@ -472,27 +473,38 @@ static const unsigned char uni2cp_low[48
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     /* 0x2500 .. 0x25ff */
-    0x2d, 0x2d, 0x7c, 0x7c, 0x2d, 0x2d, 0xa6, 0xa6,
-    0x2d, 0x2d, 0xa6, 0xa6, 0x2b, 0x2b, 0x2b, 0x2b,
+    /*0x2d, 0x2d, 0x7c, 0x7c, 0x2d, 0x2d, 0xa6, 0xa6,*/
+    0x2d, 0x2d, 0xa6, 0x7c, 0x2d, 0x2d, 0xa6, 0xa6,
+    /*0x2d, 0x2d, 0xa6, 0xa6, 0x2b, 0x2b, 0x2b, 0x2b,*/
+    0x2d, 0x2d, 0xa6, 0xa6, 0x2d, 0x2b, 0x2b, 0x2b,
     0xac, 0xac, 0xac, 0xac, 0x4c, 0x4c, 0x4c, 0x4c,
-    0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
+    /*0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,*/
+    0x2d, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
     0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
     0x2b, 0x2b, 0x2b, 0x2b, 0x54, 0x54, 0x54, 0x54,
     0x54, 0x54, 0x54, 0x54, 0x2b, 0x2b, 0x2b, 0x2b,
     0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
     0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
     0x2b, 0x2b, 0x2b, 0x2b, 0x2d, 0x2d, 0xa6, 0xa6,
-    0x3d, 0x7c, 0x2b, 0x2b, 0x2b, 0xac, 0xac, 0xac,
-    0x4c, 0x4c, 0x4c, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
-    0x2b, 0x2b, 0x2b, 0x2b, 0x54, 0x54, 0x54, 0x2b,
-    0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x3f, 0x3f, 0x3f,
+    /*0x3d, 0x7c, 0x2b, 0x2b, 0x2b, 0xac, 0xac, 0xac,*/
+    0x3d, 0xa6, 0x2d, 0xe3, 0xe3, 0xac, 0xac, 0xac,
+    /*0x4c, 0x4c, 0x4c, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,*/
+    0x4c, 0x4c, 0x4c, 0x2d, 0x2d, 0x2d, 0xa6, 0xa6,
+    /*0x2b, 0x2b, 0x2b, 0x2b, 0x54, 0x54, 0x54, 0x2b,*/
+    0xa6, 0xa6, 0xa6, 0xa6, 0x54, 0x54, 0x54, 0xa6,
+    /*0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x3f, 0x3f, 0x3f,*/
+    0xa6, 0xa6, 0x2b, 0x2b, 0x2b, 0x3f, 0x3f, 0x3f,
     0x3f, 0x2f, 0x5c, 0x58, 0x2d, 0x7c, 0x2d, 0x7c,
     0x2d, 0x7c, 0x2d, 0x7c, 0x2d, 0x7c, 0x2d, 0x7c,
+    /*0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,*/
+    0x2d, 0x3f, 0x3f, 0x3f, 0x2d, 0x3f, 0x3f, 0x3f,
+    /*0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,*/
+    0x2d, 0x3f, 0x3f, 0x3f, 0xa6, 0x3f, 0x3f, 0x3f,
+    /*0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,*/
+    0xa6, 0x2d, 0x2d, 0x2d, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
-    0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
-    0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
-    0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
-    0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
+    /*0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,*/
+    0xa6, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
diff -uHNrp wine-20071130/libs/wine/c_866.c wine-20071130e/libs/wine/c_866.c
--- wine-20071130/libs/wine/c_866.c	2007-12-01 21:14:23.000000000 +0300
+++ wine-20071130e/libs/wine/c_866.c	2008-02-04 18:31:20.000000000 +0300
@@ -95,10 +95,14 @@ static const unsigned char uni2cp_low[48
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
-    0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
-    0xff, 0x21, 0x63, 0x4c, 0xfd, 0x59, 0x7c, 0x3f,
-    0x22, 0x63, 0x61, 0x3c, 0x3f, 0x2d, 0x72, 0x2d,
-    0xf8, 0x3f, 0x32, 0x33, 0x27, 0x75, 0x3f, 0xfa,
+    /*0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,*/
+    0x5f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
+    /*0xff, 0x21, 0x63, 0x4c, 0xfd, 0x59, 0x7c, 0x3f,*/
+    0xff, 0x21, 0x63, 0x4c, 0xfd, 0x59, 0xb3, 0x15,
+    /*0x22, 0x63, 0x61, 0x3c, 0x3f, 0x2d, 0x72, 0x2d,*/
+    0x22, 0x63, 0x61, 0x3c, 0xbf, 0x2d, 0x52, 0x2d,
+    /*0xf8, 0x3f, 0x32, 0x33, 0x27, 0x75, 0x3f, 0xfa,*/
+    0xf8, 0x2b, 0x32, 0x33, 0x27, 0xe7, 0x14, 0xfa,
     0x2c, 0x31, 0x6f, 0x3e, 0x3f, 0x3f, 0x3f, 0x3f,
     0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x43,
     0x45, 0x45, 0x45, 0x45, 0x49, 0x49, 0x49, 0x49,
@@ -208,8 +212,10 @@ static const unsigned char uni2cp_low[48
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     /* 0x0400 .. 0x04ff */
-    0x85, 0xf0, 0x3f, 0x83, 0xf2, 0x3f, 0x3f, 0xf4,
-    0x3f, 0x3f, 0x3f, 0x3f, 0x8a, 0x88, 0xf6, 0x3f,
+    /*0x85, 0xf0, 0x3f, 0x83, 0xf2, 0x3f, 0x3f, 0xf4,*/
+    0x85, 0xf0, 0x5f, 0x5f, 0xf2, 0x5f, 0x5f, 0xf4,
+    /*0x3f, 0x3f, 0x3f, 0x3f, 0x8a, 0x88, 0xf6, 0x3f,*/
+    0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x88, 0xf6, 0x5f,
     0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
     0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
     0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
@@ -218,15 +224,18 @@ static const unsigned char uni2cp_low[48
     0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
     0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
     0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
-    0xa5, 0xf1, 0x3f, 0xa3, 0xf3, 0x3f, 0x3f, 0xf5,
-    0x3f, 0x3f, 0x3f, 0x3f, 0xaa, 0xa8, 0xf7, 0x3f,
-    0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
+    /*0xa5, 0xf1, 0x3f, 0xa3, 0xf3, 0x3f, 0x3f, 0xf5,*/
+    0xa5, 0xf1, 0x5f, 0x5f, 0xf3, 0x5f, 0x5f, 0xf5,
+    /*0x3f, 0x3f, 0x3f, 0x3f, 0xaa, 0xa8, 0xf7, 0x3f,*/
+    0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0xa8, 0xf7, 0x5f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
+    /*0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,*/
+    0x5f, 0x5f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
@@ -343,10 +352,13 @@ static const unsigned char uni2cp_low[48
     0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
     0x20, 0x20, 0x20, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x2d, 0x2d, 0x3f, 0x2d, 0x2d, 0x2d, 0x3f, 0x5f,
-    0x60, 0x27, 0x2c, 0x60, 0x22, 0x22, 0x2c, 0x3f,
-    0x3f, 0x3f, 0xf9, 0x3f, 0x2e, 0x3f, 0x3f, 0x3f,
+    /*0x60, 0x27, 0x2c, 0x60, 0x22, 0x22, 0x2c, 0x3f,*/
+    0x27, 0x27, 0x27, 0x60, 0x22, 0x22, 0x22, 0x3f,
+    /*0x3f, 0x3f, 0xf9, 0x3f, 0x2e, 0x3f, 0x3f, 0x3f,*/
+    0xc5, 0xd8, 0x07, 0x3f, 0x2e, 0x3f, 0x3a, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x20,
-    0x3f, 0x3f, 0x27, 0x22, 0x3f, 0x60, 0x3f, 0x3f,
+    /*0x3f, 0x3f, 0x27, 0x22, 0x3f, 0x60, 0x3f, 0x3f,*/
+    0x25, 0x3f, 0x27, 0x22, 0x3f, 0x60, 0x3f, 0x3f,
     0x3f, 0x3c, 0x3e, 0x3f, 0x21, 0x3f, 0x2d, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x2f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
@@ -361,7 +373,8 @@ static const unsigned char uni2cp_low[48
     0x61, 0x65, 0x6f, 0x78, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x63, 0x3f, 0x3f, 0x4c, 0x3f, 0x3f, 0x3f,
-    0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
+    /*0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,*/
+    0x3f, 0x3f, 0x3f, 0x3f, 0x5f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
@@ -377,7 +390,8 @@ static const unsigned char uni2cp_low[48
     0x3f, 0x3f, 0x67, 0x48, 0x48, 0x48, 0x68, 0x68,
     0x49, 0x49, 0x4c, 0x6c, 0x3f, 0x4e, 0xfc, 0x3f,
     0x50, 0x50, 0x51, 0x52, 0x52, 0x52, 0x3f, 0x3f,
-    0x3f, 0x3f, 0x3f, 0x3f, 0x5a, 0x3f, 0x3f, 0x3f,
+    /*0x3f, 0x3f, 0x3f, 0x3f, 0x5a, 0x3f, 0x3f, 0x3f,*/
+    0x3f, 0x3f, 0x54, 0x3f, 0x5a, 0x3f, 0x3f, 0x3f,
     0x5a, 0x3f, 0x4b, 0x41, 0x42, 0x43, 0x65, 0x65,
     0x45, 0x46, 0x3f, 0x4d, 0x6f, 0x3f, 0x3f, 0x3f,
     0x3f, 0x69, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
diff -uHNrp wine-20071130/libs/wine/config.c wine-20071130e/libs/wine/config.c
--- wine-20071130/libs/wine/config.c	2007-12-01 21:14:23.000000000 +0300
+++ wine-20071130e/libs/wine/config.c	2008-02-04 18:31:20.000000000 +0300
@@ -110,6 +110,11 @@ static char *build_path( const char *dir
     size_t len = strlen(dir);
     char *ret = xmalloc( len + strlen(name) + 2 );
 
+    for( ; name[0] == '.' && name[1] == '.' && name[2] == '/' && len; name+=3) 
+    {
+        while ( len && dir[len-1] == '/' ) len--;
+        while ( len && dir[len-1] != '/' ) len--;
+    }
     memcpy( ret, dir, len );
     if (len && ret[len-1] != '/') ret[len++] = '/';
     strcpy( ret + len, name );
@@ -501,3 +506,8 @@ void wine_exec_wine_binary( const char *
     preloader_exec( argv, use_preloader );
     free( argv[0] );
 }
+
+int wine_etersoft()
+{
+	return 20071130;
+}
diff -uHNrp wine-20071130/libs/wine/debug.c wine-20071130e/libs/wine/debug.c
--- wine-20071130/libs/wine/debug.c	2007-12-01 21:14:23.000000000 +0300
+++ wine-20071130e/libs/wine/debug.c	2008-02-04 18:31:20.000000000 +0300
@@ -29,6 +29,7 @@
 
 #include "wine/debug.h"
 #include "wine/library.h"
+#include "wine/unicode.h"
 
 static const char * const debug_classes[] = { "fixme", "err", "warn", "trace" };
 
@@ -357,9 +358,7 @@ static const char *default_dbgstr_wn( co
                 *dst++ = c;
             else
             {
-                *dst++ = '\\';
-                sprintf(dst,"%04x",c);
-                dst+=4;
+            wine_cp_wcstombs (wine_cp_get_table(20866),0,&c,1,dst++,1,"?",0);
             }
         }
     }
diff -uHNrp wine-20071130/libs/wine/wine.def wine-20071130e/libs/wine/wine.def
--- wine-20071130/libs/wine/wine.def	2007-12-01 21:14:23.000000000 +0300
+++ wine-20071130e/libs/wine/wine.def	2008-02-04 18:31:20.000000000 +0300
@@ -11,6 +11,7 @@ EXPORTS
     __wine_main_wargv
     atoiW
     atolW
+    wine_etersoft
     get_char_typeW
     isalnumW
     isalphaW
diff -uHNrp wine-20071130/libs/wine/wine.map wine-20071130e/libs/wine/wine.map
--- wine-20071130/libs/wine/wine.map	2007-12-01 21:14:23.000000000 +0300
+++ wine-20071130e/libs/wine/wine.map	2008-02-04 18:31:20.000000000 +0300
@@ -11,6 +11,7 @@ WINE_1.0
     __wine_main_wargv;
     atoiW;
     atolW;
+    wine_etersoft;
     get_char_typeW;
     isalnumW;
     isalphaW;
diff -uHNrp wine-20071130/loader/main.c wine-20071130e/loader/main.c
--- wine-20071130/loader/main.c	2007-12-01 21:14:23.000000000 +0300
+++ wine-20071130e/loader/main.c	2008-02-04 18:31:20.000000000 +0300
@@ -20,6 +20,7 @@
 
 #include "config.h"
 #include "wine/port.h"
+#include "wine/etersoft.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -86,7 +87,11 @@ static void check_command_line( int argc
     }
     if (!strcmp( argv[1], "--version" ))
     {
-        printf( "%s\n", wine_version );
+        LOADETER_FUNC(etersoft_version);
+        if (etersoft_version)
+	    printf( "%s\n", etersoft_version() );
+        else
+            printf( "%s\n", wine_version );
         exit(0);
     }
 }
diff -uHNrp wine-20071130/loader/Makefile.in wine-20071130e/loader/Makefile.in
--- wine-20071130/loader/Makefile.in	2007-12-01 21:14:23.000000000 +0300
+++ wine-20071130e/loader/Makefile.in	2008-02-04 18:31:20.000000000 +0300
@@ -90,7 +90,7 @@ clean::
 	$(RM) version.c version-stamp
 
 version-stamp: dummy
-	(GIT_DIR=$(TOPSRCDIR)/.git git-describe HEAD 2>/dev/null || echo "wine-@PACKAGE_VERSION@") | sed -e 's/\(.*\)/const char wine_version[] = "\1";/' >$@ || ($(RM) $@ && exit 1)
+	(GIT_DIR=$(TOPSRCDIR)/.git git-describe HEAD 2>/dev/null || echo "@PACKAGE_NAME@ @PACKAGE_VERSION@") | sed -e 's/\(.*\)/const char wine_version[] = "\1";/' >$@ || ($(RM) $@ && exit 1)
 
 version.c: version-stamp
 	@cmp -s version-stamp $@ || cp version-stamp $@
diff -uHNrp wine-20071130/loader/preloader.c wine-20071130e/loader/preloader.c
--- wine-20071130/loader/preloader.c	2007-12-01 21:14:23.000000000 +0300
+++ wine-20071130e/loader/preloader.c	2008-02-04 18:31:20.000000000 +0300
@@ -106,6 +106,9 @@
 #define MAP_NORESERVE 0
 #endif
 
+/* missed in some old systems */
+typedef uint32_t Elf_Symndx;
+
 static struct wine_preload_info preload_info[] =
 {
     { (void *)0x00000000, 0x60000000 },  /* low memory area */
diff -uHNrp wine-20071130/programs/explorer/desktop.c wine-20071130e/programs/explorer/desktop.c
--- wine-20071130/programs/explorer/desktop.c	2007-12-01 21:14:23.000000000 +0300
+++ wine-20071130e/programs/explorer/desktop.c	2008-02-04 18:31:20.000000000 +0300
@@ -117,21 +117,30 @@ static BOOL get_default_desktop_size( un
 
 static void initialize_display_settings( HWND desktop )
 {
-    static const WCHAR display_device_guid_propW[] = {
-        '_','_','w','i','n','e','_','d','i','s','p','l','a','y','_',
-        'd','e','v','i','c','e','_','g','u','i','d',0 };
+    static const char display_device_guid_prop[] = "__wine_display_device_guid";
+
     GUID guid;
-    LPWSTR guid_str;
+    RPC_CSTR guid_str;
     ATOM guid_atom;
+    HRESULT hr;
+
+    hr = UuidCreate( &guid );
+    if (hr != RPC_S_OK) {
+        WINE_ERR("could'nt create UUID\n");
+        return;
+    }
 
-    UuidCreate( &guid );
-    UuidToStringW( &guid, &guid_str );
-    WINE_TRACE( "display guid %s\n", wine_dbgstr_w(guid_str) );
+    hr = UuidToStringA( &guid, &guid_str );
+    if (hr != RPC_S_OK) {
+        WINE_ERR("could'nt convert UUID to string with error %d\n", hr);
+        return;
+    }
+    WINE_TRACE( "display guid %s\n", guid_str );
 
-    guid_atom = GlobalAddAtomW( guid_str );
-    SetPropW( desktop, display_device_guid_propW, ULongToHandle(guid_atom) );
+    guid_atom = GlobalAddAtomA( guid_str );
+    SetPropA( desktop, display_device_guid_prop, ULongToHandle(guid_atom) );
 
-    RpcStringFreeW( &guid_str );
+    RpcStringFreeA( &guid_str );
 }
 
 /* main desktop management function */
diff -uHNrp wine-20071130/programs/extrac32/extrac32.c wine-20071130e/programs/extrac32/extrac32.c
--- wine-20071130/programs/extrac32/extrac32.c	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/programs/extrac32/extrac32.c	2008-02-04 18:31:20.000000000 +0300
@@ -20,10 +20,9 @@
 
 /*
     TODO:
-    Flags /Y /A /C /D as in base program.
+    Flags /Y /A /C as in base program.
     Resources.
     Output text to console from resources.
-    Make correct output with WriteConsoleW
  */
 
 #include <windows.h>
@@ -31,6 +30,10 @@
 #include <wine/unicode.h>
 #include "wine/debug.h"
 
+#include <fnmatch.h>
+
+# define FNM_CASEFOLD    (1 << 4)   /* Compare without regard to case.  */
+
 WINE_DEFAULT_DEBUG_CHANNEL( extrac32 );
 
 #define EFLAGY  0x01
@@ -40,6 +43,8 @@ WINE_DEFAULT_DEBUG_CHANNEL( extrac32 );
 #define EFLAGL  0x10
 #define EFLAGC  0x20
 
+#define MAX_NUMBER  64
+
 extern WCHAR** ParseCmdline( LPWSTR cmdline, int *argc );
 
 static  struct  sOptions
@@ -60,10 +65,100 @@ static  struct  sOptions
 WCHAR wEx[] = { 'e', 'x', 't', 'r', 'a', 'c', 't', 0 };
 
 WCHAR wBackSlash[] = { '\\', 0 };
+WCHAR wSlashN[] = { '\n', 0 };
+
+WCHAR wFilesInCab[] = { ' ', 'f', 'i', 'l', 'e', 's', ' ', 'i', 'n', ' ', 'c', 'a' , 'b', '\n', 0 };
 
 WCHAR g_szTargetPath[MAX_PATH];
 WCHAR g_szNameInCab[MAX_PATH];
 BOOL  g_bShow = FALSE;
+int   g_nCount; /* Number files in cab */ 
+
+/****************************************************************************
+ * Create a directory.
+ *
+ * this works recursivly. so mkdir dir1\dir2\dir3 will create dir1 and dir2 if
+ * they do not already exist.
+ */
+
+static BOOL create_full_path(WCHAR* path)
+{
+    int len;
+    WCHAR *new_path;
+    BOOL ret = TRUE;
+
+    new_path = HeapAlloc(GetProcessHeap(),0,(strlenW(path) * sizeof(WCHAR))+1);
+    strcpyW(new_path,path);
+
+    while ((len = strlenW(new_path)) && new_path[len - 1] == '\\')
+        new_path[len - 1] = 0;
+
+    while (!CreateDirectory(new_path,NULL))
+    {
+        WCHAR *slash;
+        DWORD last_error = GetLastError();
+        if (last_error == ERROR_ALREADY_EXISTS)
+            break;
+
+        if (last_error != ERROR_PATH_NOT_FOUND)
+        {
+            ret = FALSE;
+            break;
+        }
+
+        if (!(slash = strrchrW(new_path,'\\')) && ! (slash = strrchrW(new_path,'/')))
+        {
+            ret = FALSE;
+            break;
+        }
+
+        len = slash - new_path;
+        new_path[len] = 0;
+        if (!create_full_path(new_path))
+        {
+            ret = FALSE;
+            break;
+        }
+        new_path[len] = '\\';
+    }
+    HeapFree(GetProcessHeap(),0,new_path);
+    return ret;
+}
+
+static void Output( LPCWSTR wName)
+{
+    int     res;
+    int     wlen = strlenW( wName );
+
+    res = WriteConsoleW( GetStdHandle( STD_OUTPUT_HANDLE ), wName, wlen, NULL, NULL );
+    if (!res)
+    {
+        DWORD len;
+        DWORD count = 0;
+        char  *mesA;
+        /* Convert to OEM, then output */
+        len = WideCharToMultiByte( GetConsoleOutputCP(), 0, wName, wlen, NULL, 0, NULL, NULL );
+        mesA = HeapAlloc(GetProcessHeap(), 0, len*sizeof(char));
+        if (!mesA) { WINE_ERR("Can not allocate buffer!!\n"); return; }
+        WideCharToMultiByte( GetConsoleOutputCP(), 0, wName, wlen, mesA, len, NULL, NULL );
+        WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), mesA, len, &count, FALSE);
+        HeapFree(GetProcessHeap(), 0, mesA);
+    }
+}
+
+static void OutputFile( LPCWSTR wName)
+{
+    int     wlen = strlenW( wName );
+    LPWSTR  wOutName;
+    wOutName = HeapAlloc( GetProcessHeap(), 0, (wlen + 1 + 1)*sizeof(WCHAR) ); /* For symbol \n and \0  */
+    if ( !wOutName ) { WINE_ERR("Can not allocate buffer!!\n"); return; }
+
+    lstrcpyW( wOutName, wName );
+    lstrcatW( wOutName, wSlashN );
+
+    Output( wOutName );
+    HeapFree(GetProcessHeap(), 0, wOutName);
+}
 
 static BOOL ExtCmp( const WCHAR str1[], const WCHAR str2[] )
 {
@@ -73,42 +168,114 @@ static BOOL ExtCmp( const WCHAR str1[], 
     return ( res == CSTR_EQUAL ) ? TRUE : FALSE;
 }
 
+WCHAR *strstrW( const WCHAR *str, const WCHAR *sub )
+{
+    while (*str)
+    {
+        const WCHAR *p1 = str, *p2 = sub;
+        while (*p1 && *p2 && *p1 == *p2) { p1++; p2++; }
+        if (!*p2) return (WCHAR *)str;
+        str++;
+    }
+    return NULL;
+}
+
+int fnmatchW( WCHAR *wPattern, WCHAR *wFile, DWORD nFlags )
+{
+    int     res = 0;
+    char    *Pattern;
+    char    *File;
+    int     len;
+
+    len = WideCharToMultiByte( CP_UNIXCP, 0, wPattern, -1, NULL, 0, NULL, NULL );
+    Pattern = HeapAlloc( GetProcessHeap(), 0, sizeof(char)*len );
+    WideCharToMultiByte( CP_UNIXCP, 0, wPattern, len, Pattern, len, NULL, NULL );
+
+    len = WideCharToMultiByte( CP_UNIXCP, 0, wFile, -1, NULL, 0, NULL, NULL );
+    File = HeapAlloc( GetProcessHeap(), 0, sizeof(char)*len );
+    WideCharToMultiByte( CP_UNIXCP, 0, wFile, len, File, len, NULL, NULL );
+
+    res = fnmatch( Pattern, File, nFlags );
+
+    HeapFree( GetProcessHeap(), 0, Pattern );
+    HeapFree( GetProcessHeap(), 0, File );
+    return res;
+}
+
 LRESULT WINAPI ExtCabCallback ( PVOID pMyInstallData, UINT Notification, UINT Param1, UINT Param2 )
 {
     LRESULT lRetVal = NO_ERROR;
     WCHAR szTarget[MAX_PATH];
     FILE_IN_CABINET_INFO *pInfo = NULL;
     FILEPATHS *pFilePaths = NULL;
+    WCHAR   NameInCab[MAX_PATH];
 
     lstrcpyW( szTarget, g_szTargetPath );
+    WINE_TRACE("Notification = 0x0%x\n", Notification);
+    WINE_TRACE( "g_szNameInCab = %s\n", wine_dbgstr_w( g_szNameInCab ) );
 
-    switch( Notification )
+    switch ( Notification )
     {
         case SPFILENOTIFY_FILEINCABINET:
             pInfo = ( FILE_IN_CABINET_INFO * ) Param1;
-            if ( !g_szNameInCab[0] )
-                lstrcatW( szTarget, pInfo -> NameInCabinet );
-            else
-                lstrcatW( szTarget, g_szNameInCab );
-            lstrcpyW( pInfo -> FullTargetName, szTarget );
+
+            WINE_TRACE( "pInfo -> NameInCabinet = %s\n", wine_dbgstr_w( pInfo -> NameInCabinet ) );
+
             if ( g_bShow )
             {
-                WriteConsoleW( GetStdHandle( STD_OUTPUT_HANDLE ), pInfo -> NameInCabinet, strlenW( pInfo -> NameInCabinet ), NULL, NULL );
+                OutputFile( pInfo -> NameInCabinet );
+                g_nCount++;
                 lRetVal = FILEOP_SKIP;
                 break;
             }
 
-            if ( g_szNameInCab[0] )
+            if ( !g_szNameInCab[0] )
             {
-                if ( ExtCmp ( pInfo -> NameInCabinet, g_szNameInCab ) )
-                    lRetVal = FILEOP_DOIT;
-                else
-                {
-                    lRetVal = FILEOP_SKIP;
-                    break;
-                }
+                lstrcatW( szTarget, pInfo -> NameInCabinet );
+                lstrcpyW( pInfo -> FullTargetName, szTarget );
+                WINE_TRACE( "szTarget = %s\n", wine_dbgstr_w( szTarget ) );
+                lRetVal = FILEOP_DOIT;
+                break;
+            }
+
+            if ( strstrW( pInfo -> NameInCabinet, wBackSlash ) )
+            {
+                WCHAR   wDirectory[MAX_PATH];
+                WCHAR   wPath[MAX_PATH];
+                int     i = strlenW( pInfo -> NameInCabinet );
+
+                lstrcpyW( wDirectory, pInfo -> NameInCabinet );
+
+                while ( (pInfo -> NameInCabinet)[i] != wBackSlash[0] )
+                    i--;
+
+                wDirectory[i] = 0;
+
+                WINE_TRACE( "wDirectory %s\n", wine_dbgstr_w( wDirectory ) );
+
+                lstrcpyW( wPath, g_szTargetPath );
+                lstrcatW( wPath, wDirectory );
+                lstrcatW( wPath, wBackSlash );
+
+                WINE_TRACE( "wPath %s\n", wine_dbgstr_w( wPath ) );
+
+                create_full_path( wPath );
             }
-            lRetVal = FILEOP_DOIT;
+
+            lstrcpyW( NameInCab, pInfo -> NameInCabinet );
+
+            if ( !fnmatchW( g_szNameInCab, NameInCab, FNM_CASEFOLD ) )
+            {
+                lstrcatW( szTarget, NameInCab );
+                lstrcpyW( pInfo -> FullTargetName, szTarget );
+                WINE_TRACE( "pInfo -> FullTargetName %s\n", wine_dbgstr_w( pInfo -> FullTargetName ) );
+                lRetVal = FILEOP_DOIT;
+            }
+            else
+                lRetVal = FILEOP_SKIP;
+
+            WINE_TRACE( "File in cabinet %s\n", wine_dbgstr_w( pInfo -> NameInCabinet ) );
+
             break;
 
         case SPFILENOTIFY_FILEEXTRACTED:
@@ -116,6 +283,10 @@ LRESULT WINAPI ExtCabCallback ( PVOID pM
             WINE_TRACE( "Extracted %s\n", wine_dbgstr_w( pFilePaths -> Target ) );
             lRetVal = NO_ERROR;
             break;
+
+        case SPFILENOTIFY_CABINETINFO:
+            lRetVal = FILEOP_SKIP; 
+            break;
       }
 
     return lRetVal;
@@ -125,6 +296,15 @@ void ExtCab( PWSTR pszCabFile )
 {
     if ( !SetupIterateCabinetW( pszCabFile, 0, ( PSP_FILE_CALLBACK ) ExtCabCallback, 0) )
         WINE_FIXME( "Can not extract cab file:%s!!!\n", wine_dbgstr_w( pszCabFile ) );
+
+    if ( g_bShow )
+    {
+        WCHAR   wNumber[MAX_NUMBER];
+        WCHAR   wFormat[] = { '%', 'd', 0 };
+        sprintfW( wNumber, wFormat, g_nCount );
+        Output( wNumber );
+        Output( wFilesInCab );
+    }
 }
 
 int PASCAL wWinMain ( HINSTANCE hInstance, HINSTANCE prev, LPWSTR cmdline, int show )
@@ -150,8 +330,9 @@ int PASCAL wWinMain ( HINSTANCE hInstanc
     }
 
     /* FIXME */
-    WINE_TRACE( "Run Wine Extrac32.\n" );
+    WINE_TRACE( "Run Wine Extrac32 (Version 0.3).\n" );
 
+    g_nCount = 0;
     /*Parse options */
     for( i = 0; i < argc; i++ )
     {
@@ -170,8 +351,6 @@ int PASCAL wWinMain ( HINSTANCE hInstanc
                     WINE_FIXME( "Can not run with /E option.\n" );
                 else
                 {
-                    /* FIXME */
-                    WINE_TRACE( "Files in cab:\n" );
                     g_bShow = TRUE;
                     ExtCab( argv[i] );
                     g_bShow = FALSE;
@@ -191,6 +370,7 @@ int PASCAL wWinMain ( HINSTANCE hInstanc
             {
                 WINE_TRACE( "Extract at the current directory.\n" );
                 WINE_TRACE( "Extracting...\n" );
+
                 if ( !g_szTargetPath )
                 {
                     GetCurrentDirectoryW( MAX_PATH, g_szTargetPath );
@@ -209,8 +389,11 @@ int PASCAL wWinMain ( HINSTANCE hInstanc
                     break;
                 }
                 else
+                {
+                    WINE_TRACE( "Extract all files!!.\n" );
                     g_szNameInCab[0] = 0; /* Extract all files */
-                ExtCab( argv[i] );
+                    ExtCab( argv[i] );
+                }
                 break;
             }
         }
diff -uHNrp wine-20071130/programs/regedit/listview.c wine-20071130e/programs/regedit/listview.c
--- wine-20071130/programs/regedit/listview.c	2007-12-01 21:14:24.000000000 +0300
+++ wine-20071130e/programs/regedit/listview.c	2008-02-04 18:31:20.000000000 +0300
@@ -525,7 +525,7 @@ BOOL RefreshListView(HWND hwndLV, HKEY h
     valName = HeapAlloc(GetProcessHeap(), 0, max_val_name_len * sizeof(TCHAR));
     valBuf = HeapAlloc(GetProcessHeap(), 0, max_val_size);
     if (RegQueryValueEx(hKey, NULL, NULL, &valType, valBuf, &valSize) == ERROR_FILE_NOT_FOUND) { 
-        AddEntryToList(hwndLV, NULL, REG_SZ, NULL, 0, !highlightValue);
+        AddEntryToList(hwndLV, NULL, valType, NULL, 0, !highlightValue);
     }
     for(index = 0; index < val_count; index++) {
         BOOL bSelected = (valName == highlightValue); /* NOT a bug, we check for double NULL here */
diff -uHNrp wine-20071130/programs/winecfg/Bg.rc wine-20071130e/programs/winecfg/Bg.rc
--- wine-20071130/programs/winecfg/Bg.rc	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/programs/winecfg/Bg.rc	2008-02-04 18:31:20.000000000 +0300
@@ -171,6 +171,7 @@ BEGIN
     GROUPBOX        "    ",IDC_STATIC,8,4,244,195
     LTEXT           "          .         .         .             .",IDC_STATIC,15,20,227,50
     CONTROL         "",IDC_AUDIO_TREE,"SysTreeView32",WS_BORDER | WS_TABSTOP,15,70,140,120
+    PUSHBUTTON      "&Test Sound",IDC_AUDIO_TEST,170,50,59,14
     PUSHBUTTON	    " ",IDC_AUDIO_CONTROL_PANEL,170,70,69,14
     GROUPBOX        " DirectSound ",IDC_STATIC,8,205,244,60
     LTEXT	    " : ",IDC_STATIC,15,215,90,10
diff -uHNrp wine-20071130/programs/winecfg/Cs.rc wine-20071130e/programs/winecfg/Cs.rc
--- wine-20071130/programs/winecfg/Cs.rc	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/programs/winecfg/Cs.rc	2008-02-04 18:31:20.000000000 +0300
@@ -169,7 +169,8 @@ BEGIN
     GROUPBOX        " Ovlada zvukov karty ",IDC_STATIC,8,4,244,195
     LTEXT           "Vyberte ovlada zvukov karty zakrtnutm polka u pslunho ovladae. Kdy nezakrtnete ani jeden ovlada, zvuk se vypne. Vybrat vce jak jeden ovlada se nedoporuuje. Detailn vlastnosti ovladae mete upravit pravm kliknutm na zvolen ovlada.",IDC_STATIC,15,20,227,50
     CONTROL         "Zazen",IDC_AUDIO_TREE,"SysTreeView32",WS_BORDER | WS_TABSTOP,15,65,140,127
-    PUSHBUTTON	    "Ovldac panel",IDC_AUDIO_CONTROL_PANEL,170,65,59,14
+    PUSHBUTTON      "&Test Sound",IDC_AUDIO_TEST,170,65,59,14
+    PUSHBUTTON	    "Ovldac panel",IDC_AUDIO_CONTROL_PANEL,170,85,59,14
     GROUPBOX        " DirectSound ",IDC_STATIC,8,205,244,60
     LTEXT           "Hardwarov akcelerace: ",IDC_STATIC,15,215,90,10
     COMBOBOX	    IDC_DSOUND_HW_ACCEL,100,213,150,70,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
diff -uHNrp wine-20071130/programs/winecfg/De.rc wine-20071130e/programs/winecfg/De.rc
--- wine-20071130/programs/winecfg/De.rc	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/programs/winecfg/De.rc	2008-02-04 18:31:20.000000000 +0300
@@ -165,7 +165,8 @@ BEGIN
     GROUPBOX        " Treiber Auswahl ",IDC_STATIC,8,4,244,195
     LTEXT           "Whlen Sie einen Sound-Treiber durch ankreuzen des gewnschten Treibers. Ist kein Treiber ausgewhlt, wird der Sound deaktiviert. Die Auswahl mehrerer Treiber ist nicht empfohlen. Ein Treiber kann durch Rechtsklicken konfiguriert werden.",IDC_STATIC,15,15,227,35
     CONTROL         "Gerte",IDC_AUDIO_TREE,"SysTreeView32",WS_BORDER | WS_TABSTOP,15,50,140,140
-    PUSHBUTTON      "Einstellungen",IDC_AUDIO_CONTROL_PANEL,170,50,59,14
+    PUSHBUTTON      "&Test Sound",IDC_AUDIO_TEST,170,50,59,14
+    PUSHBUTTON      "Einstellungen",IDC_AUDIO_CONTROL_PANEL,170,70,59,14
     GROUPBOX        " DirectSound ",IDC_STATIC,8,205,244,60    
     LTEXT           "Hardware-Beschleunigung: ", IDC_STATIC,15,215,90,10
     COMBOBOX        IDC_DSOUND_HW_ACCEL,105,213,140,70,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
diff -uHNrp wine-20071130/programs/winecfg/drive.c wine-20071130e/programs/winecfg/drive.c
--- wine-20071130/programs/winecfg/drive.c	2007-12-01 21:14:24.000000000 +0300
+++ wine-20071130e/programs/winecfg/drive.c	2008-02-04 18:31:20.000000000 +0300
@@ -340,7 +340,8 @@ void load_drives(void)
 
 	/* QueryDosDevice() requires no trailing backslash */
         lstrcpynA(simplepath, devices, 3);
-        QueryDosDevice(simplepath, targetpath, sizeof(targetpath));
+        if (!QueryDosDevice(simplepath, targetpath, sizeof(targetpath)))
+		strcpy(targetpath, "directory");
 
         /* targetpath may have forward slashes rather than backslashes, so correct */
         c = targetpath;
diff -uHNrp wine-20071130/programs/winecfg/Fi.rc wine-20071130e/programs/winecfg/Fi.rc
--- wine-20071130/programs/winecfg/Fi.rc	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/programs/winecfg/Fi.rc	2008-02-04 18:31:20.000000000 +0300
@@ -165,7 +165,8 @@ BEGIN
     GROUPBOX        " Ajurin valinta ",IDC_STATIC,8,4,244,195
     LTEXT	    "niajuri: ",IDC_STATIC,15,20,227,30
     CONTROL         "Devices",IDC_AUDIO_TREE,"SysTreeView32",WS_BORDER | WS_TABSTOP,15,50,140,140
-    PUSHBUTTON	    "&Hallintapaneeli",IDC_AUDIO_CONTROL_PANEL,170,50,79,14
+    PUSHBUTTON      "&Test Sound",IDC_AUDIO_TEST,170,50,59,14
+    PUSHBUTTON	    "&Hallintapaneeli",IDC_AUDIO_CONTROL_PANEL,170,70,79,14
     GROUPBOX        " DirectSound ",IDC_STATIC,8,205,244,60
     LTEXT	    "Laitteistopohjainen kiihdytys:",IDC_STATIC,15,215,90,10
     COMBOBOX	    IDC_DSOUND_HW_ACCEL,100,213,150,70,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
diff -uHNrp wine-20071130/programs/winecfg/Hu.rc wine-20071130e/programs/winecfg/Hu.rc
--- wine-20071130/programs/winecfg/Hu.rc	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/programs/winecfg/Hu.rc	2008-02-04 18:31:20.000000000 +0300
@@ -165,7 +165,8 @@ BEGIN
     GROUPBOX        " Meghajtprogram vlaszts ",IDC_STATIC,8,4,244,195
     LTEXT           "Vlasszon egy hangmeghajtt a kivlasztott meghajtprogram eltti ngyzet bejllsvel.  A hang letilthat, ha nem jell be egy meghajtt sem. Tbb meghajtprogram bejellse nem ajnlott. Az sszes meghajt bellthat, ha rjuk kattint jobb egrgombbal.",IDC_STATIC,15,15,227,35
     CONTROL         "Eszkzk",IDC_AUDIO_TREE,"SysTreeView32",WS_BORDER | WS_TABSTOP,15,50,140,140 
-    PUSHBUTTON	    "Vezrlpult",IDC_AUDIO_CONTROL_PANEL,170,50,59,14
+    PUSHBUTTON      "&Test Sound",IDC_AUDIO_TEST,170,50,59,14
+    PUSHBUTTON	    "Vezrlpult",IDC_AUDIO_CONTROL_PANEL,170,70,59,14
     GROUPBOX        " DirectSound ",IDC_STATIC,8,205,244,60
     LTEXT	    "Hardveres gyorsts: ",IDC_STATIC,15,215,90,10
     COMBOBOX	    IDC_DSOUND_HW_ACCEL,100,213,150,70,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
diff -uHNrp wine-20071130/programs/winecfg/It.rc wine-20071130e/programs/winecfg/It.rc
--- wine-20071130/programs/winecfg/It.rc	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/programs/winecfg/It.rc	2008-02-04 18:31:20.000000000 +0300
@@ -125,9 +125,47 @@ IDD_AUDIOCFG DIALOG DISCARDABLE  0, 0, 2
 STYLE WS_CHILD | WS_DISABLED
 FONT 8, "MS Shell Dlg"
 BEGIN
-    LTEXT	"Driver audio: ",IDC_STATIC,10,20,60,8
-    COMBOBOX	IDC_AUDIO_DRIVER,70,18,85,85,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
-    PUSHBUTTON	"Rileva automaticamente",IDC_AUDIO_AUTODETECT,170,20,49,14
+    GROUPBOX        " Driver Selection ",IDC_STATIC,8,4,244,195
+    LTEXT           "Select a sound driver by checking the box of the desired driver.  Disable sound by not selecting any driver. Selection of multiple drivers is not recommended. Configure a driver by right-clicking on it.",IDC_STATIC,15,20,227,30
+    CONTROL         "Devices",IDC_AUDIO_TREE,"SysTreeView32",WS_BORDER | WS_TABSTOP,15,50,140,140
+    PUSHBUTTON      "&Test Sound",IDC_AUDIO_TEST,170,50,59,14
+    PUSHBUTTON	    "&Control Panel",IDC_AUDIO_CONTROL_PANEL,170,70,59,14
+    GROUPBOX        " DirectSound ",IDC_STATIC,8,205,244,60
+    LTEXT	    "&Hardware Acceleration: ",IDC_STATIC,15,215,90,10
+    COMBOBOX	    IDC_DSOUND_HW_ACCEL,100,213,150,70,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    LTEXT           "Default &Sample Rate:",IDC_STATIC,15,232,70,8
+    COMBOBOX        IDC_DSOUND_RATES,90,230,42,76,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    LTEXT           "Default &Bits Per Sample:",IDC_STATIC,137,232,80,8
+    COMBOBOX        IDC_DSOUND_BITS,220,230,30,56,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    CONTROL         "Driver &Emulation",IDC_DSOUND_DRV_EMUL,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,250,230,10
+END
+
+IDD_DESKTOP_INTEGRATION DIALOG DISCARDABLE  0, 0, 260, 250
+STYLE WS_CHILD | WS_DISABLED
+FONT 8, "MS Shell Dlg"
+BEGIN
+    GROUPBOX        " Appearance ",IDC_STATIC,8,4,244,106
+    LTEXT           "&Theme:",IDC_STATIC,15,16,130,8
+    COMBOBOX        IDC_THEME_THEMECOMBO,15,24,130,14,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    PUSHBUTTON      "&Install theme...",IDC_THEME_INSTALL,152,23,93,14
+    LTEXT           "&Color:",IDC_THEME_COLORTEXT,15,40,112,8
+    COMBOBOX        IDC_THEME_COLORCOMBO,15,48,112,14,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    LTEXT           "&Size:",IDC_THEME_SIZETEXT,135,40,110,8
+    COMBOBOX        IDC_THEME_SIZECOMBO,135,48,110,14,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    LTEXT           "It&em:",IDC_STATIC,15,64,112,8
+    COMBOBOX        IDC_SYSPARAM_COMBO,15,74,112,120,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP | CBS_SORT
+    LTEXT           "C&olor:",IDC_SYSPARAM_COLOR_TEXT,135,64,25,8,WS_DISABLED
+    PUSHBUTTON      "",IDC_SYSPARAM_COLOR,135,74,25,13,WS_DISABLED | BS_OWNERDRAW
+    LTEXT           "Si&ze:",IDC_SYSPARAM_SIZE_TEXT,166,64,30,8,WS_DISABLED
+    EDITTEXT        IDC_SYSPARAM_SIZE,166,74,23,13,ES_AUTOHSCROLL | WS_TABSTOP | WS_DISABLED
+    CONTROL         "",IDC_SYSPARAM_SIZE_UD,UPDOWN_CLASS,UDS_SETBUDDYINT | WS_DISABLED,187,74,15,13
+    PUSHBUTTON      "&Font",IDC_SYSPARAM_FONT,208,74,37,13,WS_DISABLED
+    GROUPBOX        " S&hell Folder ",IDC_STATIC,8,114,244,100
+    CONTROL         "Listview",IDC_LIST_SFPATHS,"SysListView32",LVS_REPORT | LVS_AUTOARRANGE | LVS_ALIGNLEFT |
+                     LVS_SINGLESEL | WS_BORDER | WS_TABSTOP, 15,126,230,64
+    CONTROL         "&Link to:",IDC_LINK_SFPATH,"Button",BS_AUTOCHECKBOX|WS_TABSTOP|WS_DISABLED,15,195,50,13
+    EDITTEXT         IDC_EDIT_SFPATH,65,195,145,13,ES_AUTOHSCROLL|WS_TABSTOP|WS_DISABLED
+    PUSHBUTTON      "B&rowse",IDC_BROWSE_SFPATH,215,195,30,13,WS_DISABLED
 END
 
 STRINGTABLE DISCARDABLE
diff -uHNrp wine-20071130/programs/winecfg/Ja.rc wine-20071130e/programs/winecfg/Ja.rc
--- wine-20071130/programs/winecfg/Ja.rc	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/programs/winecfg/Ja.rc	2008-02-04 18:31:20.000000000 +0300
@@ -164,10 +164,15 @@ BEGIN
     GROUPBOX        " Driver Selection ",IDC_STATIC,8,4,244,195
     LTEXT	    "I[fBIhCo: ",IDC_STATIC,10,20,277,30
     CONTROL         "Devices",IDC_AUDIO_TREE,"SysTreeView32",WS_BORDER | WS_TABSTOP,15,50,140,140
-    PUSHBUTTON	    "Rg[pl",IDC_AUDIO_CONTROL_PANEL,170,50,49,14
+    PUSHBUTTON      "&Test Sound",IDC_AUDIO_TEST,170,50,59,14
+    PUSHBUTTON	    "Rg[pl",IDC_AUDIO_CONTROL_PANEL,170,70,49,14
     GROUPBOX        " DirectSound ",IDC_STATIC,8,205,244,60
     LTEXT	    "n[hEFAEANZ[V: ",IDC_STATIC,15,215,90,10
     COMBOBOX	    IDC_DSOUND_HW_ACCEL,100,213,150,70,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    LTEXT           "Default &Sample Rate:",IDC_STATIC,15,232,70,8
+    COMBOBOX        IDC_DSOUND_RATES,90,230,42,76,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    LTEXT           "Default &Bits Per Sample:",IDC_STATIC,137,232,80,8
+    COMBOBOX        IDC_DSOUND_BITS,220,230,30,56,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
     CONTROL         "hCoEG~[V",IDC_DSOUND_DRV_EMUL,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,230,230,10
 END
 
diff -uHNrp wine-20071130/programs/winecfg/main.c wine-20071130e/programs/winecfg/main.c
--- wine-20071130/programs/winecfg/main.c	2007-12-01 21:14:24.000000000 +0300
+++ wine-20071130e/programs/winecfg/main.c	2008-02-04 18:31:20.000000000 +0300
@@ -26,6 +26,8 @@
 #define NONAMELESSUNION
 #define NONAMELESSSTRUCT
 
+#include "config.h"
+#include <wine/etersoft.h>
 #include <windows.h>
 #include <commctrl.h>
 #include <objbase.h>
@@ -60,6 +62,10 @@ PropSheetCallback (HWND hWnd, UINT uMsg,
 static INT_PTR CALLBACK
 AboutDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
 {
+    HDC hdc;
+    PAINTSTRUCT ps;
+    RECT rc = {17, 17, 370, 100};
+    char version[MAX_PATH];
     switch (uMsg) {
 
 	case WM_NOTIFY:
@@ -67,6 +73,28 @@ AboutDlgProc (HWND hDlg, UINT uMsg, WPAR
 	    /* otherwise fall through, we want to refresh the page as well */
 	case WM_INITDIALOG:
 	    break;
+	case WM_PAINT:
+/* FIXME: copy (set) font from static resource or use default */
+/*
+            SelectObject(hDlg, part->u.text.hFont);
+            SetTextColor(hDlg, part->u.text.color);
+            SetBkColor(hDlg, win->info->sr_color);
+*/
+            LOADETER_FUNC(etersoft_version);
+            if (etersoft_version) {
+                char *p;
+                strcpy(version, etersoft_version());
+                p = strchr(version, ',');
+		if (p) *p = '\n';
+                p = strstr(version, "Legal");
+                if (p) *p = '\0';
+            } else
+                strcpy(version, PACKAGE_STRING);
+
+            hdc = BeginPaint(hDlg, &ps);
+            DrawText(hdc, version, -1, &rc, DT_LEFT);
+            EndPaint(hDlg, &ps);
+	    break;
 
 	case WM_COMMAND:
 	    break;
diff -uHNrp wine-20071130/programs/winecfg/Pt.rc wine-20071130e/programs/winecfg/Pt.rc
--- wine-20071130/programs/winecfg/Pt.rc	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/programs/winecfg/Pt.rc	2008-02-04 18:31:20.000000000 +0300
@@ -251,11 +251,48 @@ IDD_AUDIOCFG DIALOG DISCARDABLE  0, 0, 2
 STYLE WS_CHILD | WS_DISABLED
 FONT 8, "MS Shell Dlg"
 BEGIN
-    LTEXT	"Controlador udio: ",IDC_STATIC,10,20,60,8
-    COMBOBOX	IDC_AUDIO_DRIVER,70,18,85,85,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
-    PUSHBUTTON	"Autodetectar",IDC_AUDIO_AUTODETECT,170,20,49,14
+    GROUPBOX        " Driver Selection ",IDC_STATIC,8,4,244,195
+    LTEXT           "Select a sound driver by checking the box of the desired driver.  Disable sound by not selecting any driver. Selection of multiple drivers is not recommended. Configure a driver by right-clicking on it.",IDC_STATIC,15,20,227,30
+    CONTROL         "Devices",IDC_AUDIO_TREE,"SysTreeView32",WS_BORDER | WS_TABSTOP,15,50,140,140
+    PUSHBUTTON      "&Test Sound",IDC_AUDIO_TEST,170,50,59,14
+    PUSHBUTTON	    "&Control Panel",IDC_AUDIO_CONTROL_PANEL,170,70,59,14
+    GROUPBOX        " DirectSound ",IDC_STATIC,8,205,244,60
+    LTEXT	    "&Hardware Acceleration: ",IDC_STATIC,15,215,90,10
+    COMBOBOX	    IDC_DSOUND_HW_ACCEL,100,213,150,70,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    LTEXT           "Default &Sample Rate:",IDC_STATIC,15,232,70,8
+    COMBOBOX        IDC_DSOUND_RATES,90,230,42,76,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    LTEXT           "Default &Bits Per Sample:",IDC_STATIC,137,232,80,8
+    COMBOBOX        IDC_DSOUND_BITS,220,230,30,56,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    CONTROL         "Driver &Emulation",IDC_DSOUND_DRV_EMUL,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,250,230,10
 END
 
+IDD_DESKTOP_INTEGRATION DIALOG DISCARDABLE  0, 0, 260, 250
+STYLE WS_CHILD | WS_DISABLED
+FONT 8, "MS Shell Dlg"
+BEGIN
+    GROUPBOX        " Appearance ",IDC_STATIC,8,4,244,106
+    LTEXT           "&Theme:",IDC_STATIC,15,16,130,8
+    COMBOBOX        IDC_THEME_THEMECOMBO,15,24,130,14,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    PUSHBUTTON      "&Install theme...",IDC_THEME_INSTALL,152,23,93,14
+    LTEXT           "&Color:",IDC_THEME_COLORTEXT,15,40,112,8
+    COMBOBOX        IDC_THEME_COLORCOMBO,15,48,112,14,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    LTEXT           "&Size:",IDC_THEME_SIZETEXT,135,40,110,8
+    COMBOBOX        IDC_THEME_SIZECOMBO,135,48,110,14,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    LTEXT           "It&em:",IDC_STATIC,15,64,112,8
+    COMBOBOX        IDC_SYSPARAM_COMBO,15,74,112,120,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP | CBS_SORT
+    LTEXT           "C&olor:",IDC_SYSPARAM_COLOR_TEXT,135,64,25,8,WS_DISABLED
+    PUSHBUTTON      "",IDC_SYSPARAM_COLOR,135,74,25,13,WS_DISABLED | BS_OWNERDRAW
+    LTEXT           "Si&ze:",IDC_SYSPARAM_SIZE_TEXT,166,64,30,8,WS_DISABLED
+    EDITTEXT        IDC_SYSPARAM_SIZE,166,74,23,13,ES_AUTOHSCROLL | WS_TABSTOP | WS_DISABLED
+    CONTROL         "",IDC_SYSPARAM_SIZE_UD,UPDOWN_CLASS,UDS_SETBUDDYINT | WS_DISABLED,187,74,15,13
+    PUSHBUTTON      "&Font",IDC_SYSPARAM_FONT,208,74,37,13,WS_DISABLED
+    GROUPBOX        " S&hell Folder ",IDC_STATIC,8,114,244,100
+    CONTROL         "Listview",IDC_LIST_SFPATHS,"SysListView32",LVS_REPORT | LVS_AUTOARRANGE | LVS_ALIGNLEFT |
+                     LVS_SINGLESEL | WS_BORDER | WS_TABSTOP, 15,126,230,64
+    CONTROL         "&Link to:",IDC_LINK_SFPATH,"Button",BS_AUTOCHECKBOX|WS_TABSTOP|WS_DISABLED,15,195,50,13
+    EDITTEXT         IDC_EDIT_SFPATH,65,195,145,13,ES_AUTOHSCROLL|WS_TABSTOP|WS_DISABLED
+    PUSHBUTTON      "B&rowse",IDC_BROWSE_SFPATH,215,195,30,13,WS_DISABLED
+END
 
 LANGUAGE LANG_PORTUGUESE, SUBLANG_NEUTRAL
 
diff -uHNrp wine-20071130/programs/winecfg/Ro.rc wine-20071130e/programs/winecfg/Ro.rc
--- wine-20071130/programs/winecfg/Ro.rc	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/programs/winecfg/Ro.rc	2008-02-04 18:31:20.000000000 +0300
@@ -166,7 +166,8 @@ BEGIN
     GROUPBOX        " Selectare driver ",IDC_STATIC,8,4,244,195
     LTEXT           "Select a sound driver by checking the box of the desired driver.  Disable sound by not selecting any driver. Selection of multiple drivers is not recommended. Configure a driver by right-clicking on it.",IDC_STATIC,15,20,227,30
     CONTROL         "Dispozitive",IDC_AUDIO_TREE,"SysTreeView32",WS_BORDER | WS_TABSTOP,15,50,140,140
-    PUSHBUTTON      "Panoul de control",IDC_AUDIO_CONTROL_PANEL,170,50,59,14
+    PUSHBUTTON      "&Test Sound",IDC_AUDIO_TEST,170,50,59,14
+    PUSHBUTTON      "Panoul de control",IDC_AUDIO_CONTROL_PANEL,170,70,59,14
     GROUPBOX        " DirectSound ",IDC_STATIC,8,205,244,60
     LTEXT           "Hardware Acceleration: ",IDC_STATIC,15,215,90,10
     COMBOBOX        IDC_DSOUND_HW_ACCEL,100,213,150,70,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
diff -uHNrp wine-20071130/programs/winecfg/Ru.rc wine-20071130e/programs/winecfg/Ru.rc
--- wine-20071130/programs/winecfg/Ru.rc	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/programs/winecfg/Ru.rc	2008-02-04 18:31:20.000000000 +0300
@@ -166,7 +166,8 @@ BEGIN
     GROUPBOX        "   ",IDC_STATIC,8,4,244,195
     LTEXT	    " : ",IDC_STATIC,15,20,227,30
     CONTROL         "Devices",IDC_AUDIO_TREE,"SysTreeView32",WS_BORDER | WS_TABSTOP,15,50,140,140
-    PUSHBUTTON	    " ",IDC_AUDIO_CONTROL_PANEL,170,50,80,14
+    PUSHBUTTON      "&Test Sound",IDC_AUDIO_TEST,170,50,59,14
+    PUSHBUTTON	    " ",IDC_AUDIO_CONTROL_PANEL,170,70,80,14
     GROUPBOX        " DirectSound ",IDC_STATIC,8,205,244,60
     LTEXT	    " : ",IDC_STATIC,15,215,90,10
     COMBOBOX	    IDC_DSOUND_HW_ACCEL,100,213,145,70,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
diff -uHNrp wine-20071130/programs/winecfg/Si.rc wine-20071130e/programs/winecfg/Si.rc
--- wine-20071130/programs/winecfg/Si.rc	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/programs/winecfg/Si.rc	2008-02-04 18:31:20.000000000 +0300
@@ -87,6 +87,53 @@ FONT 8, "MS Shell Dlg"
 BEGIN
 END
 
+IDD_AUDIOCFG DIALOG DISCARDABLE  0, 0, 260, 250
+STYLE WS_CHILD | WS_DISABLED
+FONT 8, "MS Shell Dlg"
+BEGIN
+    GROUPBOX        " Driver Selection ",IDC_STATIC,8,4,244,195
+    LTEXT           "Select a sound driver by checking the box of the desired driver.  Disable sound by not selecting any driver. Selection of multiple drivers is not recommended. Configure a driver by right-clicking on it.",IDC_STATIC,15,20,227,30
+    CONTROL         "Devices",IDC_AUDIO_TREE,"SysTreeView32",WS_BORDER | WS_TABSTOP,15,50,140,140
+    PUSHBUTTON      "&Test Sound",IDC_AUDIO_TEST,170,50,59,14
+    PUSHBUTTON	    "&Control Panel",IDC_AUDIO_CONTROL_PANEL,170,70,59,14
+    GROUPBOX        " DirectSound ",IDC_STATIC,8,205,244,60
+    LTEXT	    "&Hardware Acceleration: ",IDC_STATIC,15,215,90,10
+    COMBOBOX	    IDC_DSOUND_HW_ACCEL,100,213,150,70,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    LTEXT           "Default &Sample Rate:",IDC_STATIC,15,232,70,8
+    COMBOBOX        IDC_DSOUND_RATES,90,230,42,76,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    LTEXT           "Default &Bits Per Sample:",IDC_STATIC,137,232,80,8
+    COMBOBOX        IDC_DSOUND_BITS,220,230,30,56,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    CONTROL         "Driver &Emulation",IDC_DSOUND_DRV_EMUL,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,15,250,230,10
+END
+
+IDD_DESKTOP_INTEGRATION DIALOG DISCARDABLE  0, 0, 260, 250
+STYLE WS_CHILD | WS_DISABLED
+FONT 8, "MS Shell Dlg"
+BEGIN
+    GROUPBOX        " Appearance ",IDC_STATIC,8,4,244,106
+    LTEXT           "&Theme:",IDC_STATIC,15,16,130,8
+    COMBOBOX        IDC_THEME_THEMECOMBO,15,24,130,14,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    PUSHBUTTON      "&Install theme...",IDC_THEME_INSTALL,152,23,93,14
+    LTEXT           "&Color:",IDC_THEME_COLORTEXT,15,40,112,8
+    COMBOBOX        IDC_THEME_COLORCOMBO,15,48,112,14,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    LTEXT           "&Size:",IDC_THEME_SIZETEXT,135,40,110,8
+    COMBOBOX        IDC_THEME_SIZECOMBO,135,48,110,14,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
+    LTEXT           "It&em:",IDC_STATIC,15,64,112,8
+    COMBOBOX        IDC_SYSPARAM_COMBO,15,74,112,120,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP | CBS_SORT
+    LTEXT           "C&olor:",IDC_SYSPARAM_COLOR_TEXT,135,64,25,8,WS_DISABLED
+    PUSHBUTTON      "",IDC_SYSPARAM_COLOR,135,74,25,13,WS_DISABLED | BS_OWNERDRAW
+    LTEXT           "Si&ze:",IDC_SYSPARAM_SIZE_TEXT,166,64,30,8,WS_DISABLED
+    EDITTEXT        IDC_SYSPARAM_SIZE,166,74,23,13,ES_AUTOHSCROLL | WS_TABSTOP | WS_DISABLED
+    CONTROL         "",IDC_SYSPARAM_SIZE_UD,UPDOWN_CLASS,UDS_SETBUDDYINT | WS_DISABLED,187,74,15,13
+    PUSHBUTTON      "&Font",IDC_SYSPARAM_FONT,208,74,37,13,WS_DISABLED
+    GROUPBOX        " S&hell Folder ",IDC_STATIC,8,114,244,100
+    CONTROL         "Listview",IDC_LIST_SFPATHS,"SysListView32",LVS_REPORT | LVS_AUTOARRANGE | LVS_ALIGNLEFT |
+                     LVS_SINGLESEL | WS_BORDER | WS_TABSTOP, 15,126,230,64
+    CONTROL         "&Link to:",IDC_LINK_SFPATH,"Button",BS_AUTOCHECKBOX|WS_TABSTOP|WS_DISABLED,15,195,50,13
+    EDITTEXT         IDC_EDIT_SFPATH,65,195,145,13,ES_AUTOHSCROLL|WS_TABSTOP|WS_DISABLED
+    PUSHBUTTON      "B&rowse",IDC_BROWSE_SFPATH,215,195,30,13,WS_DISABLED
+END
+
 STRINGTABLE DISCARDABLE 
 BEGIN
     IDS_WINE_VERSION        "CVS"
diff -uHNrp wine-20071130/programs/winecfg/theme.c wine-20071130e/programs/winecfg/theme.c
--- wine-20071130/programs/winecfg/theme.c	2007-12-01 21:14:24.000000000 +0300
+++ wine-20071130e/programs/winecfg/theme.c	2008-02-04 18:31:20.000000000 +0300
@@ -731,7 +731,7 @@ static void init_shell_folder_listview_h
     LoadString(GetModuleHandle(NULL), IDS_LINKS_TO, szLinksTo, sizeof(szLinksTo));
     
     GetClientRect(GetDlgItem(dialog, IDC_LIST_SFPATHS), &viewRect);
-    width = (viewRect.right - viewRect.left) / 4;
+    width = (viewRect.right - viewRect.left) / 3;
 
     listColumn.mask = LVCF_TEXT | LVCF_WIDTH | LVCF_SUBITEM;
     listColumn.pszText = szShellFolder;
diff -uHNrp wine-20071130/programs/winecfg/Tr.rc wine-20071130e/programs/winecfg/Tr.rc
--- wine-20071130/programs/winecfg/Tr.rc	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/programs/winecfg/Tr.rc	2008-02-04 18:31:20.000000000 +0300
@@ -164,7 +164,8 @@ BEGIN
     GROUPBOX        " Src Seimi ",IDC_STATIC,8,4,244,195
     LTEXT           "stediiniz srcnn kutusunu iaretleyerek bir ses srcs sein. Hibir src semeyerek sesi etkisizletirebilirsiniz. Birden fazla src seimi nerilmez. zerine sa tklayarak bir srcy yaplandrn.",IDC_STATIC,15,20,227,30
     CONTROL         "Aygtlar",IDC_AUDIO_TREE,"SysTreeView32",WS_BORDER | WS_TABSTOP,15,50,140,140 
-    PUSHBUTTON	    "Denetim Masas",IDC_AUDIO_CONTROL_PANEL,170,50,59,14
+    PUSHBUTTON      "&Test Sound",IDC_AUDIO_TEST,170,50,59,14
+    PUSHBUTTON	    "Denetim Masas",IDC_AUDIO_CONTROL_PANEL,170,70,59,14
     GROUPBOX        " DirectSound ",IDC_STATIC,8,205,244,60
     LTEXT           "Donanm Hzlandrmas: ",IDC_STATIC,15,215,90,10
     COMBOBOX	    IDC_DSOUND_HW_ACCEL,100,213,150,70,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP
diff -uHNrp wine-20071130/programs/winecfg/winecfg.rc wine-20071130e/programs/winecfg/winecfg.rc
--- wine-20071130/programs/winecfg/winecfg.rc	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/programs/winecfg/winecfg.rc	2008-02-04 18:31:20.000000000 +0300
@@ -52,6 +52,18 @@
 
 LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
 
+/* Override about dialog by our one */
+IDD_ABOUTCFG DIALOGEX 0, 0, 260, 270
+STYLE WS_CHILD
+FONT 8, "MS Shell Dlg"
+BEGIN
+    CONTROL         IDB_WINE,IDC_STATIC,"Static",SS_BITMAP ,15,37,157,111
+    LTEXT           "http://etersoft.ru/wine",IDC_STATIC,119,51,106,8
+    LTEXT           "This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.",
+                    IDC_STATIC,119,64,124,72
+END
+
+
 /* @makedep: idb_wine.bmp */
 IDB_WINE BITMAP idb_wine.bmp
 
diff -uHNrp wine-20071130/programs/wineconsole/curses.c wine-20071130e/programs/wineconsole/curses.c
--- wine-20071130/programs/wineconsole/curses.c	2007-12-01 21:14:24.000000000 +0300
+++ wine-20071130e/programs/wineconsole/curses.c	2008-02-04 18:31:20.000000000 +0300
@@ -836,7 +836,7 @@ static unsigned WCCURSES_FillCode(struct
     case KEY_SUSPEND:
     case KEY_UNDO:
     notFound:
-        WINE_FIXME("Not done yet (%o)\n", inchar);
+        WINE_TRACE("Not done yet (%o)\n", inchar);
         break;
     default:
         WINE_ERR("Unknown val (%o)\n", inchar);
diff -uHNrp wine-20071130/programs/wineconsole/user.c wine-20071130e/programs/wineconsole/user.c
--- wine-20071130/programs/wineconsole/user.c	2007-12-01 21:14:24.000000000 +0300
+++ wine-20071130e/programs/wineconsole/user.c	2008-02-04 18:31:20.000000000 +0300
@@ -1009,6 +1009,10 @@ static void WCUSER_HandleSelectionKey(st
     PRIVATE(data)->has_selection = FALSE;
 }
 
+static BOOL bMaximazed = FALSE;
+static LOGFONTW lfo;
+static WCHAR szCourierNew[] = {'C', 'o', 'u', 'r', 'i', 'e', 'r', ' ', 'N', 'e', 'w', 0};
+
 /******************************************************************
  *		WCUSER_GenerateKeyInputRecord
  *
@@ -1034,6 +1038,44 @@ static void    WCUSER_GenerateKeyInputRe
     ir.Event.KeyEvent.dwControlKeyState = WCUSER_GetCtrlKeyState(keyState);
     if (lParam & (1L << 24))		ir.Event.KeyEvent.dwControlKeyState |= ENHANCED_KEY;
     if (sys)				ir.Event.KeyEvent.dwControlKeyState |= LEFT_ALT_PRESSED; /* FIXME: gotta choose one */
+    if( (ir.Event.KeyEvent.dwControlKeyState & LEFT_ALT_PRESSED)&&(ir.Event.KeyEvent.bKeyDown) )
+    {
+        if( ir.Event.KeyEvent.wVirtualKeyCode == VK_RETURN )
+        {
+            if(bMaximazed) /* Minimazing */
+            {
+                WCUSER_SetFont(data,  &lfo);
+                bMaximazed = FALSE;
+            }
+            else /* Maximazing */
+            {
+                LOGFONTW     lf;
+                int          nCx = GetSystemMetrics(SM_CXSCREEN);
+
+                GetObjectW(PRIVATE(data)->hFont, sizeof(LOGFONTW), &lf);
+                lfo = lf;
+                switch( nCx )
+                {
+                    case 1280:
+                        WCUSER_FillLogFont( &lf, szCourierNew,  27,  14 );
+                    break;
+
+                    case 1024:
+                        WCUSER_FillLogFont( &lf, szCourierNew,  21,  11 );
+                    break;
+
+                     case 800:
+                        WCUSER_FillLogFont( &lf, szCourierNew,  16,  8 );
+                    break;
+
+                    /* default:  Nothing to do. Fall  through */
+                }
+
+                WCUSER_SetFont(data,  &lf);
+                bMaximazed = TRUE;
+            }
+        }
+    }
 
     if (!(ir.Event.KeyEvent.dwControlKeyState & ENHANCED_KEY))
     {
diff -uHNrp wine-20071130/programs/winefile/winefile.c wine-20071130e/programs/winefile/winefile.c
--- wine-20071130/programs/winefile/winefile.c	2007-12-01 21:14:24.000000000 +0300
+++ wine-20071130e/programs/winefile/winefile.c	2008-02-04 18:31:20.000000000 +0300
@@ -66,6 +66,7 @@ static const WCHAR reg_start_x[] = { 's'
 static const WCHAR reg_start_y[] = { 's','t','a','r','t','Y','\0'};
 static const WCHAR reg_width[] = { 'w','i','d','t','h','\0'};
 static const WCHAR reg_height[] = { 'h','e','i','g','h','t','\0'};
+static const WCHAR reg_logfont[] = { 'l','o','g','f','o','n','t','\0'};
 
 enum ENTRY_TYPE {
 	ET_WINDOWS,
@@ -1645,6 +1646,7 @@ static windowOptions load_registry_setti
 	DWORD type;
 	HKEY hKey;
 	windowOptions opts;
+	LOGFONT logfont;
 
         RegOpenKeyExW( HKEY_CURRENT_USER, registry_key,
                        0, KEY_QUERY_VALUE, &hKey );
@@ -1666,9 +1668,14 @@ static windowOptions load_registry_setti
         if( RegQueryValueExW( hKey, reg_height, NULL, &type,
                               (LPBYTE) &opts.height, &size ) != ERROR_SUCCESS )
 		opts.height = CW_USEDEFAULT;
+	size=sizeof(logfont);
+	if( RegQueryValueExW( hKey, reg_logfont, NULL, &type,
+                              (LPBYTE) &logfont, &size ) != ERROR_SUCCESS )
+		GetObject(GetStockObject(DEFAULT_GUI_FONT),sizeof(logfont),&logfont);
 
 	RegCloseKey( hKey );
 
+	Globals.hfont = CreateFontIndirect(&logfont);
 	return opts;
 }
 
@@ -1677,6 +1684,7 @@ static void save_registry_settings(void)
 	WINDOWINFO wi;
 	HKEY hKey;
 	INT width, height;
+	LOGFONT logfont;
 
 	wi.cbSize = sizeof( WINDOWINFO );
 	GetWindowInfo(Globals.hMainWnd, &wi);
@@ -1704,6 +1712,9 @@ static void save_registry_settings(void)
                         (LPBYTE) &width, sizeof(DWORD) );
         RegSetValueExW( hKey, reg_height, 0, REG_DWORD,
                         (LPBYTE) &height, sizeof(DWORD) );
+        GetObject(Globals.hfont, sizeof(logfont), &logfont);
+        RegSetValueExW( hKey, reg_logfont, 0, REG_BINARY,
+                        (LPBYTE) &logfont, sizeof(LOGFONT) );
 
 	/* TODO: Save more settings here (List vs. Detailed View, etc.) */
 	RegCloseKey( hKey );
diff -uHNrp wine-20071130/programs/winemenubuilder/winemenubuilder.c wine-20071130e/programs/winemenubuilder/winemenubuilder.c
--- wine-20071130/programs/winemenubuilder/winemenubuilder.c	2007-12-01 21:14:24.000000000 +0300
+++ wine-20071130e/programs/winemenubuilder/winemenubuilder.c	2008-02-04 18:31:20.000000000 +0300
@@ -595,7 +595,7 @@ static LPSTR escape(LPCWSTR arg)
     return narg;
 }
 
-static int fork_and_wait( const char *linker, const char *link_name, const char *path,
+static int fork_and_wait( const char *linker, const char *program_name, const char *link_name, const char *path,
                           int desktop, const char *args, const char *icon_name,
                           const char *workdir, const char *description )
 {
@@ -603,14 +603,16 @@ static int fork_and_wait( const char *li
     const char *argv[20];
     int retcode;
 
-    WINE_TRACE( "linker app='%s' link='%s' mode=%s "
+    WINE_TRACE( "linker app='%s' progname='%s' link='%s' mode=%s "
         "path='%s' args='%s' icon='%s' workdir='%s' descr='%s'\n",
-        linker, link_name, desktop ? "desktop" : "menu",
+        linker, program_name, link_name, desktop ? "desktop" : "menu",
         path, args, icon_name, workdir, description  );
 
     argv[pos++] = linker ;
     argv[pos++] = "--link";
     argv[pos++] = link_name;
+    argv[pos++] = "--name";
+    argv[pos++] = program_name;
     argv[pos++] = "--path";
     argv[pos++] = path;
     argv[pos++] = desktop ? "--desktop" : "--menu";
@@ -855,11 +857,13 @@ static BOOL InvokeShellLinker( IShellLin
     static const WCHAR startW[] = {'\\','c','o','m','m','a','n','d',
                                    '\\','s','t','a','r','t','.','e','x','e',0};
     char *link_name = NULL, *icon_name = NULL, *work_dir = NULL;
+    char program_name[MAX_PATH];
     char *escaped_path = NULL, *escaped_args = NULL, *escaped_description = NULL;
     WCHAR szDescription[INFOTIPSIZE], szPath[MAX_PATH], szWorkDir[MAX_PATH];
     WCHAR szArgs[INFOTIPSIZE], szIconPath[MAX_PATH];
+    LPCWSTR lastslash;
     int iIconId = 0, r = -1;
-    DWORD csidl = -1;
+    DWORD csidl = -1, rs;
     HANDLE hsem = NULL;
 
     if ( !link )
@@ -873,12 +877,27 @@ static BOOL InvokeShellLinker( IShellLin
         WINE_WARN("Unknown link location %s. Ignoring.\n",wine_dbgstr_w(link));
         return TRUE;
     }
+    
+    /* Recode link name to UTF8 and make Name from win path*/
+    lastslash = link;
+    for (rs = 0 ; link[rs] ; rs++)
+        if (link[rs] == '\\')
+            lastslash = &link[rs];
+    WideCharToMultiByte(CP_UTF8, 0, lastslash+1, -1, program_name,
+                            MAX_PATH, NULL, NULL);
+    for (rs = strlen(program_name) ; rs ; rs--)
+        if (program_name[rs] == '.') {
+            program_name[rs] = '\0';
+            break;
+        }
+
     if (!in_desktop_dir(csidl) && !in_startmenu(csidl))
     {
         WINE_WARN("Not under desktop or start menu. Ignoring.\n");
         return TRUE;
     }
     WINE_TRACE("Link       : %s\n", wine_dbgstr_a(link_name));
+    WINE_TRACE("Program name : %s\n", wine_dbgstr_a(program_name));
 
     szWorkDir[0] = 0;
     IShellLinkW_GetWorkingDirectory( sl, szWorkDir, MAX_PATH );
@@ -978,10 +997,10 @@ static BOOL InvokeShellLinker( IShellLin
         goto cleanup;
     }
 
-    r = fork_and_wait("wineshelllink", link_name, escaped_path,
+    r = fork_and_wait("wineshelllink", program_name, link_name, escaped_path,
                       in_desktop_dir(csidl), escaped_args, icon_name,
                       work_dir ? work_dir : "", escaped_description);
-
+    WINE_TRACE("wineshellink ok\n");
     ReleaseSemaphore( hsem, 1, NULL );
 
 cleanup:
diff -uHNrp wine-20071130/programs/winhelp/hlpfile.c wine-20071130e/programs/winhelp/hlpfile.c
--- wine-20071130/programs/winhelp/hlpfile.c	2007-12-01 21:14:24.000000000 +0300
+++ wine-20071130e/programs/winhelp/hlpfile.c	2008-02-04 18:31:20.000000000 +0300
@@ -3,6 +3,7 @@
  *
  * Copyright    1996 Ulrich Schmid
  *              2002 Eric Pouech
+ *              2007 Kirill K. Smirnov
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -50,6 +51,7 @@ static inline unsigned GET_UINT(const BY
 
 static HLPFILE *first_hlpfile = 0;
 static BYTE    *file_buffer;
+static UINT     file_buffer_size;
 
 static struct
 {
@@ -74,6 +76,18 @@ static struct
     HLPFILE_LINK*       link;
 } attributes;
 
+/*
+ * Compare function type for HLPFILE_BPTreeSearch function.
+ *
+ * PARAMS
+ *     p       [I] pointer to testing block (key + data)
+ *     key     [I] pointer to key value to look for
+ *     leaf    [I] whether this function called for index of leaf page
+ *     next    [O] pointer to pointer to next block
+ */
+typedef int (*HLPFILE_BPTreeCompare)(void *p, const void *key,
+                                     int leaf, void **next);
+
 static BOOL  HLPFILE_DoReadHlpFile(HLPFILE*, LPCSTR);
 static BOOL  HLPFILE_ReadFileToBuffer(HFILE);
 static BOOL  HLPFILE_FindSubFile(LPCSTR name, BYTE**, BYTE**);
@@ -92,27 +106,24 @@ static BOOL  HLPFILE_Uncompress3(char*, 
 static void  HLPFILE_UncompressRLE(const BYTE* src, const BYTE* end, BYTE** dst, unsigned dstsz);
 static BOOL  HLPFILE_ReadFont(HLPFILE* hlpfile);
 
-#if 0
+static void* HLPFILE_BPTreeSearch(BYTE*, const void*, HLPFILE_BPTreeCompare);
+
 /***********************************************************************
  *
  *           HLPFILE_PageByNumber
  */
-static HLPFILE_PAGE *HLPFILE_PageByNumber(LPCSTR lpszPath, UINT wNum)
+static HLPFILE_PAGE *HLPFILE_PageByNumber(HLPFILE* hlpfile, UINT wNum)
 {
     HLPFILE_PAGE *page;
-    HLPFILE *hlpfile = HLPFILE_ReadHlpFile(lpszPath);
-
-    if (!hlpfile) return 0;
-
-    WINE_TRACE("[%s/%u]\n", lpszPath, wNum);
+    UINT          temp = wNum;
 
-    for (page = hlpfile->first_page; page && wNum; page = page->next) wNum--;
-
-    /* HLPFILE_FreeHlpFile(lpszPath); */
+    WINE_TRACE("<%s>[%u]\n", hlpfile->lpszPath, wNum);
 
+    for (page = hlpfile->first_page; page && temp; page = page->next) temp--;
+    if (!page)
+        WINE_ERR("Page of number %u not found in file %s\n", wNum, hlpfile->lpszPath);
     return page;
 }
-#endif
 
 /* FIXME:
  * this finds the page containing the offset. The offset can either
@@ -151,26 +162,49 @@ HLPFILE_PAGE *HLPFILE_PageByOffset(HLPFI
     return found;
 }
 
+/**************************************************************************
+ * comp_PageByHash
+ *
+ * HLPFILE_BPTreeCompare function for '|CONTEXT' B+ tree file
+ *
+ */
+static int comp_PageByHash(void *p, const void *key,
+                           int leaf, void** next)
+{
+    LONG lKey = (LONG)key;
+    LONG lTest = GET_UINT(p, 0);
+
+    *next = (char *)p+(leaf?8:6);
+    WINE_TRACE("Comparing '%u' with '%u'\n", lKey, lTest);
+    if (lTest < lKey) return -1;
+    if (lTest > lKey) return 1;
+    return 0;
+}
+
 /***********************************************************************
  *
  *           HLPFILE_HlpFilePageByHash
  */
 HLPFILE_PAGE *HLPFILE_PageByHash(HLPFILE* hlpfile, LONG lHash)
 {
-    unsigned int i;
+    BYTE *ptr;
 
     if (!hlpfile) return 0;
 
     WINE_TRACE("<%s>[%x]\n", hlpfile->lpszPath, lHash);
 
-    for (i = 0; i < hlpfile->wContextLen; i++)
+    /* For win 3.0 files hash values are really page numbers */
+    if (hlpfile->version <= 16)
+        return HLPFILE_PageByNumber(hlpfile, lHash);
+
+    ptr = HLPFILE_BPTreeSearch(hlpfile->Context, (void*)lHash, comp_PageByHash);
+    if (!ptr)
     {
-        if (hlpfile->Context[i].lHash == lHash)
-            return HLPFILE_PageByOffset(hlpfile, hlpfile->Context[i].offset);
+        WINE_ERR("Page of hash %x not found in file %s\n", lHash, hlpfile->lpszPath);
+        return NULL;
     }
 
-    WINE_ERR("Page of hash %x not found in file %s\n", lHash, hlpfile->lpszPath);
-    return NULL;
+    return HLPFILE_PageByOffset(hlpfile, GET_UINT(ptr, 4));
 }
 
 /***********************************************************************
@@ -258,7 +292,6 @@ HLPFILE *HLPFILE_ReadHlpFile(LPCSTR lpsz
     hlpfile->lpszCopyright      = NULL;
     hlpfile->first_page         = NULL;
     hlpfile->first_macro        = NULL;
-    hlpfile->wContextLen        = 0;
     hlpfile->Context            = NULL;
     hlpfile->wMapLen            = 0;
     hlpfile->Map                = NULL;
@@ -337,9 +370,15 @@ static BOOL HLPFILE_DoReadHlpFile(HLPFIL
     {
         BYTE*   end;
 
-        /* FIXME this depends on the blocksize, can be 2k in some cases */
-        index  = (ref - 0x0C) >> 14;
-        offset = (ref - 0x0C) & 0x3fff;
+        index  = (ref - 0x0C) / hlpfile->dsize;
+        offset = (ref - 0x0C) % hlpfile->dsize;
+
+        if (hlpfile->version <= 16 && index != old_index && index != 0)
+        {
+            /* we jumped to the next block, adjust pointers */
+            ref -= 12;
+            offset -= 12;
+        }
 
         WINE_TRACE("ref=%08x => [%u/%u]\n", ref, index, offset);
 
@@ -355,11 +394,8 @@ static BOOL HLPFILE_DoReadHlpFile(HLPFIL
             if (!HLPFILE_AddPage(hlpfile, buf, end, index * 0x8000L + offs)) return FALSE;
             break;
 
+	case 0x01:
 	case 0x20:
-            if (!HLPFILE_AddParagraph(hlpfile, buf, end, &len)) return FALSE;
-            offs += len;
-            break;
-
 	case 0x23:
             if (!HLPFILE_AddParagraph(hlpfile, buf, end, &len)) return FALSE;
             offs += len;
@@ -369,10 +405,18 @@ static BOOL HLPFILE_DoReadHlpFile(HLPFIL
             WINE_ERR("buf[0x14] = %x\n", buf[0x14]);
 	}
 
-        ref = GET_UINT(buf, 0xc);
+        if (hlpfile->version <= 16)
+        {
+            ref += GET_UINT(buf, 0xc);
+            if (GET_UINT(buf, 0xc) == 0)
+                break;
+        }
+        else
+            ref = GET_UINT(buf, 0xc);
     } while (ref != 0xffffffff);
 
     HLPFILE_GetMap(hlpfile);
+    if (hlpfile->version <= 16) return TRUE;
     return HLPFILE_GetContext(hlpfile);
 }
 
@@ -388,7 +432,6 @@ static BOOL HLPFILE_AddPage(HLPFILE *hlp
     char*         ptr;
     HLPFILE_MACRO*macro;
 
-    if (buf + 0x31 > end) {WINE_WARN("page1\n"); return FALSE;};
     title = buf + GET_UINT(buf, 0x10);
     if (title > end) {WINE_WARN("page2\n"); return FALSE;};
 
@@ -897,8 +940,12 @@ static BOOL HLPFILE_AddParagraph(HLPFILE
     format = buf + 0x15;
     format_end = buf + GET_UINT(buf, 0x10);
 
-    fetch_long(&format);
-    *len = fetch_ushort(&format);
+    if (buf[0x14] == 0x20 || buf[0x14] == 0x23)
+    {
+        fetch_long(&format);
+        *len = fetch_ushort(&format);
+    }
+    else *len = end-buf-15;
 
     if (buf[0x14] == 0x23)
     {
@@ -918,7 +965,10 @@ static BOOL HLPFILE_AddParagraph(HLPFILE
         WINE_TRACE("looking for format at offset %u for column %d\n", format - (buf + 0x15), nc);
         if (buf[0x14] == 0x23)
             format += 5;
-        format += 4;
+        if (buf[0x14] == 0x01)
+            format += 6;
+        else
+            format += 4;
         bits = GET_USHORT(format, 0); format += 2;
         if (bits & 0x0001) fetch_long(&format);
         if (bits & 0x0002) fetch_short(&format);
@@ -1108,6 +1158,13 @@ static BOOL HLPFILE_AddParagraph(HLPFILE
             case 0xE0:
             case 0xE1:
                 WINE_WARN("jump topic 1 => %u\n", GET_UINT(format, 1));
+                HLPFILE_FreeLink(attributes.link);
+                attributes.link = HLPFILE_AllocLink((*format & 1) ? hlp_link_link : hlp_link_popup,
+                                                    hlpfile->lpszPath,
+                                                    GET_UINT(format, 1)-16,
+                                                    1, -1);
+
+
                 format += 5;
                 break;
 
@@ -1209,7 +1266,7 @@ static BOOL HLPFILE_ReadFont(HLPFILE* hl
         flag = ref[dscr_offset + i * 11 + 0];
         family = ref[dscr_offset + i * 11 + 2];
 
-        hlpfile->fonts[i].LogFont.lfHeight = -ref[dscr_offset + i * 11 + 1] / 2;
+        hlpfile->fonts[i].LogFont.lfHeight = -ref[dscr_offset + i * 11 + 1] / 2 - 3;
         hlpfile->fonts[i].LogFont.lfWidth = 0;
         hlpfile->fonts[i].LogFont.lfEscapement = 0;
         hlpfile->fonts[i].LogFont.lfOrientation = 0;
@@ -1217,7 +1274,7 @@ static BOOL HLPFILE_ReadFont(HLPFILE* hl
         hlpfile->fonts[i].LogFont.lfItalic = (flag & 2) ? TRUE : FALSE;
         hlpfile->fonts[i].LogFont.lfUnderline = (flag & 4) ? TRUE : FALSE;
         hlpfile->fonts[i].LogFont.lfStrikeOut = (flag & 8) ? TRUE : FALSE;
-        hlpfile->fonts[i].LogFont.lfCharSet = ANSI_CHARSET;
+        hlpfile->fonts[i].LogFont.lfCharSet = DEFAULT_CHARSET;
         hlpfile->fonts[i].LogFont.lfOutPrecision = OUT_DEFAULT_PRECIS;
         hlpfile->fonts[i].LogFont.lfClipPrecision = CLIP_DEFAULT_PRECIS;
         hlpfile->fonts[i].LogFont.lfQuality = DEFAULT_QUALITY;
@@ -1272,7 +1329,6 @@ static BOOL HLPFILE_ReadFont(HLPFILE* hl
 static BOOL HLPFILE_ReadFileToBuffer(HFILE hFile)
 {
     BYTE  header[16], dummy[1];
-    UINT  size;
 
     if (_hread(hFile, header, 16) != 16) {WINE_WARN("header\n"); return FALSE;};
 
@@ -1280,87 +1336,65 @@ static BOOL HLPFILE_ReadFileToBuffer(HFI
     if (GET_UINT(header, 0) != 0x00035F3F)
     {WINE_WARN("wrong header\n"); return FALSE;};
 
-    size = GET_UINT(header, 12);
-    file_buffer = HeapAlloc(GetProcessHeap(), 0, size + 1);
+    file_buffer_size = GET_UINT(header, 12);
+    file_buffer = HeapAlloc(GetProcessHeap(), 0, file_buffer_size + 1);
     if (!file_buffer) return FALSE;
 
     memcpy(file_buffer, header, 16);
-    if (_hread(hFile, file_buffer + 16, size - 16) != size - 16)
+    if (_hread(hFile, file_buffer + 16, file_buffer_size - 16) != file_buffer_size - 16)
     {WINE_WARN("filesize1\n"); return FALSE;};
 
     if (_hread(hFile, dummy, 1) != 0) WINE_WARN("filesize2\n");
 
-    file_buffer[size] = '\0'; /* FIXME: was '0', sounds ackward to me */
+    file_buffer[file_buffer_size] = '\0'; /* FIXME: was '0', sounds ackward to me */
 
     return TRUE;
 }
 
+/**************************************************************************
+ * comp_FindSubFile
+ *
+ * HLPFILE_BPTreeCompare function for HLPFILE directory.
+ *
+ */
+static int comp_FindSubFile(void *p, const void *key,
+                            int leaf, void** next)
+{
+    *next = (char *)p+strlen(p)+(leaf?5:3);
+    WINE_TRACE("Comparing '%s' with '%s'\n", (char *)p, (char *)key);
+    return strcmp(p, key);
+}
+
 /***********************************************************************
  *
  *           HLPFILE_FindSubFile
  */
 static BOOL HLPFILE_FindSubFile(LPCSTR name, BYTE **subbuf, BYTE **subend)
 {
-    BYTE *root = file_buffer + GET_UINT(file_buffer,  4);
-    BYTE *end  = file_buffer + GET_UINT(file_buffer, 12);
     BYTE *ptr;
-    BYTE *bth;
-
-    unsigned    pgsize;
-    unsigned    pglast;
-    unsigned    nentries;
-    unsigned    i, n;
-
-    bth = root + 9;
-
-    /* FIXME: this should be using the EnumBTree functions from this file */
-    pgsize = GET_USHORT(bth, 4);
-    WINE_TRACE("%s => pgsize=%u #pg=%u rootpg=%u #lvl=%u\n", 
-               name, pgsize, GET_USHORT(bth, 30), GET_USHORT(bth, 26), GET_USHORT(bth, 32));
 
-    ptr = bth + 38 + GET_USHORT(bth, 26) * pgsize;
-
-    for (n = 1; n < GET_USHORT(bth, 32); n++)
+    WINE_TRACE("looking for file '%s'\n", name);
+    ptr = HLPFILE_BPTreeSearch(file_buffer + GET_UINT(file_buffer, 4),
+                               name, comp_FindSubFile);
+    if (!ptr) return FALSE;
+    *subbuf = file_buffer + GET_UINT(ptr, strlen(name)+1);
+    if (*subbuf >= file_buffer + file_buffer_size)
     {
-        nentries = GET_USHORT(ptr, 2);
-        pglast = GET_USHORT(ptr, 4);
-        WINE_TRACE("[%u]: #entries=%u next=%u\n", n, nentries, pglast);
-
-        ptr += 6;
-        for (i = 0; i < nentries; i++)
-        {
-            char *str = (char*) ptr;
-            WINE_TRACE("<= %s\n", str);
-            if (strcmp(name, str) < 0) break;
-            ptr += strlen(str) + 1;
-            pglast = GET_USHORT(ptr, 0);
-            ptr += 2;
-        }
-        ptr = bth + 38 + pglast * pgsize;
+        WINE_ERR("internal file %s does not fit\n", name);
+        return FALSE;
     }
-
-    nentries = GET_USHORT(ptr, 2);
-    ptr += 8;
-    for (i = 0; i < nentries; i++)
+    *subend = *subbuf + GET_UINT(*subbuf, 0);
+    if (*subend > file_buffer + file_buffer_size)
     {
-        char*   fname = (char*)ptr;
-        ptr += strlen(fname) + 1;
-        WINE_TRACE("\\- %s\n", fname);
-        if (strcmp(fname, name) == 0)
-        {
-            *subbuf = file_buffer + GET_UINT(ptr, 0);
-            *subend = *subbuf + GET_UINT(*subbuf, 0);
-            if (file_buffer > *subbuf || *subbuf > *subend || *subend > end)
-	    {
-                WINE_WARN("size mismatch\n");
-                return FALSE;
-	    }
-            return TRUE;
-        }
-        ptr += 4;
+        WINE_ERR("internal file %s does not fit\n", name);
+        return FALSE;
     }
-
-    return FALSE;
+    if (GET_UINT(*subbuf, 0) < GET_UINT(*subbuf, 4) + 9)
+    {
+        WINE_ERR("invalid size provided for internal file %s\n", name);
+        return FALSE;
+    }
+    return TRUE;
 }
 
 /***********************************************************************
@@ -1387,8 +1421,31 @@ static BOOL HLPFILE_SystemCommands(HLPFI
                magic, major, minor, flags);
     if (magic != 0x036C || major != 1)
     {WINE_WARN("Wrong system header\n"); return FALSE;}
-    if (minor <= 16) {WINE_WARN("too old file format (NIY)\n"); return FALSE;}
-    if (flags & 8) {WINE_WARN("Unsupported yet page size\n"); return FALSE;}
+    if (minor <= 16)
+    {
+        hlpfile->tbsize = 0x800;
+        hlpfile->compressed = 0;
+    }
+    else if (flags == 0)
+    {
+        hlpfile->tbsize = 0x1000;
+        hlpfile->compressed = 0;
+    }
+    else if (flags == 4)
+    {
+        hlpfile->tbsize = 0x1000;
+        hlpfile->compressed = 1;
+    }
+    else
+    {
+        hlpfile->tbsize = 0x800;
+        hlpfile->compressed = 1;
+    }
+
+    if (hlpfile->compressed)
+        hlpfile->dsize = 0x4000;
+    else
+        hlpfile->dsize = hlpfile->tbsize - 0x0C;
 
     hlpfile->version = minor;
     hlpfile->flags = flags;
@@ -1552,24 +1609,35 @@ static BYTE *HLPFILE_UncompressLZ77(BYTE
  */
 static BOOL HLPFILE_UncompressLZ77_Phrases(HLPFILE* hlpfile)
 {
-    UINT i, num, dec_size;
+    UINT i, num, dec_size, head_size;
     BYTE *buf, *end;
 
     if (!HLPFILE_FindSubFile("|Phrases", &buf, &end)) return FALSE;
 
+    if (hlpfile->version <= 16)
+        head_size = 13;
+    else
+        head_size = 17;
+
     num = phrases.num = GET_USHORT(buf, 9);
     if (buf + 2 * num + 0x13 >= end) {WINE_WARN("1a\n"); return FALSE;};
 
-    dec_size = HLPFILE_UncompressedLZ77_Size(buf + 0x13 + 2 * num, end);
+    if (hlpfile->version <= 16)
+        dec_size = end - buf - 15 - 2 * num;
+    else
+        dec_size = HLPFILE_UncompressedLZ77_Size(buf + 0x13 + 2 * num, end);
 
     phrases.offsets = HeapAlloc(GetProcessHeap(), 0, sizeof(unsigned) * (num + 1));
     phrases.buffer  = HeapAlloc(GetProcessHeap(), 0, dec_size);
     if (!phrases.offsets || !phrases.buffer) return FALSE;
 
     for (i = 0; i <= num; i++)
-        phrases.offsets[i] = GET_USHORT(buf, 0x11 + 2 * i) - 2 * num - 2;
+        phrases.offsets[i] = GET_USHORT(buf, head_size + 2 * i) - 2 * num - 2;
 
-    HLPFILE_UncompressLZ77(buf + 0x13 + 2 * num, end, (BYTE*)phrases.buffer);
+    if (hlpfile->version <= 16)
+        memcpy(phrases.buffer, buf + 15 + 2*num, dec_size);
+    else
+        HLPFILE_UncompressLZ77(buf + 0x13 + 2 * num, end, (BYTE*)phrases.buffer);
 
     hlpfile->hasPhrases = TRUE;
     return TRUE;
@@ -1654,29 +1722,27 @@ static BOOL HLPFILE_Uncompress_Topic(HLP
 {
     BYTE *buf, *ptr, *end, *newptr;
     unsigned int i, newsize = 0;
+    unsigned int topic_size;
 
     if (!HLPFILE_FindSubFile("|TOPIC", &buf, &end))
     {WINE_WARN("topic0\n"); return FALSE;}
 
-    switch (hlpfile->flags & (8|4))
+    buf += 9; /* Skip file header */
+    topic_size = end - buf;
+    if (hlpfile->compressed)
     {
-    case 8:
-        WINE_FIXME("Unsupported format\n");
-        return FALSE;
-    case 4:
-        buf += 9;
-        topic.wMapLen = (end - buf - 1) / 0x1000 + 1;
-        
+        topic.wMapLen = (topic_size - 1) / hlpfile->tbsize + 1;
+
         for (i = 0; i < topic.wMapLen; i++)
         {
-            ptr = buf + i * 0x1000;
-            
+            ptr = buf + i * hlpfile->tbsize;
+
             /* I don't know why, it's necessary for printman.hlp */
             if (ptr + 0x44 > end) ptr = end - 0x44;
 
-            newsize += HLPFILE_UncompressedLZ77_Size(ptr + 0xc, min(end, ptr + 0x1000));
+            newsize += HLPFILE_UncompressedLZ77_Size(ptr + 0xc, min(end, ptr + hlpfile->tbsize));
         }
-        
+
         topic.map = HeapAlloc(GetProcessHeap(), 0,
                               topic.wMapLen * sizeof(topic.map[0]) + newsize);
         if (!topic.map) return FALSE;
@@ -1685,35 +1751,30 @@ static BOOL HLPFILE_Uncompress_Topic(HLP
 
         for (i = 0; i < topic.wMapLen; i++)
         {
-            ptr = buf + i * 0x1000;
+            ptr = buf + i * hlpfile->tbsize;
             if (ptr + 0x44 > end) ptr = end - 0x44;
 
             topic.map[i] = newptr;
-            newptr = HLPFILE_UncompressLZ77(ptr + 0xc, min(end, ptr + 0x1000), newptr);
+            newptr = HLPFILE_UncompressLZ77(ptr + 0xc, min(end, ptr + hlpfile->tbsize), newptr);
         }
-        break;
-    case 0:
-        /* basically, we need to copy the 0x1000 byte pages (removing the first 0x0C) in
-         * one single are in memory
+    }
+    else
+    {
+        /* basically, we need to copy the TopicBlockSize byte pages
+         * (removing the first 0x0C) in one single area in memory
          */
-#define DST_LEN (0x1000 - 0x0C)
-        buf += 9;
-        newsize = end - buf;
-        /* number of destination pages */
-        topic.wMapLen = (newsize - 1) / DST_LEN + 1;
+        topic.wMapLen = (topic_size - 1) / hlpfile->tbsize + 1;
         topic.map = HeapAlloc(GetProcessHeap(), 0,
-                              topic.wMapLen * (sizeof(topic.map[0]) + DST_LEN));
+                              topic.wMapLen * (sizeof(topic.map[0]) + hlpfile->dsize));
         if (!topic.map) return FALSE;
         newptr = (BYTE*)(topic.map + topic.wMapLen);
-        topic.end = newptr + newsize;
+        topic.end = newptr + topic_size;
 
         for (i = 0; i < topic.wMapLen; i++)
         {
-            topic.map[i] = newptr + i * DST_LEN;
-            memcpy(topic.map[i], buf + i * 0x1000 + 0x0C, DST_LEN);
+            topic.map[i] = newptr + i * hlpfile->dsize;
+            memcpy(topic.map[i], buf + i * hlpfile->tbsize + 0x0C, hlpfile->dsize);
         }
-#undef DST_LEN
-        break;
     }
     return TRUE;
 }
@@ -1853,6 +1914,66 @@ static void HLPFILE_UncompressRLE(const 
                   *dst - (sdst - dstsz), dstsz);
 }
 
+/**************************************************************************
+ * HLPFILE_BPTreeSearch
+ *
+ * Searches for an element in B+ tree
+ *
+ * PARAMS
+ *     buf        [I] pointer to the embedded file structured as a B+ tree
+ *     key        [I] pointer to data to find
+ *     comp       [I] compare function
+ *
+ * RETURNS
+ *     Pointer to block identified by key, or NULL if failure.
+ *
+ */
+static void* HLPFILE_BPTreeSearch(BYTE* buf, const void* key,
+                                  HLPFILE_BPTreeCompare comp)
+{
+    unsigned magic;
+    unsigned page_size;
+    unsigned cur_page;
+    unsigned level;
+    BYTE *pages, *ptr, *newptr;
+    int i, entries;
+    int ret;
+
+    magic = GET_USHORT(buf, 9);
+    if (magic != 0x293B)
+    {
+        WINE_ERR("Invalid magic in B+ tree: 0x%x\n", magic);
+        return NULL;
+    }
+    page_size = GET_USHORT(buf, 9+4);
+    cur_page  = GET_USHORT(buf, 9+26);
+    level     = GET_USHORT(buf, 9+32);
+    pages     = buf + 9 + 38;
+    while (--level > 0)
+    {
+        ptr = pages + cur_page*page_size;
+        entries = GET_SHORT(ptr, 2);
+        ptr += 6;
+        for (i = 0; i < entries; i++)
+        {
+            if (comp(ptr, key, 0, (void **)&newptr) > 0) break;
+            ptr = newptr;
+        }
+        cur_page = GET_USHORT(ptr-2, 0);
+    }
+    ptr = pages + cur_page*page_size;
+    entries = GET_SHORT(ptr, 2);
+    ptr += 8;
+    for (i = 0; i < entries; i++)
+    {
+        ret = comp(ptr, key, 1, (void **)&newptr);
+        if (ret == 0) return ptr;
+        if (ret > 0) return NULL;
+        ptr = newptr;
+    }
+    return NULL;
+}
+
 /******************************************************************
  *		HLPFILE_EnumBTreeLeaves
  *
@@ -1896,21 +2017,6 @@ static void HLPFILE_EnumBTreeLeaves(cons
     }
 }
 
-struct myfncb {
-    HLPFILE*    hlpfile;
-    int         i;
-};
-
-static unsigned myfn(const BYTE* ptr, void* user)
-{
-    struct myfncb*      m = user;
-
-    m->hlpfile->Context[m->i].lHash  = GET_UINT(ptr, 0);
-    m->hlpfile->Context[m->i].offset = GET_UINT(ptr, 4);
-    m->i++;
-    return 8;
-}
-
 /***********************************************************************
  *
  *           HLPFILE_GetContext
@@ -1918,19 +2024,14 @@ static unsigned myfn(const BYTE* ptr, vo
 static BOOL HLPFILE_GetContext(HLPFILE *hlpfile)
 {
     BYTE                *cbuf, *cend;
-    struct myfncb       m;
     unsigned            clen;
 
     if (!HLPFILE_FindSubFile("|CONTEXT",  &cbuf, &cend)) {WINE_WARN("context0\n"); return FALSE;}
 
-    clen = GET_UINT(cbuf, 0x2b);
-    hlpfile->Context = HeapAlloc(GetProcessHeap(), 0, clen * sizeof(HLPFILE_CONTEXT));
+    clen = cend - cbuf;
+    hlpfile->Context = HeapAlloc(GetProcessHeap(), 0, clen);
     if (!hlpfile->Context) return FALSE;
-    hlpfile->wContextLen = clen;
-
-    m.hlpfile = hlpfile;
-    m.i = 0;
-    HLPFILE_EnumBTreeLeaves(cbuf, cend, myfn, &m);
+    memcpy(hlpfile->Context, cbuf, clen);
 
     return TRUE;
 }
diff -uHNrp wine-20071130/programs/winhelp/hlpfile.h wine-20071130e/programs/winhelp/hlpfile.h
--- wine-20071130/programs/winhelp/hlpfile.h	2007-12-01 21:14:24.000000000 +0300
+++ wine-20071130e/programs/winhelp/hlpfile.h	2008-02-04 18:31:20.000000000 +0300
@@ -104,12 +104,6 @@ typedef struct tagHlpFilePage
 
 typedef struct
 {
-    LONG                        lHash;
-    unsigned long               offset;
-} HLPFILE_CONTEXT;
-
-typedef struct
-{
     LONG                        lMap;
     unsigned long               offset;
 } HLPFILE_MAP;
@@ -128,8 +122,7 @@ typedef struct tagHlpFileFile
     LPSTR                       lpszCopyright;
     HLPFILE_PAGE*               first_page;
     HLPFILE_MACRO*              first_macro;
-    unsigned                    wContextLen;
-    HLPFILE_CONTEXT*            Context;
+    BYTE*                       Context;
     unsigned                    wMapLen;
     HLPFILE_MAP*                Map;
     unsigned long               contents_start;
@@ -141,6 +134,9 @@ typedef struct tagHlpFileFile
 
     unsigned short              version;
     unsigned short              flags;
+    unsigned short              tbsize;     /* topic block size */
+    unsigned short              dsize;      /* decompress size */
+    unsigned short              compressed;
     unsigned                    hasPhrases; /* Phrases or PhrIndex/PhrImage */
 
     unsigned                    numBmps;
diff -uHNrp wine-20071130/server/fd.c wine-20071130e/server/fd.c
--- wine-20071130/server/fd.c	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/server/fd.c	2008-02-04 18:31:20.000000000 +0300
@@ -1,7 +1,16 @@
+#define ETERSOFT
+inline void dummy_trace(void *f, ...) { }
+//#define dummy_trace fprintf
+
+#define TRACE dummy_trace
+//#define TRACEL
+#define TRACEL dummy_trace
+
 /*
  * Server-side file descriptor management
  *
  * Copyright (C) 2000, 2003 Alexandre Julliard
+ * Copyright (C) 2005, 2007 Vitaly Lipatov (implemented access&share modes based on file locking via libwine-etersoft, cifs also)
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -82,6 +91,8 @@
 #include "winternl.h"
 #include "winioctl.h"
 
+#include "wine/etersoft.h"
+
 #if defined(HAVE_SYS_EPOLL_H) && defined(HAVE_EPOLL_CREATE)
 # include <sys/epoll.h>
 # define USE_EPOLL
@@ -176,6 +187,7 @@ struct fd
     unsigned int         no_fd_status;/* status to return when unix_fd is -1 */
     int                  signaled :1; /* is the fd signaled? */
     int                  fs_locks :1; /* can we use filesystem locks for this fd? */
+    int                  cifs :1;     /* file lies on CIFS? */
     int                  poll_index;  /* index of fd in poll array */
     struct async_queue  *read_q;      /* async readers of this fd */
     struct async_queue  *write_q;     /* async writers of this fd */
@@ -931,7 +943,7 @@ static void inode_destroy( struct object
         if (fd->unix_fd != -1) close( fd->unix_fd );
         if (fd->unlink[0])
         {
-            /* make sure it is still the same file */
+            /* make sure it is still the same file and remove unlinked file */
             struct stat st;
             if (!stat( fd->unlink, &st ) && st.st_dev == inode->device->dev && st.st_ino == inode->ino)
             {
@@ -1019,7 +1031,7 @@ static int file_lock_signaled( struct ob
     return !lock->process;
 }
 
-/* set (or remove) a Unix lock if possible for the given range */
+/* set (or remove) a Unix lock if possible for the given range. returns 1 if lock permitted */
 static int set_unix_lock( struct fd *fd, file_pos_t start, file_pos_t end, int type )
 {
     struct flock fl;
@@ -1027,6 +1039,7 @@ static int set_unix_lock( struct fd *fd,
     if (!fd->fs_locks) return 1;  /* no fs locks possible for this fd */
     for (;;)
     {
+    TRACEL(stderr,"Set unix lock (%s, access=%x, F_G_R=%x)\n", (type==F_WRLCK)?"WRLCK":"RDLCK", fd->access, FILE_GENERIC_READ);
         if (start == end) return 1;  /* can't set zero-byte lock */
         if (start > max_unix_offset) return 1;  /* ignore it */
         fl.l_type   = type;
@@ -1034,12 +1047,30 @@ static int set_unix_lock( struct fd *fd,
         fl.l_start  = start;
         if (!end || end > max_unix_offset) fl.l_len = 0;
         else fl.l_len = end - start;
+        if (fd->access == FILE_GENERIC_READ && type == F_WRLCK)
+        {   /* We can't set WR lock on read only opened file */
+            TRACEL(stderr, "Try to set WR on r/o file. Check with GETK\n");
+            fl.l_type   = F_WRLCK;
+	    /* WARNING! Some races between GETLK and SETLK can be! */
+            fcntl( fd->unix_fd, F_GETLK, &fl );
+            if (fl.l_type != F_UNLCK)
+	    {
+	        TRACEL(stderr,"Already locked. \n");
+                set_error( STATUS_FILE_LOCK_CONFLICT );
+                return 0;
+            }
+            fl.l_type = F_RDLCK;
+        }
+	if (!fl.l_len) {
+		TRACEL(stderr, "LEN is NULL!!!!!!!!!!");
+	}
         if (fcntl( fd->unix_fd, F_SETLK, &fl ) != -1) return 1;
-
+	/* perror("Etersoft warning (some error during lock):"); */
         switch(errno)
         {
         case EACCES:
             /* check whether locks work at all on this file system */
+	    TRACE(stderr,"EACCES\n");
             if (fcntl( fd->unix_fd, F_GETLK, &fl ) != -1)
             {
                 set_error( STATUS_FILE_LOCK_CONFLICT );
@@ -1057,6 +1088,7 @@ static int set_unix_lock( struct fd *fd,
         case EBADF:
             /* this can happen if we try to set a write lock on a read-only file */
             /* we just ignore that error */
+	    TRACE(stderr,"EBADF - WR on R/O file\n");
             if (fl.l_type == F_WRLCK) return 1;
             set_error( STATUS_ACCESS_DENIED );
             return 0;
@@ -1120,6 +1152,7 @@ static void remove_unix_locks( struct fd
         set_unix_lock( fd, start, end, F_UNLCK );
         return;
     }
+    TRACE(stderr,"Skip unix lock :(\n");
 
     /* allocate space for the list of holes */
     /* max. number of holes is number of locks + 1 */
@@ -1343,6 +1376,30 @@ static void fd_destroy( struct object *o
     remove_fd_locks( fd );
     list_remove( &fd->inode_entry );
     if (fd->poll_index != -1) remove_poll_user( fd, fd->poll_index );
+
+#if 0 /* we can do better */
+    LOADETER_FUNC(etersoft_sharing_close);
+    if (etersoft_sharing_close)
+    {
+        /* check for special case when file on CIFS */
+        if (etersoft_sharing_close( fd->unix_fd )) {
+            /* as in usual way */
+            if (fd->inode)
+                release_object( fd->inode );
+            /* skip add_closed_fd */
+            return;
+        }
+    }
+#else
+    /* special case for file on CIFS - remove in any case */
+    if (fd->cifs) {
+        if (fd->unix_fd != -1) {
+            close( fd->unix_fd );
+            fd->unix_fd = -1;
+        }
+    }
+#endif
+
     if (fd->inode)
     {
         inode_add_closed_fd( fd->inode, fd->closed );
@@ -1413,6 +1470,7 @@ static struct fd *alloc_fd_object(void)
     fd->unix_fd    = -1;
     fd->signaled   = 1;
     fd->fs_locks   = 1;
+    fd->cifs       = 0;
     fd->poll_index = -1;
     fd->read_q     = NULL;
     fd->write_q    = NULL;
@@ -1457,6 +1515,7 @@ struct fd *alloc_pseudo_fd( const struct
     return fd;
 }
 
+
 /* set the status to return when the fd has no associated unix fd */
 void set_no_fd_status( struct fd *fd, unsigned int status )
 {
@@ -1485,6 +1544,10 @@ static int check_sharing( struct fd *fd,
             existing_access  |= fd_ptr->access;
         }
     }
+    /* Etersoft: Set existing modes from special lock region state, get cifs status */
+    if (etersoft_sharing_pre)
+        fd->cifs = etersoft_sharing_pre(fd->unix_fd, fd->access, fd->sharing,
+            &existing_access, &existing_sharing);
 
     if ((access & FILE_UNIX_READ_ACCESS) && !(existing_sharing & FILE_SHARE_READ)) return 0;
     if ((access & FILE_UNIX_WRITE_ACCESS) && !(existing_sharing & FILE_SHARE_WRITE)) return 0;
@@ -1492,6 +1555,9 @@ static int check_sharing( struct fd *fd,
     if ((existing_access & FILE_UNIX_READ_ACCESS) && !(sharing & FILE_SHARE_READ)) return 0;
     if ((existing_access & FILE_UNIX_WRITE_ACCESS) && !(sharing & FILE_SHARE_WRITE)) return 0;
     if ((existing_access & DELETE) && !(sharing & FILE_SHARE_DELETE)) return 0;
+
+     if (etersoft_sharing_post)
+         etersoft_sharing_post(fd->unix_fd, 0, 0, 0);
     return 1;
 }
 
@@ -1550,7 +1616,22 @@ struct fd *open_fd( const char *name, in
     }
     else rw_mode = O_RDONLY;
 
-    if ((fd->unix_fd = open( name, rw_mode | (flags & ~O_TRUNC), *mode )) == -1)
+    LOADETER_FUNC(etersoft_init);
+    if (etersoft_init && !etersoft_sharing_pre) {
+        TRACE(stderr, "WINE@Etersoft: Network version is running\n");
+        LOADETER_FUNC(etersoft_sharing_open);
+        LOADETER_FUNC(etersoft_sharing_pre);
+        LOADETER_FUNC(etersoft_sharing_post);
+    }
+
+    /* Etersoft: Set existing modes from special lock region state */
+    if (etersoft_sharing_open)
+        fd->unix_fd = etersoft_sharing_open(name, rw_mode | (flags & ~O_TRUNC), sharing, *mode );
+    else
+        fd->unix_fd = open(name, rw_mode | (flags & ~O_TRUNC), *mode );
+    /* Can we detect cifs here?
+    fd->cifs       = 0; */
+    if (fd->unix_fd == -1)
     {
         /* if we tried to open a directory for write access, retry read-only */
         if (errno != EISDIR ||
diff -uHNrp wine-20071130/server/main.c wine-20071130e/server/main.c
--- wine-20071130/server/main.c	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/server/main.c	2008-02-04 18:31:20.000000000 +0300
@@ -37,7 +37,7 @@
 /* command-line options */
 int debug_level = 0;
 int foreground = 0;
-timeout_t master_socket_timeout = 3 * -TICKS_PER_SEC;  /* master socket timeout, default is 3 seconds */
+timeout_t master_socket_timeout = 7 * -TICKS_PER_SEC;  /* master socket timeout, default is 7 seconds */
 const char *server_argv0;
 
 /* parse-line args */
diff -uHNrp wine-20071130/server/registry.c wine-20071130e/server/registry.c
--- wine-20071130/server/registry.c	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/server/registry.c	2008-02-04 18:31:20.000000000 +0300
@@ -1698,9 +1698,11 @@ void flush_registry(void)
     {
         if (!save_branch( save_branch_info[i].key, save_branch_info[i].path ))
         {
+/* Disable for shared access
             fprintf( stderr, "wineserver: could not save registry branch to %s",
                      save_branch_info[i].path );
             perror( " " );
+*/
         }
     }
 }
diff -uHNrp wine-20071130/tools/c2man.pl wine-20071130e/tools/c2man.pl
--- wine-20071130/tools/c2man.pl	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/tools/c2man.pl	2008-02-04 18:31:20.000000000 +0300
@@ -627,7 +627,7 @@ sub process_comment($)
 
   # When the function is exported twice we have the second name below the first
   # (you see this a lot in ntdll, but also in some other places).
-  my $first_line = ${@{$comment->{TEXT}}}[1];
+  my $first_line = $comment->{TEXT}[1];
 
   if ( $first_line =~ /^(@|[A-Za-z0-9_]+) +(\(|\[)([A-Za-z0-9_]+)\.(([0-9]+)|@)(\)|\])$/ )
   {
@@ -642,14 +642,14 @@ sub process_comment($)
       my $alt_export = @{$spec_details->{EXPORTS}}[$alt_index];
       @$alt_export[4] |= $FLAG_DOCUMENTED;
       $spec_details->{NUM_DOCS}++;
-      ${@{$comment->{TEXT}}}[1] = "";
+      $comment->{TEXT}[1] = "";
     }
   }
 
   if (@{$spec_details->{CURRENT_EXTRA}})
   {
     # We have an extra comment that might be related to this one
-    my $current_comment = ${@{$spec_details->{CURRENT_EXTRA}}}[0];
+    my $current_comment = $spec_details->{CURRENT_EXTRA}[0];
     my $current_name = $current_comment->{COMMENT_NAME};
     if ($comment->{COMMENT_NAME} =~ /^$current_name/ && $comment->{COMMENT_NAME} ne $current_name)
     {
@@ -986,7 +986,7 @@ sub process_extra_comment($)
 
   if (@{$spec_details->{CURRENT_EXTRA}})
   {
-    my $current_comment = ${@{$spec_details->{CURRENT_EXTRA}}}[0];
+    my $current_comment = $spec_details->{CURRENT_EXTRA}[0];
 
     if ($opt_verbose > 0)
     {
@@ -1072,7 +1072,7 @@ sub process_index_files()
       if (@{$spec_details->{CURRENT_EXTRA}})
       {
         # We have an unwritten extra comment, write it
-        my $current_comment = ${@{$spec_details->{CURRENT_EXTRA}}}[0];
+        my $current_comment = $spec_details->{CURRENT_EXTRA}[0];
         process_extra_comment($current_comment);
         @{$spec_details->{CURRENT_EXTRA}} = ();
        }
@@ -1468,7 +1468,7 @@ sub output_api_synopsis($)
   my $biggest_length = 0;
   for(my $i=0; $i < @{$comment->{PROTOTYPE}}; $i++)
   {
-    my $line = ${@{$comment->{PROTOTYPE}}}[$i];
+    my $line = $comment->{PROTOTYPE}[$i];
     if ($line =~ /(.+?)([A-Za-z_][A-Za-z_0-9]*)$/)
     {
       my $length = length $1;
@@ -1482,19 +1482,19 @@ sub output_api_synopsis($)
   # Now pad the string with blanks
   for(my $i=0; $i < @{$comment->{PROTOTYPE}}; $i++)
   {
-    my $line = ${@{$comment->{PROTOTYPE}}}[$i];
+    my $line = $comment->{PROTOTYPE}[$i];
     if ($line =~ /(.+?)([A-Za-z_][A-Za-z_0-9]*)$/)
     {
       my $pad_len = $biggest_length - length $1;
       my $padding = " " x ($pad_len);
-      ${@{$comment->{PROTOTYPE}}}[$i] = $1.$padding.$2;
+      $comment->{PROTOTYPE}[$i] = $1.$padding.$2;
     }
   }
 
   for(my $i=0; $i < @{$comment->{PROTOTYPE}}; $i++)
   {
     # Format the parameter name
-    my $line = ${@{$comment->{PROTOTYPE}}}[$i];
+    my $line = $comment->{PROTOTYPE}[$i];
     my $comma = ($i == @{$comment->{PROTOTYPE}}-1) ? "" : ",";
     $line =~ s/(.+?)([A-Za-z_][A-Za-z_0-9]*)$/  $fmt[0]$1$fmt[2]$2$fmt[3]$comma$fmt[1]/;
     print OUTPUT $line;
diff -uHNrp wine-20071130/tools/wine.inf wine-20071130e/tools/wine.inf
--- wine-20071130/tools/wine.inf	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/tools/wine.inf	2008-02-04 18:31:20.000000000 +0300
@@ -40,6 +40,7 @@ AddReg=\
     DirectX,\
     Environment,\
     Fonts,\
+    IE6,\
     MCI,\
     Misc,\
     Nls,\
@@ -64,6 +65,7 @@ AddReg=\
     DirectX,\
     Environment,\
     Fonts,\
+    IE6,\
     MCI,\
     Misc,\
     Nls,\
@@ -182,16 +184,16 @@ HKLM,%CurrentVersion%,"FirstInstallDateT
 HKLM,%CurrentVersion%,"ProductId",,"12345-oem-0000001-54321"
 HKLM,%CurrentVersion%,"ProgramFilesDir",,"%16422%"
 HKLM,%CurrentVersion%,"ProgramFilesPath",0x20000,"%%ProgramFiles%%"
-HKLM,%CurrentVersion%,"RegisteredOrganization",2,"Change preferred organization in ~/.wine/system.reg"
-HKLM,%CurrentVersion%,"RegisteredOwner",2,"Change preferred owner in ~/.wine/system.reg"
+HKLM,%CurrentVersion%,"RegisteredOrganization",2,"Organization"
+HKLM,%CurrentVersion%,"RegisteredOwner",2,"WINE@Etersoft User"
 HKLM,%CurrentVersion%\Controls Folder\PowerCfg,"DiskSpinDownMax",,"3600"
 HKLM,%CurrentVersion%\Controls Folder\PowerCfg,"DiskSpinDownMin",,"3"
 HKLM,%CurrentVersion%\Controls Folder\PowerCfg,"LastID",,"5"
 HKLM,%CurrentVersion%\Setup,"BootDir",,"%30%"
 HKLM,%CurrentVersion%\Setup,"SharedDir",,"%25%"
 HKLM,%CurrentVersion%\Uninstall,,,""
-HKLM,%CurrentVersionNT%,"RegisteredOrganization",2,"Change preferred organization in ~/.wine/system.reg"
-HKLM,%CurrentVersionNT%,"RegisteredOwner",2,"Change preferred owner in ~/.wine/system.reg"
+HKLM,%CurrentVersionNT%,"RegisteredOrganization",2,"Organization"
+HKLM,%CurrentVersionNT%,"RegisteredOwner",2,"WINE@Etersoft User"
 HKLM,%CurrentVersionNT%,"SystemRoot",,"%10%"
 HKLM,%CurrentVersionNT%\Fonts,,,""
 HKLM,%CurrentVersionNT%\Q246009,"Installed",,"1"
@@ -337,6 +339,7 @@ HKLM,Software\Microsoft\Rpc\SecurityServ
 HKLM,System\CurrentControlSet\Control\Session Manager,,,""
 HKLM,System\CurrentControlSet\Control\VMM32Files,,,""
 HKCU,Software\Microsoft\Protected Storage System Provider,,,""
+HKCU,Software\Wine\MSHTML,"GeckoCabDosDir",,"%10%\Downloads\"
 HKCU,Software\Wine\MSHTML,"GeckoUrl",,"http://source.winehq.org/winegecko.php"
 HKLM,HARDWARE\DEVICEMAP\PARALLEL PORTS,,,""
 HKLM,HARDWARE\DEVICEMAP\SERIALCOMM,,,""
@@ -2653,3 +2656,8 @@ HKLM,%CurrentVersionNT%,"CurrentType",2,
 HKLM,%Control%\ProductOptions,"ProductType",2,"WinNT"
 HKLM,%Control%\Windows,"CSDVersion",0x10003,0x400
 HKLM,%Control%\Session Manager\Environment,"OS",2,"Windows_NT"
+
+[IE6]
+HKLM,Software\Microsoft\Internet Explorer,"Version",,"6.0.2800.1106"
+HKLM,Software\Microsoft\Internet Explorer,"W2kVersion",,"6.0.2800.1106"
+HKLM,Software\Classes\CLSID\{25336920-03F9-11CF-8FD0-00AA00686F13}\InProcServer32,,,"C:\Windows\System\MSHTML.DLL"
diff -uHNrp wine-20071130/tools/wineshelllink wine-20071130e/tools/wineshelllink
--- wine-20071130/tools/wineshelllink	2007-12-01 21:14:25.000000000 +0300
+++ wine-20071130e/tools/wineshelllink	2008-02-04 18:31:20.000000000 +0300
@@ -31,6 +31,7 @@ menu=""
 icon=""
 descr=""
 link=""
+progname=""
 path=""
 workdir=""
 
@@ -44,6 +45,7 @@ options:
   --menu        create a menu entry
   --path xx     path to the application
   --link xx     name of link to create, including path
+  --name xx     name of link to create, in UTF8
   --args xx     command-line arguments for the application
   --icon xx     icon to display
   --workdir xx  working directory for the application
@@ -64,6 +66,7 @@ do
     --menu)    mode="menu"; shift 1 ;;
     --path)    path="$2"; shift 2 ;;
     --link)    link="$2"; shift 2 ;;
+    --name)    progname="$2"; shift 2 ;;
     --args)    args="$2"; shift 2 ;;
     --icon)    icon="$2"; shift 2 ;;
     --descr)   descr="$2"; shift 2 ;;
@@ -86,7 +89,7 @@ desktop_entry()
 {
     cat <<EOF
 [Desktop Entry]
-Name=$linkname
+Name=$progname
 Exec=env WINEPREFIX="${WINEPREFIX:-$HOME/.wine}" wine "$path" $args
 Type=Application
 StartupWMClass=Wine
